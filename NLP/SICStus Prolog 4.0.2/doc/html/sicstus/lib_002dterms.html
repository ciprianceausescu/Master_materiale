<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html lang="en">
<head>
<title>lib-terms - SICStus Prolog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="SICStus Prolog">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="The-Prolog-Library.html#The-Prolog-Library" title="The Prolog Library">
<link rel="prev" href="lib_002dsystem.html#lib_002dsystem" title="lib-system">
<link rel="next" href="lib_002dtimeout.html#lib_002dtimeout" title="lib-timeout">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link href="texinfo.css" rel="stylesheet" type="text/css">
</head>
<body>

<h3 class="section">10.24 Term Utilities&mdash;<code>library(terms)</code></h3>

<p>This library module provides miscellaneous operations on terms. 
Exported predicates:

     <dl>
<dt><code>subsumeschk(</code><var>+General</var><code>, </code><var>+Specific</var><code>)</code><dd><a name="index-subsumeschk_002f2-_0028terms_0029-2914"></a><a name="index-subsumeschk_002f2-_0028terms_0029-2915"></a>
is true when <var>Specific</var> is an instance of <var>General</var>.  It
does not bind any variables. 
<br><dt><code>subsumes(</code><var>+General</var><code>, </code><var>+Specific</var><code>)</code><dd><a name="index-subsumes_002f2-_0028terms_0029-2916"></a><a name="index-subsumes_002f2-_0028terms_0029-2917"></a>
is true when <var>Specific</var> is an instance of <var>General</var>.  It will bind
variables in <var>General</var> (but not those in <var>Specific</var>) so that <var>General</var>
becomes identical to <var>Specific</var>. 
<br><dt><code>variant(</code><var>+Term</var><code>, </code><var>+Variant</var><code>)</code><dd><a name="index-variant_002f2-_0028terms_0029-2918"></a><a name="index-variant_002f2-_0028terms_0029-2919"></a>
is true when <var>Term</var> and <var>Variant</var> are identical modulo renaming of variables,
provided <var>Term</var> and <var>Variant</var> have no variables in common. 
<br><dt><code>term_subsumer(</code><var>+Term1</var><code>, </code><var>+Term2</var><code>, </code><var>-Term</var><code>)</code><dd><a name="index-term_005fsubsumer_002f3-_0028terms_0029-2920"></a><a name="index-term_005fsubsumer_002f3-_0028terms_0029-2921"></a>
binds <var>Term</var> to a most specific generalisation of <var>Term1</var> and <var>Term2</var>. 
Using Plotkin's algorithm [Machine Intelligence 5, 1970], extended
by Dan Sahlin to handle cyclic structures. 
<br><dt><code>term_hash(</code><var>+Term</var><code>, </code><var>-Hash</var><code>)</code><dd><a name="index-term_005fhash_002f_005b2_002c4_005d-_0028terms_0029-2922"></a><a name="index-term_005fhash_002f_005b2_002c4_005d-_0028terms_0029-2923"></a>
If <var>Term</var> is ground, an integer hash value corresponding to <var>Term</var>
is unified with <var>Hash</var>.  Otherwise, the goal just succeeds. 
<br><dt><code>term_hash(</code><var>+Term</var><code>, </code><var>+Depth</var><code>, </code><var>+Range</var><code>, </code><var>-Hash</var><code>)</code><dd>If <var>Term</var> is instantiated to the given <var>Depth</var>, an integer hash value in
the range <var>[0,Range)</var> corresponding to <var>Term</var> is unified with <var>Hash</var>. 
Otherwise, the goal just succeeds. 
<br><dt><code>term_variables(</code><var>+Term</var><code>, </code><var>-Variables</var><code>)</code><dd><a name="index-term_005fvariables_002f2-_0028terms_0029-2924"></a><a name="index-term_005fvariables_002f2-_0028terms_0029-2925"></a>
True if <var>Variables</var> is the set of variables occurring in <var>Term</var>. 
<br><dt><code>term_variables_bag(</code><var>+Term</var><code>, </code><var>-Variables</var><code>)</code><dd><a name="index-term_005fvariables_005fbag_002f2-_0028terms_0029-2926"></a><a name="index-term_005fvariables_005fbag_002f2-_0028terms_0029-2927"></a>
True if <var>Variables</var> is the list of variables occurring in <var>Term</var>,
in first occurrence order. 
<br><dt><code>acyclic_term(</code><var>+X</var><code>)</code><dd><a name="index-acyclic_005fterm_002f1-_0028terms_0029-2928"></a><a name="index-acyclic_005fterm_002f1-_0028terms_0029-2929"></a>
True if <var>X</var> is finite (acyclic).  Runs in linear time. 
<br><dt><code>cyclic_term(</code><var>+X</var><code>)</code><dd><a name="index-cyclic_005fterm_002f1-_0028terms_0029-2930"></a><a name="index-cyclic_005fterm_002f1-_0028terms_0029-2931"></a>
True if <var>X</var> is infinite (cyclic).  Runs in linear time. 
<br><dt><code>term_order(</code><var>+X</var><code>, </code><var>+Y</var><code>, </code><var>-R</var><code>)</code><dd><a name="index-term_005forder_002f3-_0028terms_0029-2932"></a><a name="index-term_005forder_002f3-_0028terms_0029-2933"></a>
is true when <var>X</var> and <var>Y</var> are arbitrary terms, and <var>R</var> is <code>&lt;</code>, <code>=</code>, or <code>&gt;</code> according
as <var>X @&lt; Y</var>, <var>X == Y</var>, or <var>X @&gt; Y</var>.  This is the same as <code>compare/3</code>, except
for the argument order. 
<br><dt><code>contains_term(</code><var>+Kernel</var><code>, </code><var>+Expression</var><code>)</code><dd><a name="index-contains_005fterm_002f2-_0028terms_0029-2934"></a><a name="index-contains_005fterm_002f2-_0028terms_0029-2935"></a>
is true when the given <var>Kernel</var> occurs somewhere in the <var>Expression</var>. 
It can only be used as a test; to generate sub-terms use <code>sub_term/2</code>. 
<br><dt><code>free_of_term(</code><var>+Kernel</var><code>, </code><var>+Expression</var><code>)</code><dd><a name="index-free_005fof_005fterm_002f2-_0028terms_0029-2936"></a><a name="index-free_005fof_005fterm_002f2-_0028terms_0029-2937"></a>
is true when the given <var>Kernel</var> does not occur anywhere in the
<var>Expression</var>.  NB: if the <var>Expression</var> contains an unbound variable,
this must fail, as the <var>Kernel</var> might occur there.  Since there are
infinitely many <var>Kernels</var> not contained in any <var>Expression</var>, and also
infinitely many <var>Expressions</var> not containing any <var>Kernel</var>, it doesn't
make sense to use this except as a test. 
<br><dt><code>occurrences_of_term(</code><var>+Kernel</var><code>, </code><var>+Expression</var><code>, </code><var>-Tally</var><code>)</code><dd><a name="index-occurrences_005fof_005fterm_002f3-_0028terms_0029-2938"></a><a name="index-occurrences_005fof_005fterm_002f3-_0028terms_0029-2939"></a>
is true when the given <var>Kernel</var> occurs exactly <var>Tally</var> times in
<var>Expression</var>.  It can only be used to calculate or test <var>Tally</var>;
to enumerate <var>Kernels</var> you'll have to use <code>sub_term/2</code> and then
test them with this routine.  If you just want to find out
whether <var>Kernel</var> occurs in <var>Expression</var> or not, use <code>contains_term/2</code>
or <code>free_of_term/2</code>. 
<br><dt><code>contains_var(</code><var>+Variable</var><code>, </code><var>+Term</var><code>)</code><dd><a name="index-contains_005fvar_002f2-_0028terms_0029-2940"></a><a name="index-contains_005fvar_002f2-_0028terms_0029-2941"></a>
is true when the given <var>Term</var> contains at least one sub-term which
is identical to the given <var>Variable</var>.  We use <code>==</code> to check for
the variable (<code>contains_term/2</code> uses <code>=</code>) so it can be used to check
for arbitrary terms, not just variables. 
<br><dt><code>free_of_var(</code><var>+Variable</var><code>, </code><var>+Term</var><code>)</code><dd><a name="index-free_005fof_005fvar_002f2-_0028terms_0029-2942"></a><a name="index-free_005fof_005fvar_002f2-_0028terms_0029-2943"></a>
is true when the given <var>Term</var> contains no sub-term identical to the
given <var>Variable</var> (which may actually be any term, not just a var). 
For variables, this is precisely the "occurs check" which is
needed for sound unification. 
<br><dt><code>occurrences_of_var(</code><var>+Term</var><code>, </code><var>+Variable</var><code>, </code><var>-Tally</var><code>)</code><dd><a name="index-occurrences_005fof_005fvar_002f3-_0028terms_0029-2944"></a><a name="index-occurrences_005fof_005fvar_002f3-_0028terms_0029-2945"></a>
is true when the given <var>Variable</var> occurs exactly <var>Tally</var> times in
<var>Term</var>.  It can only be used to calculate or test <var>Tally</var>;
to enumerate Variables you'll have to use <code>sub_term/2</code> and then
test them with this routine.  If you just want to find out
whether <var>Variable</var> occurs in <var>Term</var> or not, use <code>contains_var/2</code>
or <code>free_of_var/2</code>. 
<br><dt><code>sub_term(</code><var>?Kernel</var><code>, </code><var>+Term</var><code>)</code><dd><a name="index-sub_005fterm_002f2-_0028terms_0029-2946"></a><a name="index-sub_005fterm_002f2-_0028terms_0029-2947"></a>
is true when <var>Kernel</var> is a sub-term of <var>Term</var>.  It enumerates the
sub-terms of <var>Term</var> in an arbitrary order.  Well, it is defined
that a sub-term of <var>Term</var> will be enumerated before its own
sub-terms are (but of course some of those sub-terms might be
elsewhere in <var>Term</var> as well). 
<br><dt><code>depth_bound(</code><var>+Term</var><code>, </code><var>+Bound</var><code>)</code><dd><a name="index-depth_005fbound_002f2-_0028terms_0029-2948"></a><a name="index-depth_005fbound_002f2-_0028terms_0029-2949"></a>
is true when the term depth of <var>Term</var> is no greater than <var>Bound</var>,
that is, when constructor functions are nested no more than <var>Bound</var> deep. 
Later variable bindings may invalidate this bound.  To find the
(current) depth, use <code>term_depth/2</code>. 
<br><dt><code>length_bound(</code><var>?List</var><code>, </code><var>+Bound</var><code>)</code><dd><a name="index-length_005fbound_002f2-_0028terms_0029-2950"></a><a name="index-length_005fbound_002f2-_0028terms_0029-2951"></a>
is true when the length of <var>List</var> is no greater than <var>Bound</var>.  It can be
used to enumerate Lists up to the bound. 
<br><dt><code>size_bound(</code><var>+Term</var><code>, </code><var>+Bound</var><code>)</code><dd><a name="index-size_005fbound_002f2-_0028terms_0029-2952"></a><a name="index-size_005fbound_002f2-_0028terms_0029-2953"></a>
is true when the number of constant and function symbols in <var>Term</var> is
(currently) at most <var>Bound</var>.  If <var>Term</var> is non-ground, later variable
bindings may invalidate this bound.  To find the (current) size, use
<code>term_size/2</code>. 
<br><dt><code>term_depth(</code><var>+Term</var><code>, </code><var>-Depth</var><code>)</code><dd><a name="index-term_005fdepth_002f2-_0028terms_0029-2954"></a><a name="index-term_005fdepth_002f2-_0028terms_0029-2955"></a>
     <pre class="example">          calculates the Depth of a Term, using the definition
              term_depth(Var) = 0
              term_depth(Const) = 0
              term_depth(F(T1,...,Tn)) = 1+max(term_depth(T1),...,term_depth(Tn))
     </pre>
     <br><dt><code>term_size(</code><var>+Term</var><code>, </code><var>-Size</var><code>)</code><dd><a name="index-term_005fsize_002f2-_0028terms_0029-2956"></a><a name="index-term_005fsize_002f2-_0028terms_0029-2957"></a>
calculates the <var>Size</var> of a <var>Term</var>, defined to be the number of constant and
function symbol occurrences in it. 
<br><dt><code>same_functor(</code><var>?T1</var><code>, </code><var>?T2</var><code>)</code><dd><a name="index-same_005ffunctor_002f_005b2_002c3_002c4_005d-_0028terms_0029-2958"></a><a name="index-same_005ffunctor_002f_005b2_002c3_002c4_005d-_0028terms_0029-2959"></a>
is true when <var>T1</var> and <var>T2</var> have the same principal functor.  If one of
the terms is a variable, it will be instantiated to a new term
with the same principal functor as the other term (which should be
instantiated) and with arguments being new distinct variables.  If
both terms are variables, an error is reported. 
<br><dt><code>same_functor(</code><var>?T1</var><code>, </code><var>?T2</var><code>, </code><var>?N</var><code>)</code><dd>is true when <var>T1</var> and <var>T2</var> have the same principal functor, and their
common arity is <var>N</var>. Like <code>same_functor/3</code>, at least one of <var>T1</var> and <var>T2</var>
must be bound, or an error will be reported. 
<br><dt><code>same_functor(</code><var>?T1</var><code>, </code><var>?T2</var><code>, </code><var>?F</var><code>, </code><var>?N</var><code>)</code><dd>is true when <var>T1</var> and <var>T2</var> have the same principal functor, and their
common functor is <var>F/N</var>. Given <var>T1</var> (or <var>T2</var>) the remaining arguments
can be computed.  Given <var>F</var> and <var>N</var>, the remaining arguments can be
computed.  If too many arguments are unbound, an error is reported. 
</dl>

<div class="logo">
<a href="http://www.sics.se/sicstus/">
<table><tr><td>&nbsp;</td></tr></table>
</a>
</div>
<div class="node">
<ul class="node">
<li><a href="index.html#Top">User's Manual</a>
<hr>
<li><a href="index.html#TOC">Table of Contents</a>
<li><a rel="next" accesskey="n" href="lib_002dtimeout.html#lib_002dtimeout">Next</a>
<li><a rel="previous" accesskey="p" href="lib_002dsystem.html#lib_002dsystem">Previous</a>
<li><a rel="up" accesskey="u" href="The-Prolog-Library.html#The-Prolog-Library">Up</a>
</ul>
</div>
<hr>
<a HREF="mailto:sicstus-support@sics.se?subject=Documentation%20feedback%20on%20html/sicstus/lib_002dterms.html&amp;body=Feedback%20on%20documentation%20node%20html/sicstus/lib_002dterms.html%20in%20User's%20Manual.">Send feedback on this subject.</mailto>
   </body></html>

