This is info/sicstus.info, produced by makeinfo version 4.8 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 6 November 2007.


File: sicstus.info,  Node: ref-mgc-ove,  Next: ref-mgc-gcp,  Up: ref-mgc

4.10.1 Overview
---------------

* Menu:

* ref-mgc-ove-rsp::                     Reclaiming Space
* ref-mgc-ove-sta::                     Displaying Statistics

   SICStus Prolog uses five data areas: program space, global stack,
local stack, choicepoint stack, and trail stack.  Each of these areas
is automatically expanded if it overflows.

   The local stack contains all the control information and variable
bindings needed in a Prolog execution.  Space on the local stack is
reclaimed on determinate success of predicates and by tail recursion
optimization, as well as on backtracking.

   The choicepoint stack contains data representing outstanding choices
for some goals or disjunctions.  Space on the choicepoint stack is
reclaimed on backtracking.

   The global stack contains all the data structures constructed in an
execution of the program.  This area grows with forward execution and
shrinks on backtracking.

   The trail stack contains references to all the variables that need
to be reset when backtracking occurs.  This area grows with forward
execution and shrinks on backtracking.

   The program space contains compiled and interpreted code, recorded
terms, and atoms.  The space occupied by compiled code, interpreted
code, and recorded terms is recovered when it is no longer needed; the
space occupied by atoms that are no longer in use can be recovered by
atom garbage collection described in *Note ref-mgc-ago::.

   These fluctuations in memory usage of the above areas can be
monitored by `statistics/[0,2]'.

   SICStus Prolog uses the global stack to construct compound terms,
including lists.  Global Stack space is used as Prolog execution moves
forward.  When Prolog backtracks, it automatically reclaims space on
the global stack.  However, if a program uses a large amount of space
before failure and backtracking occur, this type of reclamation may be
inadequate.

   Without garbage collection, the Prolog system must attempt to expand
the global stack whenever a global stack overflow occurs.  To do this,
it first requests additional space from the operating system.  If no
more space is available, the Prolog system attempts to allocate unused
space from the other Prolog data areas.  If additional space cannot be
found, a resource error is raised.

   Global stack expansion and abnormal termination of execution due to
lack of stack space can occur even if there are structures on the
global stack that are no longer accessible to the computation (these
structures are what is meant by "garbage").  The proportion of garbage
to non-garbage terms varies during execution and with the Prolog code
being executed.  The global stack may contain no garbage at all, or may
be nearly all garbage.

   The  garbage collector periodically reclaims inaccessible global
stack space, reducing the need for global stack expansion and lessening
the likelihood of running out of global stack.  When the garbage
collector is enabled (as it is by default), the system makes fewer
requests to the operating system for additional space.  The fact that
less space is required from the operating system can produce a
substantial savings in the time taken to run a program, because paging
overhead can be much less.

   For example, without garbage collection, compiling a file containing
the sequence
     p(_) :- p([a]).
     :- p(_).

causes the global stack to expand until the Prolog process eventually
runs out of space.  With garbage collection enabled, the above sequence
continues indefinitely.  The list built on the global stack by each
recursive call is inaccessible to future calls (since `p/1' ignores its
argument) and can be reclaimed by the garbage collector.

   Garbage collection does not guarantee freedom from out-of-space
errors, however.  Compiling a file containing the sequence
     p(X) :- p([X]).
     :- p(a).

expands the global stack until the Prolog process eventually runs out of
space.  This happens in spite of the garbage collector, because all the
terms built on the global stack are accessible to future computation
and cannot be reclaimed.


File: sicstus.info,  Node: ref-mgc-ove-rsp,  Next: ref-mgc-ove-sta,  Up: ref-mgc-ove

4.10.1.1 Reclaiming Space
.........................

`trimcore/0' reclaims space in all of Prolog's data areas.  At any
given time, each data area contains some free space.  For example, the
local stack space contains the local stack and some free space for that
stack to grow into.  The data area is automatically expanded when it
runs out of free space, and it remains expanded until `trimcore/0' is
called, even though the stack may have shrunk considerably in the
meantime.  The effect of `trimcore/0' is to reduce the free space in
all the data areas as much as possible, and to give the space no longer
needed back to the operating system.  `trimcore/0' is called each time
Prolog returns to the top level or the top of a break level.


File: sicstus.info,  Node: ref-mgc-ove-sta,  Prev: ref-mgc-ove-rsp,  Up: ref-mgc-ove

4.10.1.2 Displaying Statistics
..............................

Statistics relating to memory usage, run time, and garbage collection,
including information about which areas of memory have overflowed and
how much time has been spent expanding them, can be displayed by
calling `statistics/0'.

   The output from `statistics/0' looks like this:

     memory (total)       1718512 bytes
        global stack       185472 bytes:       1784 in use,    183688 free
        local stack         10496 bytes:        308 in use,     10188 free
        trail stack         92750 bytes:        244 in use,     92506 free
        control stack       92722 bytes:        216 in use,     92506 free
        atoms              109849 bytes:       3698 in use,   1044877 free
        program space     1337072 bytes:    1048136 in use,    288936 free
        program space breakdown:
                 compiled code               469800 bytes
                 predicate                   134624 bytes
                 try_node                    129632 bytes
                 atom                        123064 bytes
                 sw_on_key                    92592 bytes
                 incore_info                  43392 bytes
                 atom table                   36864 bytes
                 interpreted code              7656 bytes
                 atom buffer                   2560 bytes
                 miscellaneous                 2096 bytes
                 BDD hash table                1560 bytes
                 numstack                      1024 bytes
                 FLI stack                     1024 bytes
                 SP_malloc                      952 bytes
                 int_info                       688 bytes
                 source info (itable)           368 bytes
                 module                         128 bytes
                 source info (lheap)             80 bytes
                 foreign resource                32 bytes
         No memory resource errors

            0.000 sec. for 3 global, 21 local, and 0 control space overflows
            0.000 sec. for 0 garbage collections which collected 0 bytes
            0.000 sec. for 0 atom garbage collections which collected 0 atoms 0 bytes
            0.010 sec. for 1 memory defragmentations
            0.420 sec. runtime
           26.100 sec. elapsed time

   Note the use of indentation to indicate sub-areas.  That is, memory
contains the program space, global space, and local stack, and the
global space contains the global stack and trail.

   The memory (total) figure shown as "in use" is the sum of the spaces
for the program space and stacks. The "free" figures for the stacks are
for free space within those areas.  However, this free space is
considered used as far as the memory (total) area is concerned, because
it has been allocated to the stacks. The program space is not
considered to have its own free space.  It always allocates new space
from the general memory (total) free area.

   If a memory resource error has occurred previously in the execution,
the memory area for which memory could not be allocated is displayed.

   Individual statistics can be obtained by `statistics/2', which
accepts a keyword and returns a list of statistics related to that
keyword.

   The keys and values for `statistics(KEYWORD, LIST)' are summarized
below.  The keywords `core' and `heap' are included to retain
compatibility with other Prologs.  Times are given in milliseconds and
sizes are given in bytes.

`KEYWORD'
     LIST

`global_stack'
     `[SIZE USED,FREE]'
     This refers to the global stack, where compound terms are stored.
     The values are gathered before the list holding the answers is
     allocated.

`local_stack'
     `[SIZE USED,FREE]'
     This refers to the local stack, where recursive predicate
     environments are stored.

`trail'
     `[SIZE USED,FREE]'
     This refers to the trail stack, where conditional variable
     bindings are recorded.

`choice'
     `[SIZE USED,FREE]'
     This refers to the choicepoint stack, where partial states are
     stored for backtracking purposes.

`core'
`memory'
     `[SIZE USED,0]'
     These refer to the amount of memory actually allocated by the
     Prolog engine.  The zero is there for compatibility with other
     Prolog implementations.

`heap'
`program'
     `[SIZE USED,SIZE FREE]'
     These refer to the amount of memory allocated for the database,
     symbol tables, and the like.

`runtime'
     `[SINCE START OF PROLOG,SINCE PREVIOUS STATISTICS]' These refer to
     CPU time used while executing, excluding time spent garbage
     collecting, stack shifting, or in system calls.  The second
     element is the time since the last call to `statistics/2' with
     this key. It is not affected by calls to `statistics/0'.

`total_runtime'
     `[SINCE START OF PROLOG,SINCE PREVIOUS STATISTICS]' These refer to
     total CPU time used while executing, including memory management
     such as garbage collection but excluding system calls.  The second
     element is the time since the last call to `statistics/2' with
     this key. It is not affected by calls to `statistics/0'.

`walltime'
     `[SINCE START OF PROLOG,SINCE PREVIOUS STATISTICS]' These refer to
     absolute time elapsed.  The second element is the time since the
     last call to `statistics/2' with this key. It is not affected by
     calls to `statistics/0'.

`garbage_collection'
     `[NO. OF GCS,BYTES FREED,TIME SPENT]'

`stack_shifts'
     `[NO. OF GLOBAL SHIFTS,NO. OF LOCAL/TRAILTRAIL SHIFTS,TIME SPENT]'

`atoms'
     `[NO. OF ATOMS,BYTES USED,ATOMS FREE]' The number of atoms free is
     the number of atoms allocated (the first element in the list)
     subtracted from the maximum number of atoms, i.e. 262143
     (33554431) on 32-bit (64-bit) architectures. Note that atom
     garbage collection may be able to reclaim some of the allocated
     atoms.

`atom_garbage_collection'
     `[NO. OF AGCS,BYTES FREED,TIME SPENT]'

`defragmentation'
     `[NO. OF DEFRAGMENTATIONS,TIME SPENT]'


   To see an example of the use of each of these keywords, type
     | ?- statistics(K, L).

and then repeatedly type `;' to backtrack through all the possible
keywords.  As an additional example, to report information on the
runtime of a predicate `p/0', add the following to your program:

     :- statistics(runtime, [T0| _]),
        p,
        statistics(runtime, [T1|_]),
        T is T1 - T0,
        format('p/0 took ~3d sec.~n', [T]).


File: sicstus.info,  Node: ref-mgc-gcp,  Next: ref-mgc-egc,  Prev: ref-mgc-ove,  Up: ref-mgc

4.10.2 Garbage Collection and Programming Style
-----------------------------------------------

The availability of garbage collection can lead to a more natural
programming style.  Without garbage collection, a procedure that
generates heap garbage may have to be executed in a failure-driven loop.
Failure-driven loops minimize heap usage from iteration to iteration of
a loop via SICStus Prolog's automatic recovery of heap space on failure.
For instance, in the following procedure `echo/0' echoes Prolog terms
until it reads an end-of-file character.  It uses a failure-driven loop
to recover inaccessible heap space.
     echo :- repeat,
             read(Term),
             echo_term(Term),
             !.

     echo_term(Term) :-
             Term == end_of_file.
     echo_term(Term) :-
             write(Term), nl,
             fail.

   Any heap garbage generated by `read/1' or `write/1' is automatically
reclaimed by the failure of each iteration.

   Although failure-driven loops are an accepted Prolog idiom, they are
not particularly easy to read or understand.  So we might choose to
write a clearer version of `echo/0' using recursion instead, as in
     echo :- read(Term),
             echo_term(Term).

     echo_term(Term) :-
             Term == end_of_file,
             !.
     echo_term(Term) :-
             write(Term), nl,
             echo.

   Without garbage collection the more natural recursive loop
accumulates heap garbage that cannot be reclaimed automatically.  While
it is unlikely that this trivial example will run out of heap space,
larger and more practical applications may be unable to use the clearer
recursive style without garbage collection.  With garbage collection,
all inaccessible heap space will be reclaimed by the garbage collector.

   Using recursion rather than failure-driven loops can improve
programming style further.  We might want to write a predicate that
reads terms and collects them in a list.  This is naturally done in a
recursive loop by accumulating results in a list that is passed from
iteration to iteration.  For instance,
     collect(List) :-
             read(Term),
             collect_term(Term, List).

     collect_term(Term, []) :-
             Term == end_of_file,
             !.
     collect_term(Term, [Term|List0]) :-
             collect(List0).

   For more complex applications this sort of construction might prove
unusable without garbage collection.  Instead, we may be forced to use a
failure-driven loop with side-effects to store partial results, as in
the following much less readable version of `collect/1':
     collect(List) :-
             repeat,
             read(Term),
             store_term(Term),
             !,
             collect_terms(List).

     store_term(Term) :-
             Term == end_of_file.

     store_term(Term) :-
             assertz(term(Term)),
             fail.

     collect_terms([M|List]) :-
             retract(term(M)),
             !,
             collect_terms(List).
     collect_terms([]).

   The variable bindings made in one iteration of a failure-driven loop
are unbound on failure of the iteration.  Thus partial results cannot
simply be stored in a data structure that is passed along to the next
iteration.  We must instead resort to storing partial results via
side-effects (here, `assertz/1') and collect (and clean up) partial
results in a separate pass.  The second example is much less clear to
most people than the first.  It is also much less efficient than the
first.  However,  if there were no garbage collector, larger examples
of the second type might be able to run where those of the first type
would run out of memory.


File: sicstus.info,  Node: ref-mgc-egc,  Next: ref-mgc-mgc,  Prev: ref-mgc-gcp,  Up: ref-mgc

4.10.3 Enabling and Disabling the Garbage Collector
---------------------------------------------------

The user has the option of executing programs with or without garbage
collection.  Procedures that do not use a large amount of heap space
before backtracking may not be affected when garbage collection is
enabled.  Procedures that do use a large amount of heap space may
execute more slowly due to the time spent garbage collecting, but will
be more likely to run to completion.  On the other hand, such programs
may run faster when the garbage collector is enabled because the
virtual memory is not expanded to the extent that "thrashing" occurs.
The `gc' Prolog flag can be set to `on' or `off'.  To monitor garbage
collections in verbose mode, set the `gc_trace' flag to `verbose'.  By
default, garbage collection is enabled.  


File: sicstus.info,  Node: ref-mgc-mgc,  Next: ref-mgc-gch,  Prev: ref-mgc-egc,  Up: ref-mgc

4.10.4 Monitoring Garbage Collections
-------------------------------------

By default, the user is given no indication that the garbage collector
is operating.  If no program ever runs out of space and no program
using a lot of heap space requires an inordinate amount of processing
time, such information is unlikely to be needed.

   However, if a program thought to be using much heap space runs out of
space or runs inordinately slowly, the user may want to determine
whether more or less frequent garbage collections are necessary.
Information obtained from the garbage collector by turning on the
`gc_trace' Prolog flag can be helpful in this determination.  


File: sicstus.info,  Node: ref-mgc-gch,  Next: ref-mgc-gcd,  Prev: ref-mgc-mgc,  Up: ref-mgc

4.10.5 Interaction of Garbage Collection and Heap Expansion
-----------------------------------------------------------

For most programs, the default settings for the garbage collection
parameters should suffice.  For programs that have high heap
requirements, the default parameters may result in a higher ratio of
garbage collection time to run time.  These programs should be given
more space in which to run.

   The `gc_margin' is a non-negative integer specifying the desired
margin in kilobytes.  For example, the default value of 1000 means that
the heap will not be expanded if garbage collection can reclaim at least
one megabyte.  The advantage of this criterion is that it takes into
account both the user's estimate of the heap usage and the
effectiveness of garbage collecting.

  1.  Setting the `gc_margin' higher than the default will cause fewer
     heap expansions and garbage collections.  However, it will use
     more space, and garbage collections will be more time-consuming
     when they do occur.

     Setting the margin too large will cause the heap to expand so that
     if it does overflow, the resulting garbage collection will
     significantly disrupt normal processing.  This will be especially
     so if much of the heap is accessible to future computation.

  2.  Setting the `gc_margin' lower than the default will use less
     space, and garbage collections will be less time-consuming.
     However, it will cause more heap expansions and garbage
     collections.

     Setting the margin too small will cause many garbage collections
     in a small amount of time, so that the ratio of garbage-collecting
     time to computation time will be abnormally high.

  3. Setting the margin correctly will cause the heap to expand to a
     size where expansions and garbage collections are infrequent and
     garbage collections are not too time-consuming, if they occur at
     all.

   The correct value for the `gc_margin' is dependent upon many factors.
Here is a non-prioritized list of some of them:
   * The amount of memory available to the Prolog process

   * The maximum memory limit imposed on the Prolog process

   * The program's rate of heap garbage generation

   * The program's rate of heap non-garbage generation

   * The program's backtracking behavior

   * The amount of time needed to collect the generated garbage

   * The growth rate of the other Prolog stacks

   The algorithm used when the heap overflows is as follows:


     if `gc' is on
     and the heap is larger than `gc_margin' kilobytes then
        garbage collect the heap
        if less than `gc_margin' kilobytes are reclaimed then
           try to expand the heap
        endif
     else
        try to expand the heap
     endif

   The user can use the `gc_margin' option of `prolog_flag/3' to reset
the `gc_margin' (see *Note ref-lps-ove::).  If a garbage collection
reclaims at least the `gc_margin' kilobytes of heap space the heap is
not expanded after garbage collection completes.  Otherwise, the heap
is expanded after garbage collection.  This expansion provides space
for the future heap usage that will presumably occur.  In addition, no
garbage collection occurs if the heap is smaller than `gc_margin'
kilobytes.


File: sicstus.info,  Node: ref-mgc-gcd,  Next: ref-mgc-ago,  Prev: ref-mgc-gch,  Up: ref-mgc

4.10.6 Invoking the Garbage Collector Directly
----------------------------------------------

Normally, the garbage collector is invoked only when some Prolog data
area overflows, so the time of its invocation is not predictable.  In
some applications it may be desirable to invoke the garbage collector
at regular intervals (when there is known to be a significant amount of
garbage on the heap) so that the time spent garbage collecting is more
evenly distributed in the processing time.  For instance, it may prove
desirable to invoke the garbage collector after each iteration of a
question-and-answer loop that is not failure-driven.

   In rare cases the default garbage collection parameters result in
excessive garbage collecting costs or heap expansion, and the user
cannot tune the `gc_margin' parameter adequately.  Explicitly invoking
the garbage collector using the built-in predicate `garbage_collect/0'
can be useful in these circumstances.  


File: sicstus.info,  Node: ref-mgc-ago,  Next: ref-mgc-sum,  Prev: ref-mgc-gcd,  Up: ref-mgc

4.10.7 Atom Garbage Collection
------------------------------

* Menu:

* ref-mgc-ago-agc::                     The Atom Garbage Collector User Interface
* ref-mgc-ago-pat::                     Protecting Atoms in Foreign Memory
* ref-mgc-ago-prm::                     Permanent Atoms
* ref-mgc-ago-are::                     Details of Atom Registration

   By default, atoms created during the execution of a program remain
permanently in the system until Prolog exits. For the majority of
applications this behavior is not a problem and can be ignored.
However, for two classes of application this can present problems.
Firstly the internal architecture of SICStus Prolog limits the number
of atoms that be can created to 1,048,575 on 32-bit machines, and this
can be a problem for database applications that read large numbers of
atoms from a database. Secondly, the space occupied by atoms can become
significant and dominate memory usage, which can be a problem for
processes designed to run perpetually.

   These problems can be overcome by using atom garbage collection to
reclaim atoms that are no longer accessible to the executing program.

   Atoms can be created in many ways: when an appropriate token is read
with `read_term/3', when source or PO files are loaded, when
`atom_codes/2' is called with a character list, or when
`SP_atom_from_string()' is called in C code.  In any of these contexts
an atom is only created if it does not already exist; all atoms for a
given string are given the same identification number, which is
different from the atom of any other string.  Thus, atom recognition
and comparison can be done quickly, without having to look at strings.
An occurrence of an atom is always of a fixed, small size, so where a
given atom is likely to be used in several places simultaneously the
use of atoms can also be more compact than the use of strings.

   A Prolog functor is implemented like an atom, but also has an
associated arity.  For the purposes of atom garbage collection, a
functor is considered to be an occurrence of the atom of that same name.

   Atom garbage collection is similar to heap garbage collection,
invoked automatically as well as through a call to the built-in
predicate `garbage_collect_atoms/0'.  The atom garbage collector scans
Prolog's data areas looking for atoms that are currently in use and
then throws away all unused atoms, reclaiming their space.

   Atom garbage collection can turn an application that continually
grows and eventually either runs into the atom number limit or runs out
of space into one that can run perpetually.  It can also make feasible
applications that load and manipulate huge quantities of atom-rich data
that would otherwise become full of useless atoms.


File: sicstus.info,  Node: ref-mgc-ago-agc,  Next: ref-mgc-ago-pat,  Up: ref-mgc-ago

4.10.7.1 The Atom Garbage Collector User Interface
..................................................

Because the creation of atoms does not follow any other system behaviors
like memory growth or heap garbage collection, SICStus has chosen to
keep the invocation of atom garbage collection independent of any other
operation and to keep the invocation of atom garbage collection explicit
rather than making it automatic.  It is often preferable for the
programmer to control when it will occur in case preparations need to
be made for it.

   Atom garbage collection is invoked automatically when the number of
new atoms created since the last atom garbage collection reaches the
value of the `agc_margin' flag.

   Atom garbage collection can be invoked explicitly by calling
`garbage_collect_atoms/0'.  The predicate normally succeeds silently.
The user may determine whether to invoke atom garbage collection at a
given point based on information returned from a call to `statistics/2'
with the keyword `atoms'.  That call returns a list of the form

     [NUMBER OF ATOMS, ATOM SPACE IN USE, ATOM SPACE FREE]

   For example,

     | ?- statistics(atoms, Stats).

     Stats = [4313,121062,31032]

   One would typically choose to call `garbage_collect_atoms/0' prior
to each iteration of an iterative application, when either the number
of atoms or the atom space in use passes some threshold, e.g.

     <driver loop> :-
             ...
             repeat,
                maybe_atom_gc,
                <do next iteration>
                ...
             fail.
     <driver loop>.

where

     maybe_atom_gc :-
             statistics(atoms, [_,Inuse,_]),
             atom_gc_space_threshold(Space),
             ( Inuse > Space -> garbage_collect_atoms ; true ).

     % Atom GC if there are more than 100000 bytes of atoms:
     atom_gc_space_threshold(100000).

   More sophisticated approaches might use both atom number, atom space
and `agc_margin' thresholds, or could adjust a threshold if atom
garbage collection didn't free an adequate number of atoms.

   To be most effective, atom garbage collection should be called when
as few as possible atoms are actually in use.  In the above example,
for instance, it makes the most sense to do atom garbage collection at
the beginning of each iteration rather than at the end, as at the
beginning of the iteration the previous failure may just have freed
large amounts of atom-rich global and local stack.  Similarly, it's
better to invoke atom garbage collection after abolishing or retracting
a large database than to do so before.


File: sicstus.info,  Node: ref-mgc-ago-pat,  Next: ref-mgc-ago-prm,  Prev: ref-mgc-ago-agc,  Up: ref-mgc-ago

4.10.7.2 Protecting Atoms in Foreign Memory
...........................................

SICStus Prolog's foreign language interface allows atoms to be passed
to foreign functions.  When calling foreign functions from Prolog,
atoms are passed via the `+atom' argument type in the predicate
specifications of `foreign/[2,3]' facts.  The strings of atoms can be
passed to foreign functions via the `+string' argument type.  In the
latter case a pointer to the Prolog symbol table's copy of the string
for an atom is what is passed.  When calling Prolog from C, atoms are
passed back from C to Prolog using the `-atom' and `-string' argument
types in `extern/1' declarations.  Atoms can also be created in foreign
code via functions like `SP_atom_from_string()'.

   Prolog does not keep track of atoms (or strings of atoms) stored in
foreign memory.  As such, it cannot guarantee that those atoms will be
retained by atom garbage collection.  Therefore SICStus Prolog provides
functions to "register" atoms (or their strings) with the atom garbage
collector.  Registered atoms will not be reclaimed by the atom garbage
collector.  Atoms can be registered while it is undesirable for them to
be reclaimed, and then unregistered when they are no longer needed.

   Of course, the majority of atoms passed as atoms or strings to
foreign functions do not need to be registered.  Only those that will
be stored across foreign function calls (in global variables) or across
nested calls to Prolog are at risk.  An extra margin of control is
given by the fact the programmer always invokes atom garbage collection
explicitly, and can ensure that this is only done in contexts that are
"safe" for the individual application.

   To register or unregister an atom, one of the following functions is
used:

     int SP_register_atom(atom)
     SP_atom atom;

     int SP_unregister_atom(atom)
     SP_atom atom;

   These functions return either `SP_ERROR' or a non-negative integer.
The return values are discussed further in *Note ref-mgc-ago-are::.

   As noted above, when an atom is passed as a string (`+string') to a
foreign function, the string the foreign function receives is the one
in Prolog's symbol table.  When atom garbage collection reclaims the
atom for that string, the space for the string will also be reclaimed.

   Thus, if the string is to be stored across foreign calls, either a
copy of the string or else the atom (`+atom') should be passed into the
foreign function so that it can be registered and
`SP_string_from_atom()' can be used to access the string from the atom.

   Keep in mind that the registration of atoms only pertains to those
passed to foreign functions or created in foreign code.  Atoms in
Prolog's data areas are maintained automatically.  Note also that even
though an atom may be unregistered in foreign code, atom garbage
collection still may not reclaim it as it may be referenced from
Prolog's data areas.  But if an atom is registered in foreign code, it
will be preserved regardless of its presence in Prolog's data areas.

   The following example illustrates the use of these functions. In this
example the current value of an object (which is an atom) is being
stored in a C global variable. There are two C functions that can be
called from Prolog, one to update the current value and one to access
the value.

     #include <sicstus/sicstus.h>

     SP_atom current_object = NULL;

     update_object(newvalue)
     SP_atom newvalue;
     {
             /* if current_object contains an atom, unregister it */
             if (current_object)
                     (void) SP_unregister_atom(current_object);

             /* register new value */
             (void) SP_register_atom(newvalue);
             current_object = newvalue;
     }

     SP_atom get_object()
     {
             return current_object;
     }


File: sicstus.info,  Node: ref-mgc-ago-prm,  Next: ref-mgc-ago-are,  Prev: ref-mgc-ago-pat,  Up: ref-mgc-ago

4.10.7.3 Permanent Atoms
........................

Atom garbage collection scans all Prolog's dynamic data areas when
looking for atoms that are in use.  Scanning finds atoms in the Prolog
stacks and in all compiled and interpreted code that has been
dynamically loaded into Prolog via `consult/1', `use_module/1',
`assert/2', etc.  However, there are certain potential sources of atoms
in the Prolog image from which atoms cannot be reclaimed.  Atoms for
Prolog code that has been statically linked with either the Prolog
Development Environment or the Runtime Environment have been placed in
the text space, making them (and the code that contains them)
effectively permanent.  Although such code can be abolished, its space
can never be reclaimed.

   These atoms are internally flagged as permanent by the system and are
always retained by atom garbage collection.  An atom that has become
permanent cannot be made non-permanent, so can never be reclaimed.


File: sicstus.info,  Node: ref-mgc-ago-are,  Prev: ref-mgc-ago-prm,  Up: ref-mgc-ago

4.10.7.4 Details of Atom Registration
.....................................

The functions that register and unregister atoms are in fact using
reference counting to keep track of atoms that have been registered.
As a result, it is safe to combine your code with libraries and code
others have written.  If the other code has been careful to register
and unregister its atoms as appropriate, atoms will not be reclaimed
until everyone has unregistered them.

   Of course, it is possible when writing code that needs to register
atoms that errors could occur.  Atoms that are registered too many
times simply will not be garbage collected until they are fully
unregistered.  However, atoms that aren't registered when they should
be may be reclaimed on atom garbage collection.  One normally doesn't
need to think about the reference counting going on in
`SP_register_atom()' and `SP_unregister_atom()', but some understanding
of its details could prove helpful when debugging.

   To help you diagnose problems with registering and unregistering
atoms, `SP_register_atom()' and `SP_unregister_atom()' both normally
return the current reference count for the atom.  If an error occurs,
e.g. a nonexistent atom is registered or unregistered, `SP_ERROR' is
returned.

   An unregistered atom has a reference count of 0.  Unregistering an
atom that is unregistered is a no-op; in this case,
`SP_unregister_atom()' returns 0.  A permanent atom has a reference
count of 256.  In addition, if an atom is simultaneously registered 256
times, it becomes permanent.  (An atom with 256 distinct references is
an unlikely candidate for reclamation!)  Registering or unregistering
an atom that is permanent is also a no-op;  `SP_register_atom()' and
`SP_unregister_atom()' return 256.


File: sicstus.info,  Node: ref-mgc-sum,  Prev: ref-mgc-ago,  Up: ref-mgc

4.10.8 Summary of Predicates
----------------------------

`garbage_collect'
     force an immediate garbage collection

`garbage_collect_atoms'
     garbage collect atom space

`statistics'
     display various execution statistics

`statistics(?K,?V)'
     the execution statistic with key K has value V

`trimcore'
     reduce free stack space to a minimum



File: sicstus.info,  Node: ref-mod,  Next: ref-mdb,  Prev: ref-mgc,  Up: Prolog Intro

4.11 Modules
============

* Menu:

* ref-mod-ove::                         Overview
* ref-mod-bas::                         Basic Concepts
* ref-mod-def::                         Defining a Module
* ref-mod-n2m::                         Converting Non-module-files into Module-files
* ref-mod-lod::                         Loading a Module
* ref-mod-vis::                         Visibility Rules
* ref-mod-som::                         The Source Module
* ref-mod-tyi::                         The Type-in Module
* ref-mod-dmo::                         Creating a Module Dynamically
* ref-mod-mpc::                         Module Prefixes on Clauses
* ref-mod-cim::                         Debugging Code in a Module
* ref-mod-ncl::                         Name Clashes
* ref-mod-ilm::                         Obtaining Information about Loaded Modules
* ref-mod-idp::                         Importing Dynamic Predicates
* ref-mod-mne::                         Module Name Expansion
* ref-mod-met::                         The meta_predicate Declaration
* ref-mod-sem::                         Semantics of Module Name Expansion
* ref-mod-sum::                         Predicate Summary


File: sicstus.info,  Node: ref-mod-ove,  Next: ref-mod-bas,  Up: ref-mod

4.11.1 Overview
---------------

The module system lets the user divide large Prolog programs into
"modules", or rather smaller sub-programs, and define the interfaces
between those modules.  Each module has its own name space; that is, a
predicate defined in one module is distinct from any predicates with
the same name and arity that may be defined in other modules.  The
module system encourages a group of programmers to define the
dependence each has on others' work before any code is written, and
subsequently allows all to work on their own parts independently.  It
also helps to make library predicates behave as extensions of the
existing set of built-in predicates.

   The SICStus Prolog library uses the module system and can therefore
serve as an extended example of the concepts presented in the following
text.  The design of the module system is such that loading library
files and calling library predicates can be performed without knowledge
of the module system.

   Some points to note about the module system are that:
   * It is based on predicate modularity rather than on data
     modularity; that is, atoms and functors are global.  

   * It is flat rather than hierarchical; any module may refer to any
     other module by its name--there is no need to specify a path of
     modules.

   * It is not strict; modularity rules can be explicitly overridden.
     This is primarily for flexibility during debugging.

   * It is efficient; calls to predicates across module boundaries incur
     little or no overhead.


File: sicstus.info,  Node: ref-mod-bas,  Next: ref-mod-def,  Prev: ref-mod-ove,  Up: ref-mod

4.11.2 Basic Concepts
---------------------

Each predicate in a program is identified by its "module", as well as by
its name and arity.

   A module defines a set of predicates, among which some have the
property of being "public".  Public predicates are predicates that can
be "imported" by other modules, which means that they can then be
called from within those modules.  Predicates that are not public are
"private" to the module in which they are defined; that is, they cannot
be called from outside that module (except by explicitly overriding the
modularity rules as described in *Note ref-mod-vis::).

   There are two kinds of importation:

  1. A module M1 may import a specified set of predicates from another
     module M2.  All the specified predicates should be public in M2.

  2. A module M1 may import all the public predicates of another module
     M2.

   Built-in predicates do not need to be imported; they are
automatically available from within any module.

   There is a special module called `user', which is used by default
when predicates are being defined and no other module has been
specified.

   The other predefined module is the `prolog' module where all the
built-in predicates reside.  The exported built-in predicates are
automatically imported into each new module as it is created.

   If you are using a program written by someone else, you need not be
concerned as to whether or not that program has been made into a module.
The act of loading a module from a file using `compile/1', or
`ensure_loaded/1' (see *Note ref-lod::) will automatically import all
the public predicates in that module.  Thus the command
     :- ensure_loaded(library(basics)).

will load the basic list-processing predicates from the library and make
them available.


File: sicstus.info,  Node: ref-mod-def,  Next: ref-mod-n2m,  Prev: ref-mod-bas,  Up: ref-mod

4.11.3 Defining a Module
------------------------

The normal way to define a module is by creating a "module-file" for it
and loading it into the Prolog system.  A module-file is a Prolog file
that begins with a "module declaration".

   A module declaration has one of the forms:
     :- module(+MODULENAME, +PUBLICPREDLIST).

     :- module(+MODULENAME, +PUBLICPREDLIST, +OPTIONS).

   Such a declaration must appear as the first term in a file, and
declares that file to be a module-file.  The predicates in the file
will become part of the module MODULENAME, and the predicates specified
in PUBLICPREDLIST are those that can be imported by other modules; that
is, the public predicates of this module.

   OPTIONS is an optional argument, and should be a list.  The only
available option is `hidden(BOOLEAN)', where BOOLEAN is `false' (the
default) or `true'.  In the latter case, tracing of the predicates of
the module is disabled (although spypoints can be set), and no source
information is generated at compile time.

   Instead of creating and loading a module-file, it is also possible
to define a module dynamically by, for example, asserting clauses into
a specified module.  A module created in this way has no public
predicates; all its predicates are private.  This means that they
cannot be called from outside that module except by explicitly
overriding the modularity rules as described in *Note ref-mod-vis::.
Dynamic creation of modules is described in more detail in *Note
ref-mod-dmo::.


File: sicstus.info,  Node: ref-mod-n2m,  Next: ref-mod-lod,  Prev: ref-mod-def,  Up: ref-mod

4.11.4 Converting Non-module-files into Module-files
----------------------------------------------------

The Prolog cross-referencer can automatically generate `module/2'
declarations from its cross-reference information.  This is useful if
you want to take a set of files making up a program and make each of
those files into a module-file.  For more information, *note The
Cross-Referencer::

   Alternatively, if you have a complete Prolog program consisting of a
set of source files `{file1, file2, ...}', and you wish to encapsulate
it in a single module MOD, this can be done by creating a "driver" file
of the following form:


     :- module(MOD, [ ... ]).

     :- ensure_loaded(file1).
     :- ensure_loaded(file2).
        .
        .
        .

   When a module is created in this way, none of the files in the
program `{file1, file2, ...}' have to be changed.


File: sicstus.info,  Node: ref-mod-lod,  Next: ref-mod-vis,  Prev: ref-mod-n2m,  Up: ref-mod

4.11.5 Loading a Module
-----------------------

To gain access to the public predicates of a module-file, load it as you
would any other file--using `compile/1', or `ensure_loaded/1' as
appropriate.  For example, if your code contains a directive such as
     :- ensure_loaded(FILE).

this directive will load the appropriate file FILE whether or not FILE
is a module-file.  The only difference is that if FILE is a module-file
any private predicates that it defines will not be visible to your
program.

   The load predicates are adequate for use at Prolog's top level, or
when the file being loaded is a utility such as a library file.  When
you are writing modules of your own, `use_module/[1,2,3]' is the most
useful.

   The following predicates are used to load modules:

`use_module(F)'
     import the module-file(s) F, loading them if necessary; same as
     `ensure_loaded(F)' if all files in F are module-files

`use_module(:F,+I)'
     import the procedure(s) I from the module-file F, loading
     module-file F if necessary

`use_module(?M,:F,+I)'
     import I from module M, loading module-file F if necessary


   Before a module-file is loaded, the associated module is
"reinitialized": any predicates previously imported into or defined in
that module are forgotten by the module.

   If a module of the same name with a different PUBLICPREDLIST or
different meta-predicate list has previously been loaded from a
different module-file, a warning is printed and you are given the
option of abandoning the load.  Only one of these two modules can exist
in the system at one time.

   Normally, a module-file can be reloaded after editing with no need to
reload any other modules.  However, when a module-file is reloaded
after its PUBLICPREDLIST or its meta-predicate declaration (see *Note
ref-mod-met::) has been changed, any modules that import predicates
from it may have become inconsistent.  This is because a module is
associated with a predicate at compile time, rather than run time.
Thus, other modules may refer to predicates in a module-file that are
no longer public or whose module name expansion requirements have
changed.  In the case of module-importation (where all, rather than
specific, public predicates of a module are imported), it is possible
that some predicates in the importing module should now refer to a
newly-public predicate but do not.  Whenever the possibility of such
inconsistency arises, you will be warned at the end of the load that
certain modules need to be reloaded.  This warning will be repeated at
the end of each subsequent load until those modules have been reloaded.

   Modules may be saved to a PO file by calling
`save_modules(MODULES,FILE)' (see *Note ref-sls::).


File: sicstus.info,  Node: ref-mod-vis,  Next: ref-mod-som,  Prev: ref-mod-lod,  Up: ref-mod

4.11.6 Visibility Rules
-----------------------

By default, predicates defined in one module cannot be called from
another module.  This section enumerates the exceptions to this--the
ways in which a predicate can be "visible" to modules other than the
one in which it is defined.
  1. The built-in predicates can be called from any module.

  2. Any predicate that is named in the PUBLICPREDLIST of a module, and
     that is imported by some other module M, can be called from within
     M.

  3. Module Prefixing: Any predicate, whether public or not, can be
     called from any other module if its module is explicitly given as
     a prefix to the goal, attached with the `:/2' operator.  The
     module prefix overrides the default module.  For example,
          :- mod:foo(X,Y).

     always calls `foo/2' in module MOD.  This is effectively a
     loophole in the module system, which allows you to override the
     normal module visibility rules.  It is intended primarily to
     facilitate program development and debugging, and it should not be
     used extensively since it subverts the original purposes of using
     the module system.

     Note that a predicate called in this way does not necessarily have
     to be defined in the specified module.  It may be imported into
     it.  It can even be a built-in predicate, and this is sometimes
     useful--see *Note ref-mod-som::, for an example.


File: sicstus.info,  Node: ref-mod-som,  Next: ref-mod-tyi,  Prev: ref-mod-vis,  Up: ref-mod

4.11.7 The Source Module
------------------------

For any given procedure call, or goal, the "source module" is the module
in which the corresponding predicate must be visible.  That is, unless
the predicate is built-in, it must be defined in, or imported into, the
source module.

   For goals typed at the top level, the source module is the "type-in
module", which is `user' by default--see *Note ref-mod-tyi::.  For
goals appearing in a file (either as goal clauses or as normal
clauses), the source module is the one into which that file has been
loaded.

   There are a number of built-in predicates that take predicate
specifications, clauses, or goals as arguments.  Each of these types of
argument must be understood with reference to some module.  For
example, `assert/1' takes a clause as its argument, and it must decide
into which module that clause should be asserted.  The default
assumption is that it asserts the clause into the source module.
Another example is `call/1'.  The goal (A) calls the predicate `foo/1'
in the source module; this ensures that in the compound goal (B) both
occurrences of `foo/1' refer to the same predicate.

     call(foo(X)) (A)

     call(foo(X)), foo(Y)  (B)

   All predicates that refer to the source module allow you to override
it by explicitly naming some other module to be used instead.  This is
done by prefixing the relevant argument of the predicate with the
module to be used followed by a `:' operator.  For example (C), asserts
`f(x)' in module `m'.

     | ?- assert(m:f(x)). (C)

   Note that if you call a goal in a specified module, overriding the
normal visibility rules (see *Note ref-mod-vis::), the source module
for that goal is the one you specify, not the module in which this call
occurs.  For example (D), has exactly the same effect as (C)--`f(x)' is
asserted in module `m'.  In other words, prefixing a goal with a module
duplicates the effect of calling that goal from that module.
     | ?- m:assert(f(x)). (D)

   Another built-in predicate that refers to the source module is
`compile/1'.  In this case, the argument is a file, or list of files,
rather than a predicate specification, clause, or goal.  However, in
the case where a file is not a module-file, `compile/1' must decide
into which module to compile its clauses, and it chooses the source
module by default.  This means that you can compile a file FILE into a
specific module M using
     | ?- compile(M:FILE).

   Thus if FILE is a module-file, this command would cause its public
predicates to be imported into module M.  If FILE is a non-module-file,
it is loaded into module M.

   For a list of the built-in predicates that depend on the source
module, see *Note ref-mod-mne::.  In some cases, user-defined
predicates may also require the concept of a source module.  This is
discussed in *Note ref-mod-met::.


File: sicstus.info,  Node: ref-mod-tyi,  Next: ref-mod-dmo,  Prev: ref-mod-som,  Up: ref-mod

4.11.8 The Type-in Module
-------------------------

The "type-in" module is the module that is taken as the source module
for goals typed in by the user.  The name of the default type-in module
is `user'.  That is, the predicates that are available to be called
directly by the user are those that are visible in the module `user'.

   When debugging, it is often useful to call, directly from the top
level, predicates that are private to a module, or predicates that are
public but that are not imported into `user'.  This can be done by
prefixing each goal with the module name, as described in *Note
ref-mod-vis::; but rather than doing this extensively, it may be more
convenient to make this module the type-in module.

   The type-in module can be changed using the built-in predicate
`set_module/1'; for example,
     | ?- set_module(mod).

   This command will cause subsequent goals typed at the top level to be
executed with `mod' as their source module.

   The name of the type-in module is always displayed, except when it
is `user'.  If you are running Prolog under the editor interface, the
type-in module is displayed in the status line of the Prolog window.
If you are running Prolog without the editor interface, the type-in
module is displayed before each top-level prompt.

   For example, if you are running Prolog without the editor:
     | ?- module(foo).

     yes
     [foo]
     | ?-

   It should be noted that it is unlikely to be useful to change the
type-in module via a directive embedded in a file to be loaded, because
this will have no effect on the load--it will only change the type-in
module for commands subsequently entered by the user.


File: sicstus.info,  Node: ref-mod-dmo,  Next: ref-mod-mpc,  Prev: ref-mod-tyi,  Up: ref-mod

4.11.9 Creating a Module Dynamically
------------------------------------

There are several ways in which you can create a module without loading
a module-file for it.  One way to do this is by asserting clauses into
a specified module.  For example, the command (A) will create the
dynamic predicate `f/1' and the module `m' if they did not previously
exist.

     | ?- assert(m:f(x)). (A)

   Another way to create a module dynamically is to compile a
non-module-file into a specified module.  For example (B), will compile
the clauses in FILE into the module M.

     | ?- compile(M:FILE). (B)

   The same effect can be achieved by (temporarily) changing the type-in
module to M (see *Note ref-mod-tyi::) and then calling `compile(FILE)',
or executing the command in module M as in (C).

     | ?- M:compile(FILE). (C)


File: sicstus.info,  Node: ref-mod-mpc,  Next: ref-mod-cim,  Prev: ref-mod-dmo,  Up: ref-mod

4.11.10 Module Prefixes on Clauses
----------------------------------

* Menu:

* ref-mod-mpc-cmo::                     Current Modules

   Every clause in a Prolog file has a source module implicitly
associated with it.  If the file is a module-file, the module named in
the module declaration at the top of the file is the source module for
all the clauses.  If the file is not a module-file, the relevant module
is the source module for the command that caused this file to be loaded.

   The source module of a predicate decides in which module it is
defined (the module of the head), and in which module the goals in the
body are going to be called (the module of the body). It is possible to
override the implicit source module, both for head and body, of clauses
and directives, by using prefixes. For example, consider the
module-file:
     :- module(a, []).

     :- dynamic m:a/1.
     b(1).
     m:c([]).
     m:d([H|T]) :- q(H), r(T).
     m:(e(X) :- s(X), t(X)).
     f(X) :- m:(u(X), v(X)).

   In the previous example, the following modules apply:
  1. `a/1' is declared dynamic in the module `m'.

  2. `b/1' is defined in module `a' (the module of the file).

  3. `c/1' is defined in module `m'.

  4. `d/1' is defined in module `m', but `q/1' and `r/1' are called in
     module `a' (and must therefore be defined in module `a').

  5. `e/1' is defined in module `m', and `s/1' and `t/1' are called in
     module `m'.

  6. `f/1' is defined in module `a', but `u/1' and `v/1' are called in
     module `m'.

   Module prefixing is especially useful when the module prefix is
`user'.  There are several predicates that have to be defined in module
`user' but that you may want to define (or extend) in a program that is
otherwise entirely defined in some other module or modules; *note
mpg-top-hok::.

   Note that if clauses for one of these predicates are to be spread
across multiple files, it will be necessary to declare that predicate
to be multifile by putting a multifile declaration in each of the files.


File: sicstus.info,  Node: ref-mod-mpc-cmo,  Up: ref-mod-mpc

4.11.10.1 Current Modules
.........................

A loaded module becomes current as soon as it is encountered, and a
module can never lose the property of being current.


File: sicstus.info,  Node: ref-mod-cim,  Next: ref-mod-ncl,  Prev: ref-mod-mpc,  Up: ref-mod

4.11.11 Debugging Code in a Module
----------------------------------

Having loaded a module to be debugged, you can trace through its
execution in the normal way.  When the debugger stops at a port, the
procedure being debugged is displayed with its module name as a prefix
unless the module is `user'.

   The predicate `spy/1'  depends on the source module.  It can be
useful to override this during debugging.  For example,
     | ?- spy mod1:f/3.

puts a spypoint on `f/3' in module `mod1'.

   It can also be useful to call directly a predicate that is private
to its module in order to test that it is doing the right thing.  This
can be done by prefixing the goal with its module; for example,
     | ?- mod1:f(a,b,X).


File: sicstus.info,  Node: ref-mod-ncl,  Next: ref-mod-ilm,  Prev: ref-mod-cim,  Up: ref-mod

4.11.12 Name Clashes
--------------------

A "name clash" can arise if:
  1. a module tries to import a predicate from some other module `m1'
     and it has already imported a predicate with the same name and
     arity from a module `m2';

  2. a module tries to import a predicate from some other module `m1'
     and it already contains a definition of a predicate with the same
     name and arity; or

  3. a module tries to define a predicate with the same name and arity
     as one that it has imported.

   Whenever a name clash arises, a message is displayed beginning with
the words `NAME CLASH'.  The user is asked to choose from one of
several options; for example,
     NAME CLASH: f/3 is already imported into module user
                 from module m1;
                 do you want to override this definition with
                 the one in m2? (y,n,p,s,a or ?)

   The meanings of the four recognized replies are as follows:
   * `y' means forget the previous definition of `f/3' from `m1' and use
     the new definition of `f/3' from `m2' instead.

   * `n' means retain the previous definition of `f/3' from `m1' and
     ignore the new definition of `f/3' from `m2'.

   * `p' (for proceed) means forget the previous definition of `f/3'
     and of all subsequent predicate definitions in `m1' that clash
     during the current load of `m2'.  Instead, use the new definitions
     in `m2'.  When the `p' option is chosen, predicates being loaded
     from `m1' into `m2' will cause no `NAME CLASH' messages for the
     remainder of the load, though clashes with predicates from other
     modules will still generate such messages.

   * `s' (for suppress) means forget the new definition of `f/3' and of
     all subsequent predicate definitions in `m1' that clash during the
     current load of `m2'.  Instead, use the old definitions in `m2'.
     When the `s' option is chosen, predicates being loaded from `m1'
     into `m2' will cause no `NAME CLASH' messages for the remainder of
     the load, though clashes with predicates from other modules will
     still generate such messages.

   * `?' gives brief help information.


File: sicstus.info,  Node: ref-mod-ilm,  Next: ref-mod-idp,  Prev: ref-mod-ncl,  Up: ref-mod

4.11.13 Obtaining Information about Loaded Modules
--------------------------------------------------

* Menu:

* ref-mod-ilm-def::                     Predicates Defined in a Module
* ref-mod-ilm-vis::                     Predicates Visible in a Module

`current_module(?M)'
     M is the name of a current module

`current_module(?M,?F)'
     F is the name of the file in which M'S module declaration appears


File: sicstus.info,  Node: ref-mod-ilm-def,  Next: ref-mod-ilm-vis,  Up: ref-mod-ilm

4.11.13.1 Predicates Defined in a Module
........................................

The built-in predicate `current_predicate/2' can be used to find the
predicates that are defined in a particular module.

   To backtrack through all of the predicates defined in module `m', use 

     | ?- current_predicate(_, m:Goal).

   To backtrack through _all_ predicates defined in _any_ module, use
     | ?- current_predicate(_, M:Goal).

   This succeeds once for every predicate in your program.


File: sicstus.info,  Node: ref-mod-ilm-vis,  Prev: ref-mod-ilm-def,  Up: ref-mod-ilm

4.11.13.2 Predicates Visible in a Module
........................................

The built-in predicate `predicate_property/2' can be used to find the
properties of any predicate that is visible to a particular module.

   To backtrack through all of the predicates imported by module `m',
use 

     | ?- predicate_property(m:Goal, imported_from(_)).

   To backtrack through all of the predicates imported by module `m1'
from module `m2', use 

     | ?- predicate_property(m1:Goal, imported_from(m2)).

   For example, you can load the `basics' module from the library and
then remind yourself of what predicates it defines like this:

     | ?- compile(library(basics)).
     % ... loading messages ...

     yes
     | ?- predicate_property(P, imported_from(basics)).

     P = member(_2497,_2498) ;
     P = memberchk(_2497,_2498) ;
       .
       .
       .

   This tells you what predicates are imported into the type-in module
from `basics'.

   You can also find _all_ imports into _all_ modules using
     | ?- predicate_property(M1:G, imported_from(M2)).

   To backtrack through all of the predicates exported by module `m',
use 

     | ?- predicate_property(m:Goal, exported).


File: sicstus.info,  Node: ref-mod-idp,  Next: ref-mod-mne,  Prev: ref-mod-ilm,  Up: ref-mod

4.11.14 Importing Dynamic Predicates
------------------------------------

Imported dynamic predicates may be asserted and retracted.  For
example, suppose the following file is loaded via `use_module/1':

     :- module(m1, [f/1]).
     :- dynamic f/1.
     f(0).

   Then `f/1' can be manipulated as if it were defined in the current
module.  For example,
     | ?- clause(f(X), true).

     X = 0

   The built-in predicate `listing/1' distinguishes predicates that are
imported into the current source module by prefixing each clause with
the module name.  Thus, 

     | ?- listing(f).

     m1:f(0).

   However, `listing/1' does not prefix clauses with their module if
they are defined in the source module itself.  Note that
     | ?- listing.

can be used to see all the dynamic predicates defined in or imported
into the current type-in module.  And
     | ?- listing(m1:_).

can be used to see all such predicates that are defined in or imported
into module `m1'.


File: sicstus.info,  Node: ref-mod-mne,  Next: ref-mod-met,  Prev: ref-mod-idp,  Up: ref-mod

4.11.15 Module Name Expansion
-----------------------------

The concept of a source module is explained in *Note ref-mod-som::.
For any goal, the applicable source module is determined when the goal
is compiled rather than when it is executed.

   A procedure that needs to refer to the source module has arguments
designated for module name expansion.  These arguments are expanded
when code is consulted, compiled or asserted by the transformation X ->
M:X where M is the name of the source module.  For example, the goal
`call(X)' is expanded into `call(M:X)' and the goal `clause(Head, Body)'
is expanded into `clause(M:Head, Body)'.

   Module name expansion is avoided if the argument to be expanded is
already a `:/2' term.  In this case it is unnecessary since the module
to be used has already been supplied by the programmer.


File: sicstus.info,  Node: ref-mod-met,  Next: ref-mod-sem,  Prev: ref-mod-mne,  Up: ref-mod

4.11.16 The `meta_predicate' Declaration
----------------------------------------

Sometimes a user-defined predicate will require module name expansion
(see *Note ref-mod-mne::).  This can be specified by providing a
`meta_predicate' declaration for that procedure.

   Module name expansion is needed whenever the argument of a predicate
has some module-dependent meaning.  For example, if this argument is a
goal that is to be called, it will be necessary to know in which module
to call it--or, if the argument is a clause to be asserted, in which
module it should go.

   Consider, for example, a sort routine to which the name of the
comparison predicate is passed as an argument.  In this example, the
comparison predicate should be called with respect to the module
containing the call to the sort routine.  Suppose that the sort routine
is
     mysort(COMPAREPROC, INPUTLIST, OUTPUTLIST)

   An appropriate `meta_predicate' declaration for this is
     :- meta_predicate mysort(:, +, -).

   The significant argument in the `mysort/3' term is the `:', which
indicates that module name expansion is required for this argument.
This means that whenever a goal `mysort(A, B, C)' appears in a clause,
it will be transformed at load time into `mysort(M:A, B, C)', where M
is the source module.  There are some exceptions to this compile-time
transformation rule; the goal is not transformed if either of the
following applies:

  1. A is of the form MODULE:GOAL.

  2. A is a variable and the same variable appears in the head of the
     clause in a module-name-expansion position.

   The reason for (2) is that otherwise module name expansion could
build larger and larger structures of the form MN: ... :M2:M1:GOAL.
For example, consider the following program fragment adapted from the
library (see `library(samsort)' for the full program):

     :- module(samsort, [samsort/3]).

     :- meta_predicate
             samsort(:, +, ?),
             sam_sort(+, :, +, +, ?).

     samsort(_, [], []) :- !.
     samsort(Order, List, Sorted) :-
             sam_sort(List, Order, [], 0, Sorted).
       .
       .
       .

   Normally, the `sam_sort/5' goal in this example would have the
module name of its second argument expanded thus:
     sam_sort(List, samsort:Order, [], 0, Sorted)

because of the `meta_predicate' declaration.  However, in this
situation the appropriate source module will have already been attached
to ORDER because it is the first argument of `samsort/3', which also
has a `meta_predicate' declaration.  Therefore it is not useful to
attach the module name (`samsort') to ORDER in the call of `sam_sort/5'.

   The argument of a `meta_predicate' declaration can be a term, or a
sequence of terms separated by commas.  Each argument of each of these
terms must be one of the following:

`:'
     requires module name expansion

`+'
`-'
`?'
     ignored

   The reason for `+', `-' and `*' is simply so that the information
contained in a DEC-10 Prolog-style "mode" declaration may be represented
in the `meta_predicate' declaration if you wish.  There are many
examples of `meta_predicate' declarations in the library.


File: sicstus.info,  Node: ref-mod-sem,  Next: ref-mod-sum,  Prev: ref-mod-met,  Up: ref-mod

4.11.17 Semantics of Module Name Expansion
------------------------------------------

Although module name expansion is performed when code is consulted,
compiled or asserted, it is perhaps best explained in terms of an
interpreter, especially the issue of how deeply clauses are expanded.
The semantics of `call/1', taking `meta_predicate' declarations into
account, is shown as if defined by the interpreter shown below.  The
interpreter's case analysis is as follows:

CONTROL CONSTRUCTS
     (Including cuts and module prefixes).  The interpreter implements
     the semantics of the construct, expanding its argument.

CALLABLE TERMS WITH FUNCTOR N/A
     First, we look for a `meta_predicate' declaration for N/A.  If one
     exists, the relevant arguments are expanded.  Otherwise, the goal
     is left unexpanded.  Then, if N/A is a built-in predicate, it is
     called.  Otherwise, a clause with head functor N/A is looked up
     using the imaginary predicate `:-/2', unified against, and its
     body is interpreted.

NON-CALLABLE TERMS
     Raise error exception.

   Throughout the interpretation, we must keep track of the module
context.  The interpreter is as follows, slightly simplified.  `-->/2'
is _not_ a predicate:

     call(M:Body) :-
             call(Body, M).

     call(Var, M) :- \+callable(Var), !,
             must_be(Term, callable, call(M:Var), 1).
     call(!, _) :- !,
             % _cut relevant choicepoints._
     call((A, B), M) :- !,
             call(A, M),
             call(B, M).
     call((A -> B), M) :- !,
         (   call(A, M) ->
             call(B, M)
         ).
     call((A -> B ; C), M) :- !,
         (   call(A, M) ->
             call(B, M)
         ;   call(C, M)
         ).
     call((A ; B), M) :- !,
         (   call(A, M)
         ;   call(B, M)
         ).
     call(\+(A), M) :- !,
         (   call(A, M) ->
             fail
         ;   true
         ).
     call(_^A, M) :- !,
             call(A, M).
     call(if(A,B,C), M) :- !,
          if(call(A, M),
             call(B, M),
             call(C, M)).
     call(once(A), M) :- !,
         (   call(A, M) -> true
         ).
     call(Goal, M) :-
         (   predicate_property(M:Goal, meta_predicate(Meta)) ->
             functor(Goal, Name, Arity),
             functor(AGoal, Name, Arity),
             annotate_goal(0, Arity, Meta, Goal, AGoal, M),
             call_goal(AGoal, M)
         ;   call_goal(Goal, M)
         ).

     call_goal(asserta(X), _) :- !,
             asserta(X).
     call_goal(asserta(X,R), _) :- !,
             asserta(X, R).
     % _and so on for all built-in predicates_
     call_goal(Goal, M) :-
             (M:Goal :- Body),
             call(Body, M).

     annotate_goal(A, A, _, _, _, _) :- !.
     annotate_goal(I, A, Meta, Goal, AGoal, Module) :-
             J is I+1,
             arg(J, Meta, M),
             arg(J, Goal, Arg),
             arg(J, AGoal, Ann),
             (   M==(:) -> Ann = Module:Arg
             ;   Ann = Arg
             ),
             annotate_goal(J, A, Meta, Goal, AGoal, Module).


File: sicstus.info,  Node: ref-mod-sum,  Prev: ref-mod-sem,  Up: ref-mod

4.11.18 Predicate Summary
-------------------------

`current_module(?M)'
     M is the name of a current module

`current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears

`meta_predicate :P  "declaration"'
     declares predicates P that are dependent on the module from which
     they are called

`module(+M,+L)  "declaration"'
`module(+M,+L,+O)  "declaration"'
     declaration that module M exports predicates in L, options O

`save_modules(+L,+F)'
     save the modules specifed in L into file F

`set_module(+M)'
     make M the type-in module

`use_module(:F)'
     import the module-file(s) F, loading them if necessary

`use_module(:F,+I)'
     import the procedure(s) I from the module-file F

`use_module(?M,:F,+I)'
     import I from module M, loading module-file F if necessary



File: sicstus.info,  Node: ref-mdb,  Next: ref-all,  Prev: ref-mod,  Up: Prolog Intro

4.12 Modification of the Database
=================================

* Menu:

* ref-mdb-bas::                         Introduction
* ref-mdb-dsp::                         Dynamic and Static Procedures
* ref-mdb-dre::                         Database References
* ref-mdb-acd::                         Adding Clauses to the Database
* ref-mdb-rcd::                         Removing Clauses from the Database
* ref-mdb-acl::                         Accessing Clauses
* ref-mdb-exa::                         Modification of Running Code: Examples
* ref-mdb-idb::                         The Internal Database
* ref-mdb-bbd::                         The Blackboard
* ref-mdb-sum::                         Summary of Predicates


File: sicstus.info,  Node: ref-mdb-bas,  Next: ref-mdb-dsp,  Up: ref-mdb

4.12.1 Introduction
-------------------

The family of assertion and retraction predicates described below
enables you to modify a Prolog program by adding or deleting clauses
while it is running.  These predicates should not be overused.   Often
people who are experienced with other programming languages have a
tendency to think in terms of global data structures, as opposed to
data structures that are passed as procedure arguments, and hence they
make too much use of assertion and retraction.  This leads to less
readable and less efficient programs.

   An interesting question in Prolog is what happens if a procedure
modifies itself, by asserting or retracting a clause, and then fails.
On backtracking, does the current execution of the procedure use new
clauses that are added to the bottom of the procedure?

     *Historical note:* In some non-ISO-conforming implementations of
     Prolog, changes to the Prolog database become globally visible upon
     the success of the built-in predicate modifying the database.  An
     unsettling consequence is that the definition of a procedure can
     change while it is being run.  This can lead to code that is
     difficult to understand.  Furthermore, the memory performance of
     the interpreter implementing these semantics is poor.  Worse yet,
     the semantics rendered ineffective the added determinacy detection
     available through indexing.

   SICStus Prolog implements the "logical" view in updating dynamic
predicates, conforming to the ISO standard.  This means that the
definition of a dynamic procedure that is visible to a call is
effectively frozen when the call is made.  A procedure always contains,
as far as a call to it is concerned, exactly the clauses it contained
when the call was made.

   A useful way to think of this is to consider that a call to a
dynamic procedure makes a "virtual copy" of the procedure and then runs
the copy rather than the original procedure.  Any changes to the
procedure made by the call are immediately reflected in the Prolog
database, but not in the copy of the procedure being run.  Thus,
changes to a running procedure will not be visible on backtracking.  A
subsequent call, however, makes and runs a copy of the modified Prolog
database.  Any changes to the procedure that were made by an earlier
call will now be visible to the new call.

   In addition to being more intuitive and easy to understand, the new
semantics allow interpreted code to execute with the same determinacy
detection (and excellent memory performance) as static compiled code
(see *Note Indexing::, for more information on determinacy detection).


File: sicstus.info,  Node: ref-mdb-dsp,  Next: ref-mdb-dre,  Prev: ref-mdb-bas,  Up: ref-mdb

4.12.2 Dynamic and Static Procedures
------------------------------------

All Prolog procedures are classified as being either "static" or
"dynamic procedures".  Static procedures can be changed only by
completely redefining them using the Load Predicates (see *Note
ref-lod::).  Dynamic procedures can be modified by adding or deleting
individual clauses using the assert and retract procedures.

   If a procedure is defined by being compiled, it is static by default.
If you need to be able to add, delete, or inspect the individual
clauses of such a procedure, you must make the procedure dynamic.

   There are two ways to make a procedure dynamic:
   * If the procedure is to be compiled, it must be declared to be
     dynamic before it is defined.

   * If the procedure is to be created by assertions only, the first
     `assert' operation on the procedure automatically makes it dynamic.

   A procedure is declared dynamic by preceding its definition with a
declaration of the form:
     :- dynamic :PRED

where PRED must be a procedure specification of the form NAME/ARITY, or
a sequence of such specifications, separated by commas.  For example,
     :- dynamic exchange_rate/3, spouse_of/2,
                gravitational_constant/1.

where `dynamic' is a built-in prefix operator.  If PRED is not of the
specified form an exception is raised, and the declaration is ignored.

   Note that the symbol `:- ' preceding the word `dynamic' is essential.
If this symbol is omitted, a permission error is raised because it
appears that you are trying to define a clause for the built-in
predicate `dynamic/1'.  Although `dynamic/1' is a built-in predicate,
it may only be used in declarations.

   When a dynamic declaration is encountered in a file being compiled,
it is considered to be a part of the redefinition of the procedures
specified in its argument.  Thus, if you compile a file containing only
     :- dynamic hello/0

the effect will be to remove any previous definition of `hello/0' from
the database, and to make the procedure dynamic.  You cannot make a
procedure dynamic retroactively.  If you wish to make an
already-existing procedure dynamic it must be redefined.

   It is often useful to have a dynamic declaration for a procedure
even if it is to be created only by assertions.  This helps another
person to understand your program, since it emphasizes the fact that
there are no pre-existing clauses for this procedure, and it also
avoids the possibility of Prolog stopping to tell you there are no
clauses for this procedure if you should happen to call it before any
clauses have been asserted.  This is because unknown procedure catching
(see *Note Undefined Predicates::) does not apply to dynamic
procedures; it is presumed that a call to a dynamic procedure should
simply fail if there are no clauses for it.  

   If a program needs to make an undefined procedure dynamic, this can
be achieved by calling `clause/2' on that procedure.  The call will
fail because the procedure has no clauses, but as a side-effect it will
make the procedure dynamic and thus prevent unknown procedure catching
on that procedure.  See the Reference page for details of `clause/2'.

   Although you can simultaneously declare several procedures to be
dynamic, as shown above, it is recommended that you use a separate
dynamic declaration for each procedure placed immediately before the
clauses for that procedure.  In this way when you reconsult or
recompile the procedure using the editor interface, you will be
reminded to include its dynamic declaration.

   Dynamic procedures are implemented by interpretation, even if they
are included in a file that is compiled.  This means that they are
executed more slowly than if they were static, and also that they can be
printed using `listing/0'.  Dynamic procedures, as well as static
procedures, are indexed on their first argument; see *Note Indexing::.  


File: sicstus.info,  Node: ref-mdb-dre,  Next: ref-mdb-acd,  Prev: ref-mdb-dsp,  Up: ref-mdb

4.12.3 Database References
--------------------------

A "database reference" is a term that uniquely identifies a clause or
recorded term (see *Note ref-mdb-idb::) in the database.  Database
references are provided only to increase efficiency in programs that
access the database in complex ways.  Use of a database reference to a
clause can save repeated searches using `clause/2'.  However, it does
_not_ normally pay to access a clause via a database reference when
access via first argument indexing is possible.


File: sicstus.info,  Node: ref-mdb-acd,  Next: ref-mdb-rcd,  Prev: ref-mdb-dre,  Up: ref-mdb

4.12.4 Adding Clauses to the Database
-------------------------------------

The assertion predicates are used to add clauses to the database in
various ways.  The relative position of the asserted clause with
respect to other clauses for the same predicate is determined by the
choice among `assert/1', `asserta/1', and `assertz/1'.  A database
reference that uniquely identifies the clause being asserted is
established by providing an optional second argument to any of the
assertion predicates.

`assert(:C)'
     clause C is asserted in an arbitrary position in its predicate

`assert(:C,-R)'
     as `assert/1'; reference R is returned

`asserta(:C)'
     clause C is asserted before existing clauses

`asserta(:C,-R)'
     as `asserta/1'; reference R is returned

`assertz(:C)'
     clause C is asserted after existing clauses

`assertz(:C,-R)'
     as `assertz/1'; reference R is returned

   *Please note*: If the term being asserted contains attributed
variables (*note lib-atts::) or suspended goals (*note ref-sem-sec::),
those attributes are not stored in the database.  To retain the
attributes, you can use `copy_term/3' (*note ref-lte-cpt::).


File: sicstus.info,  Node: ref-mdb-rcd,  Next: ref-mdb-acl,  Prev: ref-mdb-acd,  Up: ref-mdb

4.12.5 Removing Clauses from the Database
-----------------------------------------

* Menu:

* ref-mdb-rcd-efu::                     A Note on Efficient Use of retract/1

   This section briefly describes the predicates used to remove the
clauses and/or properties of a predicate from the system.

     *Please note:*  Removing all of a predicate's clauses by
     `retract/1' and/or `erase/1' (see *Note ref-mdb-rcd-efu::) does
     not remove the predicate's properties (and hence its definition)
     from the system.  The only way to completely remove a predicate's
     clauses _and_ properties is to use `abolish/[1,2]'.

`retract(:C)'
     erase the first dynamic clause that matches C

`retractall(:H)'
     erase every clause whose head matches H

`abolish(:F)'
     abolish the predicate(s) specified by F

`abolish(:F,+O)'
     abolish the predicate(s) specified by F with options O

`erase(+R)'
     erase the clause or recorded term (see *Note ref-mdb-idb::) with
     reference R


File: sicstus.info,  Node: ref-mdb-rcd-efu,  Up: ref-mdb-rcd

4.12.5.1 A Note on Efficient Use of `retract/1'
...............................................

_WARNING:_ `retract/1' is a nondeterminate procedure.  Thus, we can use
     | ?- retract((foo(X) :- Body)), fail.

to retract all clauses for `foo/1'.  A nondeterminate procedure in
SICStus Prolog uses a "choicepoint", a data  structure kept on an
internal stack, to implement backtracking.  This applies to
user-defined procedures as well as to built-in and library procedures.
In a simple model, a choicepoint is created for each call to a
nondeterminate procedure, and is deleted on determinate success or
failure of that call, when backtracking is no longer possible.  In
fact, SICStus Prolog improves upon this simple model by recognizing
certain contexts in which choicepoints can be avoided, or are no longer
needed.

   The Prolog "cut" (`!') works by removing choicepoints, disabling the
potential backtracking they represented.  A choicepoint can thus be
viewed as an "outstanding call", and a "cut" as deleting outstanding
calls.

   To avoid leaving inconsistencies between the Prolog database and
outstanding calls, a retracted clause is reclaimed only when the system
determines that there are no choicepoints on the stack that could allow
backtracking to the clause.  Thus, the existence of a single
choicepoint on the stack can disable reclamation of retracted clauses
for the procedure whose call created the choicepoint.  Space is
recovered only when the choicepoint is deleted.

   Often `retract/1' is used determinately; for example, to retract a
single clause, as in
     | ?- <do some stuff>
           retract(Clause),
          <do more stuff without backtracking>.

   No backtracking by `retract/1' is intended.  Nonetheless, if Clause
may match more than one clause in its procedure, a choicepoint will be
created by `retract/1'.  While executing "<do more stuff without
backtracking>", that choicepoint will remain on the stack, making it
impossible to reclaim the retracted Clause.  Such choicepoints can also
disable tail recursion optimization.  If not cut away, the choicepoint
can also lead to runaway retraction on the unexpected failure of a
subsequent goal.  This can be avoided by simply cutting away the
choicepoint with an explicit `cut' or a local cut (`->').  Thus, in the
previous example, it is preferable to write either
     | ?- <do some stuff>
           retract(Clause),
           !,
          <do more stuff without backtracking>.

or

     | ?- <do some stuff>
          ( retract(Clause) -> true ),
          <do more stuff without backtracking>.

   This will reduce stack size and allow the earliest possible
reclamation of retracted clauses.


File: sicstus.info,  Node: ref-mdb-acl,  Next: ref-mdb-exa,  Prev: ref-mdb-rcd,  Up: ref-mdb

4.12.6 Accessing Clauses
------------------------

`Goal'
     Succeeds If:

`clause(:P,?Q)'
     there is a clause for a dynamic predicate with head P and body Q

`clause(:P,?Q,?R)'
     there is a clause for a dynamic predicate with head P, body Q, and
     reference R

`instance(+R,-T)'
     T is an instance of the clause or term referenced by R



File: sicstus.info,  Node: ref-mdb-exa,  Next: ref-mdb-idb,  Prev: ref-mdb-acl,  Up: ref-mdb

4.12.7 Modification of Running Code: Examples
---------------------------------------------

* Menu:

* ref-mdb-exa-asz::                     Example: assertz
* ref-mdb-exa-rtr::                     Example: retract
* ref-mdb-exa-abo::                     Example: abolish

   The following examples show what happens when a procedure is
modified while it is running.  This can happen in two ways:
  1. The procedure calls some other procedure that modifies it.

  2. The procedure succeeds nondeterminately, and a subsequent goal
     makes the modification.
         In either case, the question arises as to whether the
modifications take effect upon backtracking into the modified
procedure.  In SICStus Prolog the answer is that they do not.  As
explained in the overview to this section (see *Note ref-mdb-bas::),
modifications to a procedure affect only calls to that procedure that
occur after the modification.


File: sicstus.info,  Node: ref-mdb-exa-asz,  Next: ref-mdb-exa-rtr,  Up: ref-mdb-exa

4.12.7.1 Example: assertz
.........................

Consider the procedure `foo/0' defined by

     :- dynamic foo/0.
     foo :- assertz(foo), fail.

   Each call to `foo/0' asserts a new last clause for `foo/0'.  After
the Nth call to `foo/0' there will be N+1 clauses for `foo/0'.  When
`foo/0' is first called, a virtual copy of the procedure is made,
effectively freezing the definition of `foo/0' for that call.  At the
time of the call, `foo/0' has exactly one clause.  Thus, when `fail/0'
forces backtracking, the call to `foo/0' simply fails: it finds no
alternatives.  For example,

     | ?- compile(user).
     | :- dynamic foo/0.
     | foo :- assertz(foo), fail.
     | ^D
     % user compiled in module user, 0.100 sec 2.56 bytes

     yes
     | ?- foo.  % The asserted clause is not found

     no
     | ?- foo.  % A later call does find it, however

     yes
     | ?-

   Even though the virtual copy of `foo/0' being run by the first call
is not changed by the assertion, the Prolog database is.  Thus, when a
second call to `foo/0' is made, the virtual copy for that call contains
two clauses.  The first clause fails, but on backtracking the second
clause is found and the call succeeds.


File: sicstus.info,  Node: ref-mdb-exa-rtr,  Next: ref-mdb-exa-abo,  Prev: ref-mdb-exa-asz,  Up: ref-mdb-exa

4.12.7.2 Example: retract
.........................

     | ?- assert(p(1)), assert(p(2)), assert(p(3)).

     yes
     | ?- p(N), write(N), nl, retract(p(2)),
          retract(p(3)), fail.
     1
     2
     3

     no
     | ?- p(N), write(N), fail.
     1
     no
     | ?-

At the first call to `p/1', the procedure has three clauses.  These
remain visible throughout execution of the call to `p/1'.  Thus, when
backtracking is forced by `fail/0', N is bound to 2 and written.  The
retraction is again attempted, causing backtracking into `p/1'.  N is
bound to 3 and written out.  The call to `retract/1' fails.  There are
no more clauses in `p/1', so the query finally fails.  A subsequent
call to `p/1', made after the retractions, sees only one clause.


File: sicstus.info,  Node: ref-mdb-exa-abo,  Prev: ref-mdb-exa-rtr,  Up: ref-mdb-exa

4.12.7.3 Example: abolish
.........................

     | ?- compile(user).
     | :- dynamic q/1.
     | q(1).
     | q(2).
     | q(3).
     | ^D
     % user compiled in modules user, 0.117 sec 260 bytes

     yes
     | ?- q(N), write(N), nl, abolish(q/1), fail.
     1
     2
     3

     no
     | ?-

Procedures that are abolished while they have outstanding calls do not
become invisible to those calls.  Subsequent calls however, will find
the procedure undefined.


File: sicstus.info,  Node: ref-mdb-idb,  Next: ref-mdb-bbd,  Prev: ref-mdb-exa,  Up: ref-mdb

4.12.8 The Internal Database
----------------------------

The following predicates are provided solely for compatibility with
other Prolog systems.  Their semantics can be understood by imagining
that they are defined by the following clauses:
     recorda(Key, Term, Ref) :-
          functor(Key, Name, Arity),
          functor(F, Name, Arity),
          asserta('$recorded'(F,Term), Ref).
     recordz(Key, Term, Ref) :-
          functor(Key, Name, Arity),
          functor(F, Name, Arity),
          assertz('$recorded'(F,Term), Ref).
     recorded(Key, Term, Ref) :-
          functor(Key, Name, Arity),
          functor(F, Name, Arity),
          clause('$recorded'(F,Term), _, Ref).

   The reason for the calls to `functor/3' in the above definition is
that only the principal functor of the key is significant.  If KEY is a
compound term, its arguments are ignored.

     *Please note:* Equivalent functionality and performance, with
     reduced memory costs, can usually be had through normal dynamic
     procedures and indexing (see *Note ref-mdb-bas:: and *Note
     Indexing::).

   `recorda(KEY, TERM, REF)' records the TERM in the internal database
as the first item for the key KEY; a database reference to the
newly-recorded term is returned in REF.

   `recordz(KEY, TERM, REF)' is like `recorda/3' except that it records
the term as the last item in the internal database.

   `recorded(KEY, TERM, REF)' searches the internal database for a term
recorded under the key KEY that unifies with TERM, and whose database
reference unifies with REF.

   `current_key(KEYNAME, KEYTERM)' succeeds when KEYNAME is the atom or
integer that is the name of KEYTERM.  KEYTERM is an integer, atom, or
compound term that is the key for a currently recorded term.


File: sicstus.info,  Node: ref-mdb-bbd,  Next: ref-mdb-sum,  Prev: ref-mdb-idb,  Up: ref-mdb

4.12.9 Blackboard Primitives
----------------------------

The predicates described in this section store arbitrary terms in a
per-module repository known as the "blackboard".  The main purpose of
the blackboard was initially to provide a means for communication
between branches executing in parallel, but the blackboard works
equally well during sequential execution.  The blackboard implements a
mapping from keys to values.  Keys are restricted to being atoms or
small integers, whereas values are arbitrary terms.  In contrast to the
predicates described in the previous sections, a given key can map to
at most a single term.

   Each Prolog module maintains its own blackboard, so as to avoid name
clashes if different modules happen to use the same keys.  The "key"
arguments of these predicates are subject to module name expansion, so
the module name does not have to be explicitly given unless multiple
Prolog modules are supposed to share a single blackboard.

   The predicates below implement atomic blackboard actions.

`bb_put(:KEY, +TERM)'
     A copy of TERM is stored under KEY.

`bb_get(:KEY, ?TERM)'
     If a term is currently stored under KEY, a copy of it is unified
     with TERM.  Otherwise, `bb_get/2' silently fails.

`bb_delete(:KEY, ?TERM)'
     If a term is currently stored under KEY, the term is deleted, and
     a copy of it is unified with TERM.  Otherwise, `bb_delete/2'
     silently fails.

`bb_update(:KEY, ?OLDTERM, ?NEWTERM)'
     If a term is currently stored under KEY and unifies with OLDTERM,
     the term is replaced by a copy of NEWTERM.  Otherwise,
     `bb_update/3' silently fails.  This predicate provides an atomic
     swap operation.

   *Please note*: If the term being stored contains attributed variables
(*note lib-atts::) or suspended goals (*note ref-sem-sec::), those
attributes are not stored.  To retain the attributes, you can use
`copy_term/3' (*note ref-lte-cpt::).

   The following example illustrates how these primitives may be used to
implement a "maxof" predicate that finds the maximum value computed by
some nondeterminate goal.  We use a single key `max'.  We assume that
GOAL does not produce any "false" solutions that would be eliminated by
cuts in a sequential execution.  Thus, GOAL may need to include
redundant checks to ensure that its solutions are valid, as discussed
above.

     maxof(Value, Goal, _) :-
             bb_put(max, -1),                % initialize max-so-far
             call(Goal),
             update_max(Value),
             fail.
     maxof(_, _, Max) :-
             bb_delete(max, Max),
             Max > 1.

     update_max(New):-
             bb_get(max, Old),
             compare(C, Old, New),
             update_max(C, Old, New).

     update_max(<, Old, New) :- bb_update(max, Old, New).
     update_max(=, _, _).
     update_max(>, _, _).


File: sicstus.info,  Node: ref-mdb-sum,  Prev: ref-mdb-bbd,  Up: ref-mdb

4.12.10 Summary of Predicates
-----------------------------

`abolish(:F)  "ISO"'
     abolish the predicate(s) specified by F

`abolish(:F,+O)'
     abolish the predicate(s) specified by F with options O

`assert(:C)'
`assert(:C,-R)'
     clause C is asserted; reference R is returned

`asserta(:C)  "ISO"'
`asserta(:C,-R)'
     clause C is asserted before existing clauses; reference R is
     returned

`assertz(:C)  "ISO"'
`assertz(:C,-R)'
     clause C is asserted after existing clauses; reference R is
     returned

`bb_delete(:KEY,-TERM)'
     Delete from the blackboard TERM stored under KEY.

`bb_get(:KEY,-TERM)'
     Get from the blackboard TERM stored under KEY.

`bb_put(:KEY,+TERM)'
     Store TERM under KEY on the blackboard.

`bb_update(:KEY, -OLDTERM, +NEWTERM)'
     Replace OLDTERM by NEWTERM under KEY on the blackboard.

`clause(:P,?Q)  "ISO"'
`clause(:P,?Q,?R)'
     there is a clause for a dynamic predicate with head P, body Q, and
     reference R

`current_key(?N, ?K)'
     N is the name and K is the key of a recorded term

`dynamic :P  "ISO,declaration"'
     predicates specified by P are dynamic

`erase(+R)'
     erase the clause or record with reference R

`instance(+R,-T)'
     T is an instance of the clause or term referenced by R

`recorda(+K,+T,-R)'
     make term T the first record under key K; reference R is returned

`recorded(?K,?T,?R)'
     term T is recorded under key K with reference R

`recordz(+K,+T,-R)'
     make term T the last record under key K; reference R is returned

`retract(:C)  "ISO"'
     erase the first dynamic clause that matches C

`retractall(:H)'
     erase every clause whose head matches H


File: sicstus.info,  Node: ref-all,  Next: ref-gru,  Prev: ref-mdb,  Up: Prolog Intro

4.13 Sets and Bags:  Collecting Solutions to a Goal
===================================================

* Menu:

* ref-all-bas::                         Introduction
* ref-all-cse::                         Collecting a Sorted List
* ref-all-cba::                         Collecting a Bag of Solutions
* ref-all-sum::                         Predicate Summary


File: sicstus.info,  Node: ref-all-bas,  Next: ref-all-cse,  Up: ref-all

4.13.1 Introduction
-------------------

When there are many solutions to a goal, and a list of all those
solutions is desired, one means of collecting them is to write a
procedure that repeatedly backtracks into that goal to get another
solution.  In order to collect all the solutions together, it is
necessary to use the database (via assertion) to hold the solutions as
they are generated, because  backtracking to redo the goal would undo
any list construction that had been done after satisfying the goal.

   The writing of such a backtracking loop can be avoided by the use of
one of the built-in predicates `setof/3', `bagof/3' and
`findall/[3,4]', which are described below.  These provide a nice
logical abstraction, whereas with a user-written backtracking loop the
need for explicit side-effects (assertions) destroys the declarative
interpretation of the code.  The built-in predicates are also more
efficient than those a user could write.

   *Please note*: If the solutions being collected contain attributed
variables (*note lib-atts::) or suspended goals (*note ref-sem-sec::),
those attributes are not retained in the list of solutions.  To retain
the attributes, you can use `copy_term/3' (*note ref-lte-cpt::).


File: sicstus.info,  Node: ref-all-cse,  Next: ref-all-cba,  Prev: ref-all-bas,  Up: ref-all

4.13.2 Collecting a Sorted List
-------------------------------

* Menu:

* ref-all-cse-equ::                     Existential Quantifier

   `setof(TEMPLATE, GENERATOR, SET)' returns the set SET of all
instances of TEMPLATE such that GENERATOR is provable, where that set
is non-empty.  The term GENERATOR specifies a goal to be called as if
by `call/1'.  SET is a set of terms represented as a list of those
terms, without duplicates,  in the standard order for terms (see *Note
ref-lte-cte::).

   Obviously, the set to be enumerated should be finite, and should be
enumerable by Prolog in finite time.  It is possible for the provable
instances to contain variables, but in this case SET will only provide
an imperfect representation of what is in reality an infinite set.

   If GENERATOR is instantiated, but contains uninstantiated variables
that do not also appear in TEMPLATE, `setof/3' can succeed
nondeterminately, generating alternative values for SET corresponding
to different instantiations of the free variables of GENERATOR.  (It is
to allow for such usage that SET is constrained to be non-empty.)  For
example, if your program contained the clauses
     likes(tom, beer).
     likes(dick, beer).
     likes(harry, beer).
     likes(bill, cider).
     likes(jan, cider).
     likes(tom, cider).

the call
     | ?- setof(X, likes(X,Y), S).

might produce two alternative solutions via backtracking:
     X = _872,
     Y = beer,
     S = [dick,harry,tom] ;

     X = _872,
     Y = cider,
     S = [bill,jan,tom] ;

     no

   The call
     | ?- setof((Y,S), setof(X,likes(X,Y),S), SS).

would then produce

     Y = _402,
     S = _417,
     X = _440,
     SS = [(beer,[dick,harry,tom]),(cider,[bill,jan,tom])] ;

     no


File: sicstus.info,  Node: ref-all-cse-equ,  Up: ref-all-cse

4.13.2.1 Existential Quantifier
...............................

X `^' P is recognized as meaning "there exists an X such that P is
true", and is treated as equivalent to simply calling P.  The use of
the explicit existential quantifier outside `setof/3' and `bagof/3' is
superfluous.

   Variables occurring in GENERATOR will not be treated as free if they
are explicitly bound within GENERATOR by an existential quantifier.  An
existential quantification is written:
     Y^Q

meaning "there exists a Y such that Q is true", where Y is some Prolog
variable.  For example:
     | ?- setof(X, Y^likes(X,Y), S).

would produce the single result
     X = _400,
     Y = _415,
     S = [bill,dick,harry,jan,tom] ;

     no

in contrast to the earlier example.

   Furthermore, it is possible to existentially quantify a term, where
all the variables in that term are taken to be existentially quantified
in the goal.  e.g.

     A=term(X,Y), setof(Z, A^foo(X,Y,Z), L).

will treat X and Y as if they are existentially quantified.


File: sicstus.info,  Node: ref-all-cba,  Next: ref-all-sum,  Prev: ref-all-cse,  Up: ref-all

4.13.3 Collecting a Bag of Solutions
------------------------------------

* Menu:

* ref-all-cba-cal::                     Collecting All Instances

   `bagof/3' is is exactly the same as `setof/3' except that the list
(or alternative lists) returned will not be ordered, and may contain
duplicates.  This relaxation saves time and space in execution.


File: sicstus.info,  Node: ref-all-cba-cal,  Up: ref-all-cba

4.13.3.1 Collecting All Instances
.................................

`findall/3' is a special case of `bagof/3', where all free variables in
the generator are taken to be existentially quantified.  Thus the use
of the operator `^' is avoided.  Because `findall/3' avoids the
relatively expensive variable analysis done by `bagof/3', using
`findall/3' where appropriate rather than `bagof/3' can be considerably
more efficient.

   `findall/4' is a variant of `findall/3' with an extra argument to
which the list of solutions is appended. This can reduce the amount of
append operations in the program.


File: sicstus.info,  Node: ref-all-sum,  Prev: ref-all-cba,  Up: ref-all

4.13.4 Predicate Summary
------------------------

`?X ^ :P'
     there exists an X such that P is provable (used in `setof/3' and
     `bagof/3')

`bagof(?X,:P,-B)  "ISO"'
     B is the bag of instances of X such that P is provable

`findall(?T,:G,-L)  "ISO"'
`findall(?T,:G,?L,?R)'
     L is the list of all solutions T for the goal G, concatenated with
     R or with the empty list

`setof(?X,:P,-S)  "ISO"'
     S is the set of instances of X such that P is provable



File: sicstus.info,  Node: ref-gru,  Next: ref-ere,  Prev: ref-all,  Up: Prolog Intro

4.14 Grammar Rules
==================

* Menu:

* ref-gru-dcg::                         Definite Clause Grammars
* ref-gru-gru::                         How to Use the Grammar Rule Facility
* ref-gru-exa::                         An Example
* ref-gru-tra::                         Semantics of Grammar Rules
* ref-gru-sum::                         Summary of Predicates

   This section describes SICStus Prolog's grammar rules, and the
translation of these rules into Prolog clauses.  At the end of the
section is a list of grammar-related built-in predicates.


File: sicstus.info,  Node: ref-gru-dcg,  Next: ref-gru-gru,  Up: ref-gru

4.14.1 Definite Clause Grammars
-------------------------------

Prolog's grammar rules provide a convenient notation for expressing
definite clause grammars, which are useful for the analysis of both
artificial and natural languages.

   The usual way one attempts to make precise the definition of a
language, whether it is a natural language or a programming lanaguage,
is through a collection of rules called a "grammar".  The rules of a
grammar define which strings of words or symbols are valid sentences of
the language.  In addition, the grammar generally analyzes the sentence
into a structure that makes its meaning more explicit.

   A fundamental class of grammar is the context-free grammar (CFG),
familiar to the computing community in the notation of "BNF"
(Backus-Naur form). In CFGs, the words, or basic symbols, of the
language are identified by "terminal symbols", while categories of
phrases of the language are identified by non-terminal symbols.  Each
rule of a CFG expresses a possible form for a non-terminal, as a
sequence of terminals and non-terminals.  The analysis of a string
according to a CFG is a parse tree, showing the constitutent phrases of
the string and their hierarchical relationships.

   Context-free grammars (CFGs) consist of a series of rules of the
form:
     NT --> BODY.

where NT is a non-terminal symbol and body is a sequence of one or more
items separated by commas.  Each item is either a non-terminal symbol
or a sequence of terminal symbols.  The meaning of the rule is that
BODY is a possible form for a phrase of type NT. A non-terminal symbol
is written as a Prolog atom, while a sequence of terminals is written
as a Prolog list, whereas a terminal may be any Prolog term.

   Definite clause grammars (DCGs) are a generalization of context-free
grammars and rules corresponding to DCGs are referred to as "Grammar
Rules".  A grammar rule in Prolog takes the general form
     HEAD --> BODY.

meaning "a possible form for  HEAD  is  BODY".  Both  BODY  and  HEAD
are sequences  of  one  or  more  items  linked  by  the  standard
Prolog conjunction operator `,' (comma).

   Definite clause grammars  extend  context-free  grammars  in  the
following ways:

   * A non-terminal symbol  may  be  any  callable Prolog  term.

   * A  terminal  symbol  may  be  any  Prolog  term.   To  distinguish
     terminals  from  non-terminals,  a  sequence  of  one or more
     terminal symbols is written within a grammar rule as a Prolog
     list.   An  empty sequence  is  written  as the empty list `[]'.
     If the terminal symbols are character codes, such lists can be
     written (as elsewhere) as strings.  An empty sequence is written
     as the empty list (`[]' or `""').  

   * Extra conditions, in the form of Prolog procedure  calls,  may  be
     included  in  the  right-hand  side of a grammar rule.  These
     extra conditions allow the explicit use of procedure calls in the
     body of a rule to restrict the constitutents accepted.  Such
     procedure calls are written enclosed in curly brackets (`{' and
     `}').

   * The left-hand side of a grammar rule consists of  a  non-terminal,
     optionally  followed  by  a  sequence of terminals (again written
     as a Prolog list).

   * Alternatives may be stated explicitly in the right-hand side of  a
     grammar rule, using the disjunction operator `;' (semicolon) as in
     Prolog.  (The disjunction operator can also be written as `|'
     (vertical-bar).)

   * The cut symbol `!' may be included in the right-hand side of a
     grammar rule, as in a Prolog clause.  The cut symbol does not need
     to be enclosed in curly brackets.  The same is true for the control
     constructs. However, all other built-in predicates not enclosed in
     curly brackets will be treated as non-terminal symbols.  The
     precise meaning of this rule is clarified in *Note ref-gru-tra::.  

   * The extra arguments of non-terminals provide the means of building
     structure (such as parse trees) in grammar rules.  As non-terminals
     are "expanded" by matching against grammar rules, structures are
     progressively built up in the course of the unification process.

   * The extra arguments of non-terminals can also provide a general
     treatment of context dependency by carrying test and contextual
     information.


File: sicstus.info,  Node: ref-gru-gru,  Next: ref-gru-exa,  Prev: ref-gru-dcg,  Up: ref-gru

4.14.2 How to Use the Grammar Rule Facility
-------------------------------------------

Following is a summary of the steps that enable you to construct and
utilitze definte clause grammars:

   STEPS:

  1. Write a grammar, using `-->/2' to formulate rules.

  2. Compile the file containing the grammar rules.  The Load
     Predicates automatically translate the grammar rules into Prolog
     clauses.

  3. Use `phrase/[2,3]' to parse or generate strings.

   OPTIONAL STEPS:

  1. Modify the way in which Prolog translates your grammar rules by
     defining clauses for `user:term_expansion/6'; *note ref-lod-exp::.

  2. In debugging or in using the grammar facility for more obscure
     purposes it may be useful to understand more about `expand_term/2'.


File: sicstus.info,  Node: ref-gru-exa,  Next: ref-gru-tra,  Prev: ref-gru-gru,  Up: ref-gru

4.14.3 An Example
-----------------

As an example, here is a simple grammar that parses an arithmetic
expression (made up of digits and operators) and computes its value.
Create a file containing the following rules:

                                                           _grammar.pl_

     expr(Z) --> term(X), "+", expr(Y), {Z is X + Y}.
     expr(Z) --> term(X), "-", expr(Y), {Z is X - Y}.
     expr(X) --> term(X).

     term(Z) --> number(X), "*", term(Y), {Z is X * Y}.
     term(Z) --> number(X), "/", term(Y), {Z is X / Y}.
     term(Z) --> number(Z).

     number(C) --> "+", number(C).
     number(C) --> "-", number(X), {C is -X}.
     number(X) --> [C], {"0"=<C, C=<"9", X is C - "0"}.

   In the last rule, C is the character code of a decimal digit.

   This grammar can now be used to parse and evaluate an expression by
means of the built-in predicates `phrase/[2,3]'.  For example,
     | ?- [grammar].
     | ?- phrase(expr(Z), "-2+3*5+1").

     Z = 14

     | ?- phrase(expr(Z), "-2+3*5", Rest).

     Z = 13,
     Rest = [] ;

     Z = 1,
     Rest = "*5" ;

     Z = -2,
     Rest = "+3*5" ;

     no


File: sicstus.info,  Node: ref-gru-tra,  Next: ref-gru-sum,  Prev: ref-gru-exa,  Up: ref-gru

4.14.4 Semantics of Grammar Rules
---------------------------------

Grammar rules are best explained in terms of an interpreter.  The
semantics of `phrase/3' is shown as if defined by the interpreter shown
below.  The interpreter's case analysis is as follows:

CONTROL CONSTRUCTS
     (Including cuts and module prefixes).  The interpreter implements
     the semantics of the construct, descending into its argument. Note
     that other built-in predicates are _not_ treated this way.

LISTS
     Treated as terminal symbols.

CURLY BRACKETS
     Treated as procedure calls.

CALLABLE TERMS WITH FUNCTOR N/A
     A grammar rule with head functor N/A is looked up using the
     imaginary predicate `-->/2', unified against, and its body is
     interpreted.  If none exists, this is treated as a procedure call
     to a predicate N/A+2.

NON-CALLABLE TERMS
     Raise error exception.

   The following points are worth noting:

   * The code below defines what constructs of and to what depth
     grammar rule bodies are interpreted, as opposed to being treated as
     non-terminals.

   * Throughout the interpretation, we must keep track of the module
     context.

   * The head non-terminal of a grammar rule is optionally  followed
     by  a  sequence of terminals. This feature is not supported by the
     interpreter, but is supported in the actual implementation.

   * As a general rule, the last argument is unified _after_ any
     side-effects, including cuts.  This is in line with the rule that
     output arguments should not be unified before a cut (*note Eff
     Overview::). In other words, grammar rules are "steadfast".

   * The last clause gives a clue to how grammar rules are actually
     implemented, i.e. by compile-time transformation to ordinary Prolog
     clauses. A grammar rule with head functor N/A is transformed to a
     Prolog clause with head functor N/A+2, the extra arguments being
     `S0' and `S'. `-->/2' is _not_ a predicate.

   The interpreter is as follows, slightly simplified:

     phrase(M:Body, S0, S) :-
             phrase(Body, M, S0, S).

     phrase(Var, M, S0, S) :- \+callable(Var), !,
             must_be(Term, callable, phrase(M:Var,S0,S), 1).
     phrase(M:Body, _, S0, S) :- !,
             phrase(Body, M, S0, S).
     phrase(!, _, S0, S) :- !,
             _cut relevant choicepoints_,
             S0 = S.                 % _unification AFTER action_
     phrase((A, B), M, S0, S) :- !,
             phrase(A, M, S0, S1),
             phrase(B, M, S1, S).
     phrase((A -> B), M, S0, S) :- !,
         (   phrase(A, M, S0, S1) ->
             phrase(B, M, S1, S)
         ).
     phrase((A -> B ; C), M, S0, S) :- !,
         (   phrase(A, M, S0, S1) ->
             phrase(B, M, S1, S)
         ;   phrase(C, M, S0, S)
         ).
     phrase((A ; B), M, S0, S) :- !,
         (   phrase(A, M, S0, S)
         ;   phrase(B, M, S0, S)
         ).
     phrase(\+(A), M, S0, S) :- !,
         (   phrase(A, M, S0, _) ->
             fail
         ;   S0 = S
         ).
     phrase(_^A, M, S0, S) :- !,
             phrase(A, M, S0, S).
     phrase(if(A,B,C), M, S0, S) :- !,
          if(phrase(A, M, S0, S1),
             phrase(B, M, S1, S),
             phrase(C, M, S0, S)).
     phrase(once(A), M, S0, S) :- !,
         (   phrase(A, M, S0, S1) ->
             S1 = S                  % _unification AFTER call_
         ).
     phrase([], _, S0, S) :- !,
             S0 = S.
     phrase([H|T], M, S0, S) :- !,
             S0 = [H|S1],
             phrase(T, M, S1, S).
     phrase({G}, M, S0, S) :- !,
             call(M:G),
             S0 = S.                 % _unification AFTER call_
     phrase(NT, M, S0, S) :-
             \+ \+(M:NT --> Rhs), !, % _grammar rule exists?_
             (M:NT --> Rhs),
             phrase(Rhs, M, S0, S).
     phrase(NT, M, S0, S) :-
             call(M:NT, S0, S).      % _otherwise, treat as procedure call_

   As mentioned above, grammar rules are merely a convenient
abbreviation for ordinary Prolog clauses.  Each grammar rule is
translated into a Prolog clause as it is compiled.  This translation is
exemplified below.

   The procedural interpretation of a grammar rule is that it takes an
input list of symbols or character codes, analyzes some initial portion
of that list, and produces the remaining portion (possibly enlarged) as
output for further analysis.  The arguments required for the input and
output lists are not written explicitly in a grammar rule, but are
added when the rule is translated into an ordinary Prolog clause.  The
translations shown differ from the output of `listing/[0,1]' in that
internal translations such as variable renaming are not represented.
This is done in the interests of clarity.  For example, a rule such as
(A) will be depicted as translating into (B) rather than (C).
     p(X) --> q(X). (A)

     p(X, S0, S) :-
             q(X, S0, S). (B)

     p(A, B, C) :-
             q(A, B, C). (C)

   If there is more than one non-terminal on the right-hand side, as in
(D) the corresponding input and output arguments are identified,
translating into (E):

     p(X, Y) --> q(X), r(X, Y), s(Y). (D)


     p(X, Y, S0, S) :- (E)
         q(X, S0, S1),
         r(X, Y, S1, S2),
         s(Y, S2, S).

   Terminals are translated using the built-in predicate `=/2'.  For
instance, (F) is translated into (G):

     p(X) --> [go, to], q(X), [stop]. (F)

     p(X, S0, S) :- (G)
         S0 = [go,to|S1],
         q(X, S1, S2),
         S2 = [stop|S].

   Extra conditions expressed as explicit procedure calls, enclosed in
curly braces, naturally translate into themselves.  For example (H)
translates to (I):
     p(X) --> [X], {integer(X), X > 0}, q(X). (H)

     p(X, S0, S) :- (I)
         S0 = [X|S1],
         integer(X),
         X > 0,
         q(X, S1, S).

   Terminals on the left-hand side of a rule, enclosed in square
brackets, also translate into a unification.  For example, (J) becomes
(K):
     is(N), [not] --> [aint]. (J)

     is(N, S0, S) :- (K)
         S0 = [aint|S1],
         S = [not|S1].

   Disjunction and other control constructs have a fairly obvious
translation.  For example, (L), a rule that equates phrases like
"(sent) a letter to him" and "(sent) him a letter", translates to (M):
     args(X, Y) --> (L)
             dir(X), [to], indir(Y) |
             indir(Y), dir(X).

     args(X, Y, S0, S) :- (M)
         (   dir(X, S0, S1),
             S1 = [to|S2],
             indir(Y, S2, S)
         |   indir(Y, S0, S1),
             dir(X, S1, S)
         ).

   In order to look at these translations, declare the grammar rules
dynamic and use `listing/[0,1]'.  However, bear in mind that a grammar
rule with head functor N/A is transformed to a Prolog clause with head
functor N/A+2.  For example, the following declaration for grammar rule
(L) would enable you to list its translation, (M):
      :- dynamic args/4.


File: sicstus.info,  Node: ref-gru-sum,  Prev: ref-gru-tra,  Up: ref-gru

4.14.5 Summary of Predicates
----------------------------

`:HEAD --> :BODY'
     A possible form for HEAD is BODY

`expand_term(+T,-X)  "hookable"'
     term T expands to term X using `user:term_expansion/6' or grammar
     rule expansion

`phrase(:P, -L)'
`phrase(:P, ?L, ?R)'
     R or the empty list is what remains of list L after phrase P has
     been found

`user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2, -TOKENS2)  "hook"'
     Overrides or complements the standard transformations to be done by
     `expand_term/2'.



File: sicstus.info,  Node: ref-ere,  Next: ref-msg,  Prev: ref-gru,  Up: Prolog Intro

4.15 Errors and Exceptions
==========================

* Menu:

* ref-ere-ove::                         Overview
* ref-ere-rex::                         Raising Exceptions
* ref-ere-hex::                         Handling Exceptions
* ref-ere-err::                         Error Classes
* ref-ere-exa::                         An Example
* ref-ere-int::                         Interrupting Execution
* ref-ere-sum::                         Summary of Predicates


File: sicstus.info,  Node: ref-ere-ove,  Next: ref-ere-rex,  Up: ref-ere

4.15.1 Overview
---------------

Whenever the Prolog system encounters a situation where it cannot
continue execution, it raises an exception.  For example, if a built-in
predicate detects an argument of the wrong type, it raises a
`type_error' exception.  The manual page description of each built-in
predicate lists the kinds of exceptions that can be raised by that
built-in predicate.

   The default effect of raising an exception is to terminate the
current computation and then print an error message.  After the error
message, you are back at Prolog's top level.  For example, if the goal
     X is a/2

is executed somewhere in a program you get
     ! Type error in argument 2 of is/2
     ! expected number, but found a
     ! goal:  A is a/2

     | ?-

   Particular things to notice in this message are:

`!'
     This character indicates that this is an error message rather than
     a warning(1) or informational message.

`Type Error'
     This is the "exception class".  Every exception raised by the
     system is categorized into one of a small number of classes.  The
     classes are listed in *Note ref-ere-err::.

`goal:'
     The goal that caused the exception to be raised.

   ---------- Footnotes ----------

   (1) The difference between an error (including exceptions) and a
warning: A "warning" is issued if Prolog detects a situation that is
likely to cause problems, though it is possible that you intended it.
An "error", however, indicates that Prolog recognizes a situation where
it cannot continue.


File: sicstus.info,  Node: ref-ere-rex,  Next: ref-ere-hex,  Prev: ref-ere-ove,  Up: ref-ere

4.15.2 Raising Exceptions
-------------------------

You can raise exceptions from your own code using one of the two
equivalent built-in predicates:
     raise_exception(+EXCEPTIONCODE)
     throw(+EXCEPTIONCODE)

   The argument to this predicate is the "exception term"; it is an
arbitrary non-variable term of which the principal functor indicates
the exception class.  You can use the same exception classes as the
system (see *Note ref-ere-err::), or you can use your own exception
classes.

   *Note lib-types:: for an alternative interface to raising error
exceptions, which tries to include line number information for
source-linked debugging.

   Error messages like the one shown above are printed using the
built-in predicate `print_message/2'.  One of the arguments to
`print_message/2' is the exception term.  `print_message/2' can be
extended, as described in *Note ref-msg::, so that you can have
appropriate error messages printed corresponding to your own exception
classes.

   *Please note*: If the exception term contains attributed variables
(*note lib-atts::) or suspended goals (*note ref-sem-sec::), those
attributes do not become part of the exception.  To retain the
attributes, you can use `copy_term/3' (*note ref-lte-cpt::).


File: sicstus.info,  Node: ref-ere-hex,  Next: ref-ere-err,  Prev: ref-ere-rex,  Up: ref-ere

4.15.3 Handling Exceptions
--------------------------

* Menu:

* ref-ere-hex-pgo::                     Protecting a Particular Goal
* ref-ere-hex-hup::                     Handling Unknown Predicates

   It is possible to protect a part of a program against abrupt
termination in the event of an exception.  There are two ways to do
this:
   * Trap exceptions to a particular goal by calling `on_exception/3' as
     described in *Note ref-ere-hex-pgo::.

   * Handle undefined predicates or subsets of them through the hook
     predicate `user:unknown_predicate_handler/3'; see *Note
     ref-ere-hex-hup::.


File: sicstus.info,  Node: ref-ere-hex-pgo,  Next: ref-ere-hex-hup,  Up: ref-ere-hex

4.15.3.1 Protecting a Particular Goal
.....................................

The built-in predicate `on_exception/3' enables you to handle
exceptions to a specific goal:

     `on_exception(?EXCEPTIONCODE, :PROTECTEDGOAL, :HANDLER)'

   PROTECTEDGOAL is executed.  If all goes well, it will behave just as
if you had written PROTECTEDGOAL without the `on_exception/3' wrapper.
If an exception is raised while PROTECTEDGOAL is running, Prolog will
abandon PROTECTEDGOAL entirely.  Any bindings made by PROTECTEDGOAL
will be undone, just as if it had failed.  If the exception occurred in
the scope of a `call_cleanup(GOAL,CLEANUP', CLEANUP will be called.
Side-effects, such as asserts and retracts, are not undone, just as
they are not undone when a goal fails.  After undoing the bindings,
Prolog tries to unify the exception term raised with the EXCEPTIONCODE
argument.  If this unification succeeds, HANDLER will be executed as if
you had written

     EXCEPTIONCODE=<the actual exception term>,
     HANDLER

   If this unification fails, Prolog will keep searching up the
ancestor list looking for another exception handler.  If it reaches
Prolog's top level (or a break level) without having found a call to
`on_exception/3' with a matching EXCEPTIONCODE, an appropriate error
message is printed (using `print_message/2').

   PROTECTEDGOAL need not be determinate.  That is, backtracking into
PROTECTEDGOAL is possible, and the exception handler becomes reactivated
in this case.  However, if PROTECTEDGOAL is determinate, the call to
`on_exception/3' is also determinate.

   The PROTECTEDGOAL is logically _inside_ the `on_exception/3' form,
but the HANDLER is _not_.  If an exception is raised inside the
HANDLER, this `on_exception/3' form will _not_ be reactivated.  If you
want an exception handler that protects itself, you have to program it,
perhaps like this:
     recursive_on_exception_handler(Err, Goal, Handler) :-
         on_exception(Err, Goal,
             recursive_on_exception_handler(Err, Handler, Handler)).

   Certain built-in and library predicates rely on the exception
mechanism, so it is usually a bad idea to let PATTERN be a variable,
matching any exception.  If it must be a variable, the HANDLER should
examine the exception and pass it on if it is not relevant to the
current invocation.

   In a development system, any previously uncaught exception is caught
and an appropriate error message is printed before returning to the top
level.  In recursive calls to Prolog from C, uncaught exceptions are
returned back to C instead.  The printing of these and other messages
in a development system is handled by the predicate `print_message/2'
(*note ref-msg::).

   `catch(PROTECTEDGOAL, EXCEPTIONCODE, HANDLER)' is the same as
`on_exception(EXCEPTIONCODE, PROTECTEDGOAL, HANDLER)'.


File: sicstus.info,  Node: ref-ere-hex-hup,  Prev: ref-ere-hex-pgo,  Up: ref-ere-hex

4.15.3.2 Handling Unknown Predicates
....................................

Users can write a handler for the specific exception occurring when an
undefined predicate is called by defining clauses for the hook
predicate `user:unknown_predicate_handler/3'.  This can be thought of as
a "global" exception handler for this particular exception, because
unlike `on_exception/3', its effect is not limited to a particular
goal.  Furthermore, the exception is handled at the point where the
undefined predicate is called.

   The handler can be written to apply to all unknown predicates, or to
a class of them.  The reference page contains an example of
constraining the handler to certain predicates.


File: sicstus.info,  Node: ref-ere-err,  Next: ref-ere-exa,  Prev: ref-ere-hex,  Up: ref-ere

4.15.4 Error Classes
--------------------

* Menu:

* ref-ere-err-ins::                     Instantiation Errors
* ref-ere-err-typ::                     Type Errors
* ref-ere-err-dom::                     Domain Errors
* ref-ere-err-eva::                     Evaluation Errors
* ref-ere-err-rep::                     Representation Errors
* ref-ere-err-exi::                     Existence Errors
* ref-ere-err-per::                     Permission Errors
* ref-ere-err-con::                     Context Errors
* ref-ere-err-cns::                     Consistency Errors
* ref-ere-err-syn::                     Syntax Errors
* ref-ere-err-res::                     Resource Errors
* ref-ere-err-sys::                     System Errors

   Exceptions raised by the Prolog system are called errors.  The set
of exception classes used by the system has been kept small.  Here is a
complete list:

Instantiation Error
     An input argument is insufficiently instantiated.

Type Error
     An input argument is of the wrong type.

Domain Error
     An input argument is illegal but of the right type.

Evaluation Error
     An incorrect arithmetic expression was evaluated.

Representation Error
     A computed value cannot be represented.

Existence Error
     Something does not exist.

Permission Error
     Specified operation is not permitted.

Context Error
     Specified operation is not permitted in this context.

Consistency Error
     Two otherwise correct values are inconsistent with each other.

Syntax Error
     Error in reading a term.

Resource Error
     Some resource limit has been exceeded.

System Error
     An error detected by the operating system.


   The format of the exception raised by the built-in predicates is:

     error(ISO_ERROR, SICSTUS_ERROR)

where ISO_ERROR is the error term prescribed by the ISO Prolog
standard, while SICSTUS_ERROR is the part defined by the standard to be
implementation dependent. In the case of SICStus Prolog, this is the
SICStus error term, which normally contains additional information,
such as the goal and the argument number causing the error.  Arguments
are numbered from 1 upwards.

   The list below itemizes the error terms, showing the ISO_ERROR and
SICSTUS_ERROR form of each one, in that order.  Note that the SICStus
and ISO error terms do not always belong to the same error class, and
that the context and consistency error classes are extensions to the
ISO Prolog standard.

   The goal part of the error term may optionally have the form
`$@(CALLABLE,PC)' where PC is an internal encoding of the line of code
containing the culprit goal or one of its ancestors.  To decompose an
annotated goal AGOAL into a GOAL proper and a SOURCEINFO descriptor
term, indicating the source position of the goal, use:

     ?- goal_source_info(AGOAL, GOAL, SOURCEINFO).

   The reference page gives details about the SOURCEINFO format.

`instantiation_error'
`instantiation_error(GOAL,ARGNO)'
     GOAL was called with insufficiently instantiated variables.

`type_error(TYPENAME,CULPRIT)'
`type_error(GOAL,ARGNO,TYPENAME,CULPRIT)'
     GOAL was called with the wrong type of argument(s).  TYPENAME is
     the expected type and CULPRIT what was actually found.

`domain_error(DOMAIN,CULPRIT)'
`domain_error(GOAL,ARGNO,DOMAIN,CULPRIT)'
     GOAL was called with argument(s) of the right type but with
     illegal value(s).  DOMAIN is the expected domain and CULPRIT what
     was actually found.

`existence_error(OBJECTTYPE,CULPRIT)'
`existence_error(GOAL,ARGNO,OBJECTTYPE,CULPRIT,RESERVED)'
     Something does not exist as indicated by the arguments.  If the
     `unknown' Prolog flag is set to `error', this error is raised with
     ARGNO set to 0 when an undefined predicate is called.  

`permission_error(OPERATION,OBJECTTYPE,CULPRIT)'
`permission_error(GOAL,OPERATION,OBJECTTYPE,CULPRIT,RESERVED)'
     The OPERATION is not permitted on CULPRIT of the OBJECTTYPE.

`context_error(CONTEXTTYPE,COMMANDTYPE)'
`context_error(GOAL,CONTEXTTYPE,COMMANDTYPE)'
     The COMMANDTYPE is not permitted in CONTEXTTYPE.

`syntax_error(MESSAGE)'
`syntax_error(GOAL,POSITION,MESSAGE,TOKENS,AFTERERROR)'
     A syntax error was found when reading a term with `read/[1,2]' or
     assembling a number from its characters with `number_chars/2' or
     `number_codes/2'. In the former case this error is raised only if
     the `syntax_errors' flag is set to `error'.  

`evaluation_error(ERRORTYPE,CULPRIT)'
`evaluation_error(GOAL,ARGNO,ERRORTYPE,CULPRIT)'
     An incorrect arithmetic expression was evaluated.

`representation_error(ERRORTYPE)'
`representation_error(GOAL,ARGNO,ERRORTYPE)'
     A representation error occurs when the program tries to compute
     some well-defined value that cannot be represented, such as a
     compound term with arity > 255.

`consistency_error(CULPRIT1,CULPRIT2,MESSAGE)'
`consistency_error(GOAL,CULPRIT1,CULPRIT2,MESSAGE)'
     A consistency error occurs when two otherwise valid values or
     operations have been specified that are inconsistent with each
     other.

`resource_error(RESOURCETYPE)'
`resource_error(GOAL,RESOURCETYPE)'
     A resource error occurs when SICStus Prolog has insufficient
     resources to complete execution.  The only value for RESOURCETYPE
     that is currently in use is `memory'.

`system_error'
`system_error(MESSAGE)'
     An error occurred while dealing with the operating system.

   Most exception terms include a copy of the GOAL that raised the
exception.

   In general, built-in predicates that cause side-effects, such as the
opening of a stream or asserting a clause into the Prolog database,
attempt to do all error checking before the side-effect is performed.
Unless otherwise indicated in the documentation for a particular
predicate or error class, it should be assumed that goals that raise
exceptions have not performed any side-effect.


File: sicstus.info,  Node: ref-ere-err-ins,  Next: ref-ere-err-typ,  Up: ref-ere-err

4.15.4.1 Instantiation Errors
.............................

An instantiation error occurs when a predicate or command is called with
one of its input arguments insufficiently instantiated.

   The SICSTUS_ERROR term associated with an instantiation error is
     instantiation_error(GOAL, ARGNO)

where ARGNO is a non-negative integer indicating which argument caused
the problem.  ARGNO=0 means that the problem could not be localized to
a single argument.

   Note that the ARGNOth argument of GOAL might well be a non-variable:
the error is _in_ that argument.  For example, the goal
     X is Y+1

where Y is uninstantiated raises the exception
     instantiation_error(_2298 is _2301+1,2)

because the second argument to `is/2' contains a variable.


File: sicstus.info,  Node: ref-ere-err-typ,  Next: ref-ere-err-dom,  Prev: ref-ere-err-ins,  Up: ref-ere-err

4.15.4.2 Type Errors
....................

A type error occurs when an input argument is of the wrong "type".  In
general, a "type" is taken to be a class of terms for which there
exists a unary "type test predicate".  Some types are built-in, such as
`atom/1' and `integer/1'.

   The type of a term is the sort of thing you can tell just by looking
at it, without checking to see how _big_ it is.  So "integer" is a
type, but "non-negative integer" is not, and "atom" is a type, but
"atom with 5 letters in its name" and "atom starting with `x'" are not.

   The point of a type error is that you have _obviously_ passed the
wrong sort of argument to a command; perhaps you have switched two
arguments, or perhaps you have called the wrong predicate, but it isn't
a subtle matter of being off by one.

   Most built-in predicates check all their input arguments for type
errors.

   The SICSTUS_ERROR term associated with a type error is
     type_error(GOAL, ARGNO, TYPENAME, CULPRIT)

ARGNO
     CULPRIT occurs somewhere in the ARGNOth argument of GOAL.

TYPENAME
     says what sort of term was expected; it should be the name of a
     unary predicate that is true of whatever terms would not provoke a
     type error.

CULPRIT
     is the actual term being complained about: TYPENAME(CULPRIT)
     should be false.

   For example, suppose we had a predicate
     date_plus(NUMBEROFDAYS, DATE0, DATE)

which held when DATE0 and DATE were `date(Y,M,D)' records and
NUMBEROFDAYS was the number of days between those two dates.  You might
see an error term such as
     type_error(/* Goal     */ date_plus(27, date(18,mar,11), _235),
                /* Argno    */ 2,
                /* TypeName */ integer,
                /* Culprit  */ mar


File: sicstus.info,  Node: ref-ere-err-dom,  Next: ref-ere-err-eva,  Prev: ref-ere-err-typ,  Up: ref-ere-err

4.15.4.3 Domain Errors
......................

A domain error occurs when an input argument is of the right type but
there is something wrong with its value.  For example, the second
argument to `open/3' is supposed to be an atom that represents a valid
mode for opening a file, such as `read' or `write'.  If a number or a
compound term is given instead, that is a type error.  If an atom is
given that is not a valid mode, that is a domain error.

   The main reason that we distinguish between type errors and domain
errors is that they usually represent different sorts of mistakes in
your program.  A type error usually indicates that you have passed the
wrong argument to a command, whereas a domain error usually indicates
that you passed the argument you meant to check, but you hadn't checked
it enough.

   The SICSTUS_ERROR term associated with a domain error is
     domain_error(GOAL, ARGNO, DOMAINNAME, CULPRIT)

   The arguments correspond to those of the SICSTUS_ERROR term for a
type error, except that DOMAINNAME is not in general the name of a unary
predicate: it needn't even be an atom.  For example, if some command
requires an argument to be an integer in the range 1..99, it might use
`between(1,99)' as the DOMAINNAME.  With respect to the `date_plus'
example under Type Errors, if the month had been given as 13 it would
have passed the type test but would raise a domain error.

   For example, the goal
     open(somefile,rread,S)

raises the exception
     domain_error(open(somefile,rread,_2490),2,'i/o mode',rread,'')

   The MESSAGE argument is used to provide extra information about the
problem.


File: sicstus.info,  Node: ref-ere-err-eva,  Next: ref-ere-err-rep,  Prev: ref-ere-err-dom,  Up: ref-ere-err

4.15.4.4 Evaluation Errors
..........................

An evaluation error occurs when an incorrect arithmetic expression was
evaluated.  The SICSTUS_ERROR term associated with an evaluation error
is
     evaluation_error(GOAL, ARGNO, TYPENAME, CULPRIT)

   This has the same arguments as a type error.


File: sicstus.info,  Node: ref-ere-err-rep,  Next: ref-ere-err-exi,  Prev: ref-ere-err-eva,  Up: ref-ere-err

4.15.4.5 Representation Errors
..............................

A representation error occurs when your program calls for the
computation of some well-defined value that cannot be represented.

   Most representation errors are some sort of overflow:
     functor(T, f, 1000)             % maximum arity is 255
     atom_codes(X, L)                % if length of L > 65535

are all representation errors.  Floating-point overflow is a
representation error.

   The SICSTUS_ERROR term for a representation error is
     representation_error(GOAL, ARGNO, MESSAGE)

ARGNO
     identifies the argument of the goal that cannot be constructed.

MESSAGE
     further classifies the problem.  A message of `0' or `''' provides
     no further information.


File: sicstus.info,  Node: ref-ere-err-exi,  Next: ref-ere-err-per,  Prev: ref-ere-err-rep,  Up: ref-ere-err

4.15.4.6 Existence Errors
.........................

An existence error occurs when a predicate attempts to access something
that does not exist.  For example, trying to compile a file that does
not exist, erasing a database reference that has already been erased.  A
less obvious example:  reading past the end of file marker in a stream
is regarded as asking for an object (the next character) that does not
exist.

   The SICSTUS_ERROR term associated with an existence error is
     existence_error(GOAL, ARGNO, OBJECTTYPE, CULPRIT, MESSAGE)

ARGNO
     index of argument of GOAL where CULPRIT appears

OBJECTTYPE
     expected type of non-existent object

CULPRIT
     name for the non-existent object

MESSAGE
     the constant `0' or `''', or some additional information provided
     by the operating system or other support system indicating why
     CULPRIT is thought not to exist.

   For example, `see('../brother/niece')' might raise the exception
     existence_error(see('../brother/niece'),
             1, file, '/usr/stella/parent/brother/niece',
             errno(20))

where the MESSAGE encodes the system error `ENOTDIR' (some component of
the path is not a directory).

   As a general rule, if CULPRIT was provided in the goal as some sort
of context-sensitive name, the Prolog system will try to resolve it to
an absolute name, as shown here, so that you can see whether the
problem is just that the name was resolved in the wrong context.


File: sicstus.info,  Node: ref-ere-err-per,  Next: ref-ere-err-con,  Prev: ref-ere-err-exi,  Up: ref-ere-err

4.15.4.7 Permission Errors
..........................

A permission error occurs when an operation is attempted that is among
the kinds of operation that the system is in general capable of
performing, and among the kinds that you are in general allowed to
request, but this particular time it isn't permitted.  Usually, the
reason for a permission error is that the "owner" of one of the objects
has requested that the object be protected.

   For example, an attempts to assert or retract clauses for a
predicate that has not been declared `:-dynamic' is rejected with a
permission error.

   File system protection is another major source of such errors.

   The SICSTUS_ERROR term associated with a permission error is
     permission_error(GOAL, OPERATION, OBJECTTYPE, CULPRIT, MESSAGE)

OPERATION
     operation attempted; OPERATION exists but is not permitted with
     CULPRIT.

OBJECTTYPE
     CULPRIT's type.

CULPRIT
     name of protected object.

MESSAGE
     provides such operating-system-specific additional information as
     may be available.  A message of `0' or `''' provides no further
     information.


File: sicstus.info,  Node: ref-ere-err-con,  Next: ref-ere-err-cns,  Prev: ref-ere-err-per,  Up: ref-ere-err

4.15.4.8 Context Errors
.......................

A context error occurs when a goal or declaration appears in the wrong
place.  There may or may not be anything wrong with the goal or
declaration as such; the point is that it is out of place.  Calling
`multifile/1' as a goal is a context error, as is having `:-module/2'
anywhere but as the first term in a source file.

   The SICSTUS_ERROR term associated with a context error is
     context_error(GOAL, CONTEXTTYPE, COMMANDTYPE)

CONTEXTTYPE
     the context in which the command was attempted.

COMMANDTYPE
     the type of command that was attempted.



File: sicstus.info,  Node: ref-ere-err-cns,  Next: ref-ere-err-syn,  Prev: ref-ere-err-con,  Up: ref-ere-err

4.15.4.9 Consistency Errors
...........................

A consistency error occurs when two otherwise valid values or
operations have been specified that are inconsistent with each other.
For example, if two modules each import the same predicate from the
other, that is a consistency error.

   The SICSTUS_ERROR term associated with a consistency error is
     consistency_error(GOAL, CULPRIT1, CULPRIT2, MESSAGE)

CULPRIT1
     One of the conflicting values/operations.

CULPRIT2
     The other conflicting value/operation..

MESSAGE
     Additional information, or `0', or `'''.


File: sicstus.info,  Node: ref-ere-err-syn,  Next: ref-ere-err-res,  Prev: ref-ere-err-cns,  Up: ref-ere-err

4.15.4.10 Syntax Errors
.......................

A syntax error occurs when data are read from some external source but
have an improper format or cannot be processed for some other reason.
This category mainly applies to `read/1' and its variants.

   The SICSTUS_ERROR term associated with a syntax error is
     syntax_error(GOAL, POSITION, MESSAGE, LEFT, RIGHT)

where GOAL is the goal in question, POSITION identifies the position in
the stream where reading started, and MESSAGE describes the error.
Left and right are lists of tokens before and after the error,
respectively.

   Note that the POSITION is where reading started, not where the error
_is_.

   `read/1' does two things.  First, it reads a sequence of characters
from the current input stream up to and including a clause terminator,
or the end of file marker, whichever comes first.  Then it attempts to
parse the sequence of characters as a Prolog term.  If the parse is
unsuccessful, a syntax error occurs.  Thus, in the case of syntax
errors, `read/1' disobeys the normal rule that predicates should detect
and report errors before they perform any side-effects, because the
side-effect of reading the characters has been done.

   A syntax error does not necessarily cause an exception to be raised.
The behavior can be controlled via  the `syntax_errors' Prolog flag as
follows.  The following values are possible:

`quiet'
     When a syntax error is detected, nothing is printed, and `read/1'
     just quietly fails.

`dec10'
     This provides compatibility with other Prologs:  when a syntax
     error is detected, a syntax error message is printed on
     `user_error', and the `read' is repeated.  This is the default.

`fail'
     This provides compatibility with other Prologs.  When a syntax
     error is detected, a syntax error message is printed on
     `user_error', and the `read' then fails.

`error'
     When a syntax error is detected, an exception is raised.


File: sicstus.info,  Node: ref-ere-err-res,  Next: ref-ere-err-sys,  Prev: ref-ere-err-syn,  Up: ref-ere-err

4.15.4.11 Resource Errors
.........................

A resource error occurs when some resource runs out.  For example, you
can run out of virtual memory, or you can exceed the operating system
limit on the number of simultaneously open files.

   Often a resource error arises because of a programming mistake:  for
example, you may exceed the maximum number of open files because your
program doesn't close files when it has finished with them.  Or, you
may run out of virtual memory because you have a non-terminating
recursion in your program.

   The SICSTUS_ERROR term for a resource error is
     resource_error(GOAL, RESOURCE)

GOAL
     A copy of the goal, or `0' if no goal was responsible; for example
     there is no particular goal to blame if you run out of virtual
     memory.

RESOURCE
     identifies the resource that was exhausted.

MESSAGE
     an operating-system-specific message.  Usually it will be
     `errno(ERRNO)'.



File: sicstus.info,  Node: ref-ere-err-sys,  Prev: ref-ere-err-res,  Up: ref-ere-err

4.15.4.12 System Errors
.......................

System errors are problems that the operating system notices (or
causes).  Note that many of the exception indications returned by the
operating system (such as "file does not exist") are mapped to Prolog
exceptions; it is only really unexpected things that show up as system
errors.

   The SICSTUS_ERROR term for a system error is
     system_error(MESSAGE)

where MESSAGE is not further specified.


File: sicstus.info,  Node: ref-ere-exa,  Next: ref-ere-int,  Prev: ref-ere-err,  Up: ref-ere

4.15.5 An Example
-----------------

Suppose you want a routine that is given a filename and a prompt
string.  This routine is to open the file if it can; otherwise it is to
prompt the user for a replacement name.  If the user enters an empty
name, it is to fail.  Otherwise, it is to keep asking the user for a
name until something works, and then it is to return the stream that
was opened.  (There is no need to return the file name that was finally
used.  We can get it from the stream.)

     :- use_module(library(prompt), [
             prompted_line/2
        ]).

     open_output(FileName, Prompt, Stream) :-
             on_exception(Error,
                 open(FileName, write, Stream),
                 (   file_error(Error) ->
                     print_message(warning, Error),
                     retry_open_output(Prompt, Stream)
                 ;   raise_exception(Error)
                 )).

     file_error(domain_error(open(_,_,_), 1, _, _, _)).
     file_error(existence_error(open(_,_,_), 1, _, _, _)).
     file_error(permission_error(open(_,_,_), _, _, _, _)).

     retry_open_output(Prompt, Stream) :-
             prompted_line(Prompt, Chars),
             atom_chars(FileName, Chars),
             FileName \== '',
             open_output(FileName, Prompt, Stream).

   What this example does _not_ catch is as interesting as what it does.
All instantiation errors, type errors, context errors, and evaluation
errors are re-raised, as they represent errors in the program.

   As the previous example shows, you generally do not want to catch
_all_ exceptions that a particular goal might raise.


File: sicstus.info,  Node: ref-ere-int,  Next: ref-ere-sum,  Prev: ref-ere-exa,  Up: ref-ere

4.15.6 Interrupting Execution
-----------------------------

There exist more drastic means of interrupting the normal control flow.
To invoke a recursive top-level, use:

     ?- break.

   To exit from Prolog, use:

     ?- halt.

   To exit from Prolog with return code CODE, use:

     ?- halt(CODE).

   To abort the execution of the current query and return to the
top-level, use:

     ?- abort.

     *Please note:* `halt/[0,1]' and `abort/0' are implemented by
     raising a reserved exception, which has a handler at the top level
     of development systems and executables built with the `spld' tool.
     Thus they give the opportunity for cleanup goals (see
     `call_cleanup/2') to run.



File: sicstus.info,  Node: ref-ere-sum,  Prev: ref-ere-int,  Up: ref-ere

4.15.7 Summary of Predicates
----------------------------

`abort'
     abort execution of the program; return to current break level

`break'
     start a new break-level to interpret commands from the user

`catch(:P,?E,:H)  "ISO"'
     specify a handler H for any exception E arising in the execution
     of the goal P

`user:error_exception(+EXCEPTION)  "hook"'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

`goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.

`halt  "ISO"'
`halt(C)  "ISO"'
     exit from Prolog with exit code C

`on_exception(?E,:P,:H)'
     specify a handler H for any exception E arising in the execution
     of the goal P

`raise_exception(+E)'
     raise exception E

`throw(+E)  "ISO"'
     raise exception E


File: sicstus.info,  Node: ref-msg,  Prev: ref-ere,  Up: Prolog Intro

4.16 Messages and Queries
=========================

This section describes the two main aspects of user interaction,
displaying messages and querying the user.  We will deal with these two
issues in turn.

* Menu:

* Message Processing:: Message Processing
* Message Handling Predicates:: Message Handling Predicates
* Query Processing:: Query Processing
* Query Handling Predicates:: Query Handling Predicates
* Message Summary:: Predicate Summary


File: sicstus.info,  Node: Message Processing,  Next: Message Handling Predicates,  Up: ref-msg

4.16.1 Message Processing
-------------------------

Every message issued by the Prolog system is displayed using a single
predicate:
     `print_message(SEVERITY, MESSAGE)'

   MESSAGE is a term that encodes the message to be printed.  The
format of message terms is subject to change, but can be inspected in
the file `library('SU_messages')' of the SICStus Prolog distribution.

   The atom SEVERITY specifies the type (or importance) of the message.
The following table lists the severities known to the SICStus Prolog
system, together with the line prefixes used in displaying messages of
the given severity:

`error'           `'! ''   for error messages
`warning'         `'* ''   for warning messages
`informational'   `'% ''   for informational messages
`help'            `'''     for help messages
`query'           `'''     for query texts (*note Query Processing::)
`silent'          `'''     a special kind of message, which normally
                           does not produce any output, but can be
                           intercepted by hooks

   `print_message/2' is a built-in predicate, so that users can invoke
it to have their own messages processed in the same way as the system
messages.

   The processing and printing of the messages is highly customizable.
For example, this allows the user to change the language of the
messages, or to make them appear in dialog windows rather than on the
terminal.

* Menu:

* Message Phases:: Phases of Message Processing
* Message Generation Phase:: Message Generation Phase
* Message Printing Phase:: Message Printing Phase


File: sicstus.info,  Node: Message Phases,  Next: Message Generation Phase,  Up: Message Processing

4.16.1.1 Phases of Message Processing
.....................................

Messages are processed in two major phases.  The user can influence the
behavior of each phase using appropriate hooks, described later.

   The first phase is called the _message generation phase_: it
determines the text of the message from the input (the abstract message
term).  No printing is done here.  In this phase the user can change
the phrasing or the language of the messages.

   The result of the first phase is created in the form of a
"format-command list".  This is a list whose elements are
"format-commands", or the atom `nl' denoting the end of a line.  A
format-command describes a piece of text not extending over a line
boundary and it can be one of the following:

`FORMATSTRING-ARGS'
`format(FORMATSTRING, ARGS)'
     This indicates that the message text should appear as if printed by
          format(FORMATSTRING, ARGS).

`write_term(TERM, OPTIONS)'
     This indicates that the message text should appear as if printed by
          write_term(TERM, OPTIONS).

`write_term(TERM)'
     Equivalent to `write_term(TERM, OPTIONS)' where OPTIONS is the
     actual value of the Prolog flag `toplevel_print_options'.  

   As an example, let us see what happens in case of the toplevel call
`_ =:= 3'.  An instantiation error is raised by the Prolog system,
which is caught, and the abstract message term
`error(instantiation_error,instantiation_error(_=:=3,1))' is
generated--the first argument is the goal, and the second argument is
the position of the uninstantiated variable within the goal.  In the
first phase of message processing this is converted to the following
format-command list:
     ['Instantiation error'-[],' in argument ~d of ~q'-[1,=:= /2],nl,
      'goal:  '-[],write_term(_=:=3),nl]

   A minor transformation, so-called _line splitting_ is performed on
the message text before it is handed over to the second phase.  The
format-command list is broken up along the `nl' atoms into a list of
lines, where each line is a list of format-commands.  We will use the
term format-command lines to refer to the result of this transformation.

   In the example above, the result of this conversion is the following:
     [['Instantiation error'-[],' in argument ~d of ~q'-[1,=:= /2]],
      ['goal:  '-[],write_term(_=:=3)]]
The above format-command lines term is the input of the second
phase of message processing.

   The second phase is called the _message printing phase_, this is
where the message is actually displayed.  The severity of the message is
used here to prefix each line of the message with some characters
indicating the type of the message, as listed above.

   The user can change the exact method of printing (e.g. redirection of
messages to a stream, a window, or using different prefixes, etc.)
through appropriate hooks.

   In our example the following lines are printed by the second phase
of processing:
     ! Instantiation error in argument 1 of =:= /2
     ! goal:  _=:=3

   The user can override the default message processing mechanism in the
following two ways:
   * A global method is to define the hook predicate
     `portray_message/2', which is the first thing called by message
     processing.  If this hook exists and succeeds, it overrides all
     other processing--nothing further is done by `print_message/2'.

   * If a finer method of influencing the behavior of message
     processing is needed, there are several further hooks provided,
     which affect only one phase of the process.  These are described
     in the following paragraphs.


File: sicstus.info,  Node: Message Generation Phase,  Next: Message Printing Phase,  Prev: Message Phases,  Up: Message Processing

4.16.1.2 Message Generation Phase
.................................

The default message generation predicates are located in the
`library('SU_messages')' file, in the `'SU_messages'' module, together
with other message and query related predicates.  This is advantageous
when these predicates have to be changed as a whole (for example when
translating all messages to another language), because this can be done
simply by replacing the file `library('SU_messages')' by a new one.

   In the message generation phase three alternative methods are tried:

   * First the hook predicate `generate_message_hook/3' is executed, if
     it succeeds, it is assumed to deliver the output of this phase.

   * Next the default message generation is invoked via
     `'SU_messages':generate_message/3'.

   * In the case that neither of the above methods succeed, a built-in
     fall-back message generation method is used.

   The hook predicate `generate_message_hook/3' can be used to override
the default behavior, or to handle new messages defined by the
programmer, which do not fit the default message generation schemes.
The latter can also be achieved by adding new clauses to the extendible
`'SU_messages':generate_message/3' predicate.

   If both the hook and the default method refuses to handle the
message, the following simple format-command list is generated from the
abstract message term MESSAGE:
     ['~q'-[MESSAGE],nl]
This will result in displaying the abstract message term itself,
as if printed by `writeq/1'.

   For messages of the severity `silent' the message generation phase
is skipped, and the `[]' format-command list is returned as the output.


File: sicstus.info,  Node: Message Printing Phase,  Prev: Message Generation Phase,  Up: Message Processing

4.16.1.3 Message Printing Phase
...............................

By default this phase is handled by the built-in predicate
`print_message_lines/3'.  Each line of the message is prefixed with a
string depending on the severity, and is printed to `user_error'.  The
`query' severity is special--no newline is printed after the last line
of the message.

   This behavior can be overridden by defining the hook predicate
`message_hook/3', which is called with the severity of the message, the
abstract message term and its translation to format-command lines.  It
can be used to make smaller changes, for example by calling
`print_message_lines/3' with a stream argument other than `user_error',
or to implement a totally different display method such as using dialog
windows for messages.

   For messages of the severity `silent' the message printing phase
consists of calling the hook predicate `message_hook/3' only.  Even if
the hook fails, no printing is done.


File: sicstus.info,  Node: Message Handling Predicates,  Next: Query Processing,  Prev: Message Processing,  Up: ref-msg

4.16.2 Message Handling Predicates
----------------------------------

`print_message(+SEVERITY, +MESSAGE)  "hookable"'
     Portrays or else writes MESSAGE of a given SEVERITY on the
     standard error stream.

`portray_message(+SEVERITY, +MESSAGE)  "hook"'
`user:portray_message(+SEVERITY, +MESSAGE)'
     Tells `print_message/2' what to do.

`generate_message_hook(+MESSAGE, -L0, -L)  "hook"'
`user:generate_message_hook(+MESSAGE, -L0, -L)'
     A way for the user to override the call to
     `'SU_messages':generate_message/3' in the message generation phase
     in `print_message/2'.

`'SU_messages':generate_message(+MESSAGE, -L0, -L)  "extendible"'
     Predefined message generation rules.

`message_hook(+SEVERITY, +MESSAGE, +LINES)  "hook"'
`user:message_hook(+SEVERITY, +MESSAGE, +LINES)'
     Overrides the call to `print_message_lines/3' in
     `print_message/2'.  A way for the user to intercept the abstract
     message term MESSAGE of type SEVERITY, whose translation is LINES,
     before it is actually printed.

`print_message_lines(+STREAM, +SEVERITY, +LINES)'
     Print the LINES to STREAM, preceding each line with a prefix
     defined by SEVERITY.

`goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.


File: sicstus.info,  Node: Query Processing,  Next: Query Handling Predicates,  Prev: Message Handling Predicates,  Up: ref-msg

4.16.3 Query Processing
-----------------------

All user input in the Prolog system is handled by a single predicate:
     `ask_query(QUERYCLASS, QUERY, HELP, ANSWER)'

   QUERYCLASS, described below, specifies the form of the query
interaction.  QUERY is an abstract message term specifying the query
text, HELP is an abstract message term used as a help message in
certain cases, and ANSWER is the (abstract) result of the query.

   `ask_query/4' is a built-in predicate, so that users can invoke it
to have their own queries processed in the same way as the system
queries.

   The processing of queries is highly customizable.  For example, this
allows changing the language of the input expected from the user, or to
make queries appear in dialog windows rather than on the terminal.

* Menu:

* Query Classes:: Query Classes
* Query Phases:: Phases of Query Processing
* Query Hooks:: Hooks in Query Processing
* Default Input Methods:: Default Input Methods
* Default Map Methods:: Default Map Methods
* Default Query Classes:: Default Query Classes


File: sicstus.info,  Node: Query Classes,  Next: Query Phases,  Up: Query Processing

4.16.3.1 Query Classes
......................

Queries posed by the system can be classified according to the kind of
input they expect, the way the input is processed, etc.  Queries of the
same kind form a _query class_.

   For example, queries requiring a yes/no answer form a query class
with the following characteristics:

   * the text ` (y or n) ' is used as the prompt;

   * a single line of text is input;

   * if the first non-whitespace character of the input is `y' or `n'
     (possibly in capitals), the query returns the atom `yes' or `no',
     respectively, as the abstract answer;

   * otherwise a help message is displayed and the query is repeated.

   There are built-in query classes for reading in yes/no answers,
toplevel queries, debugger commands, etc.

   A query class is characterized by a ground Prolog term, which is
supplied as the first argument to the query processing predicate
`ask_query/4'.  The characteristics of a query class are normally
described by the extendible predicate
     'SU_messages':query_class(QUERYCLASS, PROMPT, INPUTMETHOD,
                               MAPMETHOD, FAILUREMODE).

   The arguments of the `query_class' predicate have the following
meaning:
   * PROMPT: an atom to be used for prompting the user.

   * INPUTMETHOD: a non-variable term, which specifies how to obtain
     input from the user.

     For example, a built-in input method is described by the atom
     `line'.  This requests that a line is input from the user, and the
     code-list is returned.  Another built-in input method is
     `term(OPTIONS)'; here, a Prolog term is read and returned.

     The input obtained using INPUTMETHOD is called "raw input", as it
     may undergo further processing.

     In addition to the built-in input methods, the user can define
     his/her own extensions.

   * MAPMETHOD: a non-variable term, which specifies how to process the
     raw input to get the abstract answer to the query.

     For example, the built-in map method `char([yes-"yY", no-"nN"])'
     expects a code-list as raw input, and gives the answer term `yes'
     or `no' depending on the first non-whitespace character of the
     input.  For another example, the built-in map method `=' requests
     that the raw input itself be returned as the answer term--this is
     often used in conjunction with the input method `term(OPTIONS)'.

     In addition to the built-in map methods the user can define his/her
     own extensions.

   * FAILUREMODE

     This is used only when the mapping of raw input fails, and the
     query must be repeated.  This happens for example if the user typed
     a character other than `y' or `n' in case of the `yes_or_no' query
     class.  FAILUREMODE determines what to print before re-querying
     the user.  Possible values are:

        * `help_query': print a help message, then print the text of
          the query again

        * `help': only print the help message

        * `query': only print the text of the query

        * `none': do not print anything


File: sicstus.info,  Node: Query Phases,  Next: Query Hooks,  Prev: Query Classes,  Up: Query Processing

4.16.3.2 Phases of Query Processing
...................................

Query processing is done in several phases, described below.  We will
illustrate what is done in each phase through a simple example: the
question put to the user when the solution to the toplevel query `X is
1+1' is displayed, requesting a decision whether to find alternative
answers or not:
     | ?- X is 1+1.

     X = 2 ? no
     Please enter ";" for more choices; otherwise, <return>
      ? ;

   We focus on the query `X = 2 ? ' in the above script.

   The example query belongs to the class `next_solution', its text is
described by the message term `solutions([binding("X",2)])', and its
help text by the message term `bindings_help'.  Accordingly, such a
query is executed by calling:
     ask_query(next_solution,               /* QUERYCLASS */
               solutions([binding("X",2)]), /* QUERY */
               bindings_help,               /* HELP */
               ANSWER)

   In general, execution of `ask_query(QUERYCLASS, QUERY, HELP,
ANSWER)' consists of the following phases:

   * _Preparation phase_: The abstract message terms QUERY (for the
     text of the query) and HELP (for the help message) are converted
     to format-command lines via the message generation and line
     splitting phases (*note Message Processing::).  Let us call the
     results of the two conversions QUERYLINES and HELPLINES,
     respectively.  The text of the query, QUERYLINES is printed
     immediately (via the message printing phase, using `query'
     severity).  HELPLINES may be printed later, and QUERYLINES printed
     again, in case of invalid user input.

     The characteristics of QUERYCLASS (described in the previous
     subsubsection) are retrieved to control the exact behavior of the
     further phases.

     In our example, the following parameters are sent in the
     preparation phase:

     QUERYLINES    =   `[[],['~s = '-["X"],write_term(2)]]'
     HELPLINES     =   
       `[['Please enter ";" for more choices; otherwise, <return>'-[]]]'
     PROMPT        =   `' ? ''
     INPUTMETHOD   =   `line'
     MAPMETHOD     =   `char([yes-";", no-[0'\n]])'
     FAILUREMODE   =   `help'

     QUERYLINES is displayed immediately, printing:
          X = 2

     (Note that the first element of QUERYLINES is `[]', therefore the
     output is preceded by a newline.  Also note that no newline is
     printed at the end of the  last line, because the `query' severity
     is used.)

     The subsequent phases will be called repeatedly until the mapping
     phase succeeds in generating an answer.

   * _Input phase_: By default, the input phase is implemented by the
     extendible predicate
          'SU_messages':query_input(INPUTMETHOD, PROMPT, RAWINPUT).

     This phase uses the PROMPT and INPUTMETHOD characteristics of the
     query class.  INPUTMETHOD specifies the method of obtaining input
     from the user.  This method is executed, and the result (RAWINPUT)
     is passed on to the next phase.

     The use of PROMPT may depend on INPUTMETHOD.  For example, the
     built-in input method `line' prints the prompt unconditionally,
     while the input method `term(_)' passes PROMPT to `prompt/2'.

     In the example, first the ` ? ' prompt is displayed.  Next, because
     INPUTMETHOD is `line', a line of input is read, and the code-list
     is returned in RAWINPUT.  Supposing that the user typed `
     no<RET>', RAWINPUT becomes `" no"' = `[32,110,111]'.

   * _Mapping phase_: By default, the mapping phase is implemented by
     the extendible predicate
          'SU_messages':query_map(MAPMETHOD, RAWINPUT,
                                  RESULT, ANSWER).

     This phase uses the MAPMETHOD parameter to control the method of
     converting the raw input to the abstract answer.

     In some cases RAWINPUT is returned as it is, but otherwise it has
     to be processed (parsed) to generate the answer.

     The conversion process may have two outcomes indicated in the
     RESULT returned:
        * success, in which case the query processing is completed with
          the ANSWER term returned;

        * failure, the query has to be repeated.

     In the latter case a message describing the cause of failure may be
     returned, to be printed before the query is repeated.

     In our example, the map method is `char([yes-";", no-[0'\n]])'.
     The mapping phase fails for the RAWINPUT passed on by the previous
     phase of the example, as the first non-whitespace character is `n',
     which does not match any of the given characters.

   * _Query restart phase_: This phase is executed only if the mapping
     phase returned with failure.

     First, if a message was returned by the mapping, it is printed.
     Subsequently, if requested by the FAILUREMODE parameter, the help
     message HELPLINES and/or the text of the query QUERYLINES is
     printed.

     The query is then repeated--the input and mapping phase will be
     called again to try to get a valid answer.

     In the above example, the user typed an invalid character, so the
     mapping failed.  The `char(_)' mapping does not return any message
     in case of failure.  The FAILUREMODE of the query class is `help',
     so the help message HELPLINES is printed, but the query is not
     repeated:
          Please enter ";" for more choices; otherwise, <return>

     Having completed the query restart phase, the example script
     continues by re-entering the input phase: the prompt ` ? ' is
     printed, another line is read, and is processed by the mapping
     phase.  If the user types the character `;' this time, the mapping
     phase returns successfully and gives the abstract answer term
     `yes'.



File: sicstus.info,  Node: Query Hooks,  Next: Default Input Methods,  Prev: Query Phases,  Up: Query Processing

4.16.3.3 Hooks in Query Processing
..................................

As explained above, the major parts of query processing are implemented
in the `'SU_messages'' module in the file `library('SU_messages')'
through the following extendible predicates:
   * `'SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD,
     -MAPMETHOD, -FAILUREMODE)'

   * `'SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)'

   * `'SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)'

   This is to enable the user to change the language used, the
processing done, etc., simply by changing or replacing the
`library('SU_messages')' file.

   To give more control to the user and to make the system more robust
(for example if the `'SU_messages'' module is corrupt) the so-called
_four step procedure_ is used in the above three cases--obtaining the
query class parameters, performing the query input and performing the
mapping.  The four steps of this procedure, described below, are tried
in the given order until the first one that succeeds.  Note that if an
exception is raised within the first three steps, a warning is printed
and the step is considered to have failed.

   * First a hook predicate is tried.  The name of the hook is derived
     from the name of the appropriate predicate by appending `_hook' to
     it, e.g. `user:query_class_hook/5' in case of the query class.  If
     this hook predicate exists and succeeds, it is assumed to have
     done all necessary processing, and the following steps are skipped.

   * Second, the predicate in the `'SU_messages'' module is called
     (this is the default case, these are the predicates listed above).
     Normally this should succeed, unless the module is corrupt, or an
     unknown query-class/input-method/map-method is encountered.  These
     predicates are extendible, so new classes and methods can be added
     easily by the user.

   * Third, as a fall-back, a built-in minimal version of the
     predicates in the original `'SU_messages'' is called.  This is
     necessary because the `library('SU_messages')' file is modifiable
     by the user, therefore vital parts of the Prolog system (e.g. the
     toplevel query) could be damaged.

   * If all the above steps fail, nothing more can be done, and an
     exception is raised.


File: sicstus.info,  Node: Default Input Methods,  Next: Default Map Methods,  Prev: Query Hooks,  Up: Query Processing

4.16.3.4 Default Input Methods
..............................

The following INPUTMETHOD types are implemented by the default
`'SU_messages':query_input(INPUTMETHOD, PROMPT, RAWINPUT)' (and these
are the input methods known to the third, fall-back step):

`line'
     The PROMPT is printed, a line of input is read using `read_line/2'
     and the code-list is returned as RAWINPUT.

`term(OPTIONS)'
     PROMPT is set to be the prompt (cf. `prompt/2'), and a Prolog term
     is read by `read_term/2' using the given OPTIONS, and is returned
     as RAWINPUT.

`FINALTERM^term(TERM,OPTIONS)'
     A Prolog term is read as above, and is unified with TERM.
     FINALTERM is returned as RAWINPUT.  For example, the
     `T-Vs^term(T,[variable_names(Vs)])' input method will return the
     term read, paired with the list of variable names.


File: sicstus.info,  Node: Default Map Methods,  Next: Default Query Classes,  Prev: Default Input Methods,  Up: Query Processing

4.16.3.5 Default Map Methods
............................

The following MAPMETHOD types are known to
`'SU_messages':query_map(MAPMETHOD, RAWINPUT, RESULT, ANSWER)' and to
the built-in fall-back mapping:

`char(PAIRS)'
     In this map method RAWINPUT is assumed to be a code-list.

     PAIRS is a list of `NAME-ABBREVIATIONS' pairs, where NAME is a
     ground term, and ABBREVIATIONS is a code-list.  The first
     non-layout character of RAWINPUT is used for finding the
     corresponding name as the answer, by looking it up in the
     abbreviation lists.  If the character is found, RESULT is
     `success', and ANSWER is set to the NAME found; otherwise, RESULT
     is `failure'.

`='
     No conversion is done, ANSWER is equal to RAWINPUT and RESULT is
     `success'.

`debugger'
     This map method is used when reading a single line debugger
     command.  It parses the debugger command and returns the
     corresponding abstract command term.  If the parse is
     unsuccessful, the answer `unknown(Line,Warning)' is returned.
     This is to allow the user to extend the debugger command language
     via `debugger_command_hook/2', see *Note Debug Commands::.

     The details of this mapping can be obtained from the
     `library('SU_messages')' file.

     Note that the fall-back version of this mapping is simplified, it
     only accepts parameterless debugger commands.


File: sicstus.info,  Node: Default Query Classes,  Prev: Default Map Methods,  Up: Query Processing

4.16.3.6 Default Query Classes
..............................

Most of the default query classes are designed to support some specific
interaction with the user within the Prolog development environment.
The full list of query classes can be inspected in the file
`library('SU_messages')'.  Here, we only describe the two classes
defined by `'SU_messages':query_class/5' that may be of general use:

QUERYCLASS    `yes_or_no'          `yes_no_proceed'
PROMPT        `' (y or n) ''       `' (y, n, p, s, a, or ?) ''
INPUTMETHOD   `line'               `line'
MAPMETHOD     `char([yes-"yY",     `char([yes-"yY", no-"nN", proceed-"pP",
              no-"nN"])'           suppress-"sS", abort-"aA"])'
FAILUREMODE   `help_query'         `help_query'


File: sicstus.info,  Node: Query Handling Predicates,  Next: Message Summary,  Prev: Query Processing,  Up: ref-msg

4.16.4 Query Handling Predicates
--------------------------------

`ask_query(+QUERYCLASS, +QUERY, +HELP, -ANSWER)  "hookable"'
     Prints the question QUERY, then reads and processes user input
     according to QUERYCLASS, and returns the result of the processing,
     the abstract answer term ANSWER.  The HELP message is printed in
     case of invalid input.

`query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)  "hook"'
`user:query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)'
     Called by `ask_query/4' before processing the query.  If this
     predicate succeeds, it is assumed that the query has been
     processed and nothing further is done.

`query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)  "hook"'
`user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_class/5' in the preparation phase of query
     processing.  This way the default query class characteristics can
     be changed.

`'SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)  "extendible"'
     Predefined query class characteristics table.

`'SU_messages':query_abbreviation(+QUERYCLASS, -PROMPT, -PAIRS)  "extendible"'
     Predefined query abbreviation table.

`query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)  "hook"'
`user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_input/3' in the input phase of query
     processing.  This way the implementation of the default input
     methods can be changed.

`'SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)  "extendible"'
     Predefined query input methods.

`query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)  "hook"'
`user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_map/4' in the mapping phase of query
     processing.  This way the implementation of the default map methods
     can be changed.

`'SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)  "extendible"'
     Predefined query map methods.


File: sicstus.info,  Node: Message Summary,  Prev: Query Handling Predicates,  Up: ref-msg

4.16.5 Predicate Summary
------------------------

`ask_query(+QUERYCLASS, +QUERY, +HELP, -ANSWER)  "hookable"'
     Prints the question QUERY, then reads and processes user input
     according to QUERYCLASS, and returns the result of the processing,
     the abstract answer term ANSWER.  The HELP message is printed in
     case of invalid input.

`user:message_hook(+M,+S,+L)  "hook"'
     intercept the printing of a message

`'SU_messages':generate_message(+M,?SO,?S)  "extendible"'
     determines the mapping from a message term into a sequence of
     lines of text to be printed

`user:generate_message_hook(+M,?S0,?S)  "hook"'
     intercept message before it is given to
     `'SU_messages':generate_message/3'

`goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.

`user:portray_message(+SEVERITY,+MESSAGE)  "hook"'
     Tells `print_message/2' what to do.

`print_message(+S,+M)  "hookable"'
     print a message M of severity S

`print_message_lines(+S,+P,+L)'
     print the message lines L to stream S with prefix P

`'SU_messages':query_abbreviation(+T,-P)  "extendible"'
     specifies one letter abbreviations for responses to queries from
     the Prolog system

`user:query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)  "hook"'
     Called by `ask_query/4' before processing the query.  If this
     predicate succeeds, it is assumed that the query has been
     processed and nothing further is done.

`'SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)  "extendible"'
     Access the parameters of a given QUERYCLASS.

`user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)  "hook"'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_class/5' in the preparation phase of query
     processing.  This way the default query class characteristics can
     be changed.

`'SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)  "extendible"'
     Implements the input phase of query processing.

`user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)  "hook"'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_input/3' in the input phase of query
     processing.  This way the implementation of the default input
     methods can be changed.

`'SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)  "extendible"'
     Implements the mapping phase of query processing.

`user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)  "hook"'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_map/4' in the mapping phase of query
     processing.  This way the implementation of the default map methods
     can be changed.



File: sicstus.info,  Node: Debug Intro,  Next: Mixing C and Prolog,  Prev: Prolog Intro,  Up: Top

5 Debugging
***********

This chapter describes the debugging facilities that are available in
development systems.  The purpose of these facilities is to provide
information concerning the control flow of your program.

   The main features of the debugging package are as follows:

   * The "Procedure Box" model of Prolog execution, which provides a
     simple way of visualizing control flow, especially during
     backtracking.  Control flow is viewed at the predicate level,
     rather than at the level of individual clauses.

   * The ability to exhaustively trace your program or to selectively
     set "spypoints".  Spypoints allow you to nominate interesting
     predicates at which, for example, the program is to pause so that
     you can interact.

   * The ability to set advice-points. An advice-point allows you to
     carry out some actions at certain points of execution,
     independently of the tracing activity. Advice-points can be used,
     e.g. for checking certain program invariants (cf. the assert
     facility of the C programming language), or for gathering
     profiling or branch coverage information.  Spypoints and
     advice-points are collectively called breakpoints.

   * The wide choice of control and information options available during
     debugging.

   The Procedure Box model of execution is also called the Byrd Box
model after its inventor, Lawrence Byrd.

   Much of the information in this chapter is also in Chapter eight of
[Clocksin & Mellish 81], which is recommended as an introduction.

   Unless otherwise stated, the debugger prints goals using
`write_term/3' with the value of the Prolog flag
`debugger_print_options'.  

   The debugger is not available in runtime systems and the predicates
defined in this chapter are undefined; *note Runtime Systems::.

* Menu:

* Procedure Box:: The Procedure Box Control Flow Model
* Basic Debug:: Basic Debugging Predicates
* Plain Spypoint:: Plain Spypoints
* Debug Format:: Format of Debugging Messages
* Debug Commands:: Commands Available during Debugging
* Advanced Debugging:: Advanced Debugging --- an Introduction
* Breakpoint Predicates:: Breakpoint Handling Predicates
* Breakpoint Processing:: The Processing of Breakpoints
* Breakpoint Conditions:: Breakpoint Conditions
* Consult:: Consulting during Debugging
* Exceptions Debug:: Catching Exceptions
* Debug Summary:: Predicate Summary


File: sicstus.info,  Node: Procedure Box,  Next: Basic Debug,  Up: Debug Intro

5.1 The Procedure Box Control Flow Model
========================================

During debugging, the debugger prints out a sequence of goals in
various states of instantiation in order to show the state the program
has reached in its execution.  However, in order to understand what is
occurring it is necessary to understand when and why the debugger
prints out goals.  As in other programming languages, key points of
interest are predicate entry and return, but in Prolog there is the
additional complexity of backtracking.  One of the major confusions
that novice Prolog programmers have to face is the question of what
actually happens when a goal fails and the system suddenly starts
backtracking.  The Procedure Box model of Prolog execution views
program control flow in terms of movement about the program text.  This
model provides a basis for the debugging mechanism in development
systems, and enables the user to view the behavior of the program in a
consistent way.

   Let us look at an example Prolog predicate :

                *--------------------------------------*
        Call    |                                      |    Exit
     ---------> +  descendant(X,Y) :- offspring(X,Y).  + --------->
                |                                      |
                |  descendant(X,Z) :-                  |
     <--------- +     offspring(X,Y), descendant(Y,Z). + <---------
        Fail    |                                      |    Redo
                *-------------------+------------------*
                                    |
     <------------------------------+
        Exception

The first clause states that Y is a descendant of X if Y is an
offspring of X, and the second clause states that Z is a descendant of
X if Y is an offspring of X and if Z is a descendant of Y.  In the
diagram a box has been drawn around the whole predicate and labeled
arrows indicate the control flow in and out of this box.  There are
five such arrows, which we shall look at in turn.

CALL
     This arrow represents initial invocation of the predicate.  When a
     goal of the form `descendant(X,Y)' is required to be satisfied,
     control passes through the CALL port of the descendant box with
     the intention of matching a component clause and then satisfying
     the subgoals in the body of that clause.  Note that this is
     independent of whether such a match is possible; i.e. first the
     box is called, and then the attempt to match takes place.
     Textually we can imagine moving to the code for descendant when
     meeting a call to descendant in some other part of the code.

EXIT
     This arrow represents a successful return from the predicate.
     This occurs when the initial goal has been unified with one of the
     component clauses and the subgoals have been satisfied.  Control
     now passes out of the EXIT port of the descendant box.  Textually
     we stop following the code for descendant and go back to the place
     we came from.

REDO
     This arrow indicates that a subsequent goal has failed and that
     the system is backtracking in an attempt to find alternatives to
     previous solutions.  Control passes through the REDO port of the
     descendant box.  An attempt will now be made to resatisfy one of
     the component subgoals in the body of the clause that last
     succeeded; or, if that fails, to completely rematch the original
     goal with an alternative clause and then try to satisfy any
     subgoals in the body of this new clause.  Textually we follow the
     code backwards up the way we came looking for new ways of
     succeeding, possibly dropping down on to another clause and
     following that if necessary.

FAIL
     This arrow represents a failure of the initial goal, which might
     occur if no clause is matched, or if subgoals are never satisfied,
     or if any solution produced is always rejected by later processing.
     Control now passes out of the FAIL port of the descendant box and
     the system continues to backtrack.  Textually we move back to the
     code that called this predicate and keep moving backwards up the
     code looking for choicepoints.

EXCEPTION
     This arrow represents an exception that was raised in the initial
     goal, either by a call to `throw/1' or `raise_exception/1' or by
     an error in a built-in predicate.  *Note ref-ere::.  Control now
     passes out of the EXCEPTION port of the descendant box and the
     system continues to pass the exception to outer levels.  Textually
     we move back to the code that called this predicate and keep
     moving backwards up the code looking for a call to `catch/3' or
     `on_exception/3'.

   In terms of this model, the information we get about the procedure
box is only the control flow through these five ports.  This means that
at this level we are not concerned with identifying the matching clause,
and how any subgoals are satisfied, but rather we only wish to know the
initial goal and the final outcome.  However, it can be seen that
whenever we are trying to satisfy subgoals, what we are actually doing
is passing through the ports of _their_ respective boxes.  If we were
to follow this, we would have complete information about the control
flow inside the procedure box.

   Note that the box we have drawn round the predicate should really be
seen as an "invocation box".  That is, there will be a different box
for each different invocation of the predicate.  Obviously, with
something like a recursive predicate, there will be many different
CALLS and EXITS in the control flow, but these will be for different
invocations.  Since this might get confusing each invocation box is
given a unique integer identifier.

   In addition to the five basic ports discussed above, there are two
more ports for invocations involving a blocked goal:

BLOCK
     This port is passed through when a goal is blocked.

UNBLOCK
     This port is passed through when a previously blocked goal is
     unblocked.


File: sicstus.info,  Node: Basic Debug,  Next: Plain Spypoint,  Prev: Procedure Box,  Up: Debug Intro

5.2 Basic Debugging Predicates
==============================

Development systems provide a range of built-in predicates for control
of the debugging facilities.  The most basic predicates are as follows:

`debug  "development"'
     Switches the debugger on, and ensures that the next time control
     reaches a spypoint, it will be activated. In basic usage this
     means that a message will be produced and you will be prompted for
     a command.  In order for the full range of control flow
     information to be available it is necessary to have the debugger
     on from the start.  When it is off the system does not remember
     invocations that are being executed.  (This is because it is
     expensive and not required for normal running of programs.)  You
     can switch DEBUG MODE on in the middle of execution, either from
     within your program or after a `^C' (see `trace/0' below), but
     information prior to this will be unavailable.

`zip  "development"'
     Same as `debug/0', except no debugging information is being
     collected, and so is almost as fast as running with the debugger
     switched off.

`trace  "development"'
     Switches the debugger on, and ensures that the next time control
     enters an invocation box, a message will be produced and you will
     be prompted for a command.  The effect of `trace/0' can also be
     achieved by typing `t' after a `^C' interruption of a program.

     At this point you have a number of options.  *Note Debug
     Commands::.  In particular, you can just type <RET> to creep (or
     single-step) into your program.  If you continue to creep through
     your program you will see every entry and exit to/from every
     invocation box, including compiled code, except for code belonging
     to hidden modules (*note ref-mod::).  You will notice that the
     debugger stops at all ports.  However, if this is not what you
     want, the next predicate gives full control over the ports at
     which you are prompted.

`leash(+MODE)  "development"'
     Leashing Mode is set to MODE.  Leashing Mode determines the ports
     of invocation boxes at which you are to be prompted when you creep
     through your program.  At unleashed ports a tracing message is
     still output, but program execution does not stop to allow user
     interaction.  Note that `leash/1' does not apply to spypoints, the
     leashing mode of these can be set using the advanced debugger
     features; *note Advanced Debugging::.  Block and Unblock ports
     cannot be leashed.  MODE can be a subset of the following,
     specified as a list of the following:

    `call'
          Prompt on Call.

    `exit'
          Prompt on Exit.

    `redo'
          Prompt on Redo.

    `fail'
          Prompt on Fail.

    `exception'
          Prompt on Exception.

     The following shorthands are also allowed:

    `leash(full).'
          Same as `leash([call,exit,redo,fail,exception]).'.

    `leash(half).'
          Same as `leash([call,redo]).'.

    `leash(none).'
          Same as `leash([]).'.

     The initial value of LEASHING MODE is
     `[call,exit,redo,fail,exception]' (full leashing).

`nodebug  "development"'
`notrace  "development"'
`nozip  "development"'
     Switches the debugger off.  Any spypoints set will be kept but
     will never be activated.

`debugging  "development"'
     Prints information about the current debugging state.  This will
     show:

       1. Whether undefined predicates are being trapped.

       2. What breakpoints have been set (see below).

       3. What mode of leashing is in force (see above).


File: sicstus.info,  Node: Plain Spypoint,  Next: Debug Format,  Prev: Basic Debug,  Up: Debug Intro

5.3 Plain Spypoints
===================

For programs of any size, it is clearly impractical to creep through
the entire program.  Spypoints make it possible to stop the program
whenever it gets to a particular predicate of interest.  Once there,
one can set further spypoints in order to catch the control flow a bit
further on, or one can start creeping.

   In this section we discuss the simplest form of spypoints, the
"plain spypoints". The more advanced forms, the "conditional" and
"generic spypoints" will be discussed later; *note Advanced Debugging::.

   Setting a plain spypoint on a predicate indicates that you wish to
see all control flow through the various ports of its invocation boxes,
except during skips.  When control passes through any port of an
invocation box with a spypoint set on it, a message is output and the
user is asked to interact.  Note that the current mode of leashing does
not affect plain spypoints: user interaction is requested on _every_
port.

   Spypoints are set and removed by the following built-in predicates.
The first two are also standard operators:

`spy :SPEC  "development"'
     Sets plain spypoints on all the predicates given by the
     generalized predicate spec SPEC.

     Examples:

          | ?- spy [user:p, m:q/[2,3]].
          | ?- spy m:[p/1, q/1].

     If you set some spypoints when the debugger is switched off, it
     will be automatically switched on, entering zip mode.

`nospy :SPEC  "development"'
     Similar to `spy SPEC' except that all the predicates given by SPEC
     will have all previously set spypoints removed from them
     (including conditional spypoints; *note Creating Breakpoints::).

`nospyall  "development"'
     Removes all the spypoints that have been set, including the
     conditional and generic ones.

The commands available when you arrive at a spypoint are described
later.  *Note Debug Commands::.


File: sicstus.info,  Node: Debug Format,  Next: Debug Commands,  Prev: Plain Spypoint,  Up: Debug Intro

5.4 Format of Debugging Messages
================================

We shall now look at the exact format of the message output by the
system at a port.  All trace messages are output to the standard error
stream, using the `print_message/2' predicate; *note ref-msg::.  This
allows you to trace programs while they are performing file I/O.  The
basic format is as follows:

     N S    23     6 Call: T foo(hello,there,_123) ?

   N is only used at Exit ports and indicates whether the invocation
could backtrack and find alternative solutions.  Unintended
nondeterminacy is a source of inefficiency, and this annotation can
help spot such efficiency bugs.  It is printed as `?', indicating that
`foo/3' could backtrack and find alternative solutions, or ` '
otherwise.

   S is a spypoint indicator.  If there is a plain spypoint on `foo/3',
it is printed as `+'. In case of conditional and generic spypoints it
takes the form `*' and `#', respectively. Finally, it is printed as `
', if there is no spypoint on the predicate being traced.

   The first number is the unique invocation identifier.  It is
increasing regardless of whether or not debugging messages are output
for the invocations (provided that the debugger is switched on).  This
number can be used to cross correlate the trace messages for the various
ports, since it is unique for every invocation.  It will also give an
indication of the number of procedure calls made since the start of the
execution.  The invocation counter starts again for every fresh
execution of a command, and it is also reset when retries (see later)
are performed.

   The number following this is the "current depth"; i.e. the number of
direct ancestors this goal has, for which a procedure box has been
built by the debugger.

   The next word specifies the particular port (Call, Exit, Redo, Fail,
or Exception).

   T is a subterm trace.  This is used in conjunction with the `^'
command (set subterm), described below.  If a subterm has been
selected, T is printed as the sequence of commands used to select the
subterm.  Normally, however, T is printed as ` ', indicating that no
subterm has been selected.

   The goal is then printed so that you can inspect its current
instantiation state.

   The final `?' is the prompt indicating that you should type in one
of the commands allowed (*note Debug Commands::).  If this particular
port is unleashed, you will not get this prompt since you have
specified that you do not wish to interact at this point.

   At Exception ports, the trace message is preceded by a message about
the pending exception, formatted as if it would arrive uncaught at the
top level.

   Note that calls that are compiled in-line are not traced.

   Block and Unblock ports are exceptions to the above debugger message
format.  A message

            S -  -  Block: p(_133)

indicates that the debugger has encountered a blocked goal, i.e. one
which is temporarily suspended due to insufficiently instantiated
arguments (*note ref-sem-sec::).  By default, no interaction takes
place at this point, and the debugger simply proceeds to the next goal
in the execution stream.  The suspended goal will be eligible for
execution once the blocking condition ceases to exist, at which time a
message

            S -  -  Unblock: p(_133)

is printed. Although Block and Unblock ports are unleashed by default
in trace mode, you can make the debugger interact at these ports by
using conditional spypoints.


File: sicstus.info,  Node: Debug Commands,  Next: Advanced Debugging,  Prev: Debug Format,  Up: Debug Intro

5.5 Commands Available during Debugging
=======================================

This section describes the particular commands that are available when
the system prompts you after printing out a debugging message.  All the
commands are one or two letter mnemonics, among which some can be
optionally followed by an argument.  They are read from the standard
input stream with any blanks being completely ignored up to the end of
the line (<RET>).

   The only command that you really have to remember is `h' (followed
by <RET>).  This provides help in the form of the following list of
available commands.

        <cr>   creep            c      creep
         l     leap             z      zip
         s     skip             s <i>  skip i
         o     out              o <n>  out n
         q     q-skip           q <i>  q-skip i
         r     retry            r <i>  retry i
         f     fail             f <i>  fail i
         j<p>  jump to port     j<p><i>jump to port i
         d     display          w      write
         p     print            p <i>  print partial
         g     ancestors        g <n>  ancestors n
         t     backtrace        t <n>  backtrace n
         &     blocked goals    & <n>  nth blocked goal
         n     nodebug          =      debugging
         +     spy this         *      spy conditionally
         -     nospy this       \ <i>  remove brkpoint
         D <i> disable brkpoint E <i>  enable brkpoint
         a     abort            b      break
         @     command          u      unify
         e     raise exception  .      find this
         <     reset printdepth < <n>  set printdepth
         ^     reset subterm    ^ <n>  set subterm
         ?     help             h      help

`c'
`<RET>'
     "creep" causes the debugger to single-step to the very next port
     and print a message.  Then if the port is leashed (*note Basic
     Debug::), the user is prompted for further interaction.
     Otherwise, it continues creeping.  If leashing is off, creep is
     the same as "leap" (see below) except that a complete trace is
     printed on the standard error stream.  

`l'
     "leap" causes the debugger to resume running your program, only
     stopping when a spypoint is reached (or when the program
     terminates).  Leaping can thus be used to follow the execution at
     a higher level than exhaustive tracing.  All you need to do is to
     set spypoints on an evenly spread set of pertinent predicates, and
     then follow the control flow through these by leaping from one to
     the other.  Debugging information is collected while leaping, so
     when a spypoint is reached, it is possible to inspect the ancestor
     goals, or creep into them upon entry to Redo ports.  

`z'
     "zip" is like "leap", except no debugging information is being
     collected while zipping, resulting in significant savings in
     memory and execution time.  

`s'
     "skip" is only valid for Call and Redo ports.  It skips over the
     entire execution of the predicate.  That is, you will not see
     anything until control comes back to this predicate (at either the
     Exit port or the Fail port).  Skip is particularly useful while
     creeping since it guarantees that control will be returned after
     the (possibly complex) execution within the box.  If you skip, no
     message at all will appear until control returns.  This includes
     calls to predicates with spypoints set; they will be masked out
     during the skip.  No debugging information is being collected while
     skipping.

     If you supply an integer argument, this should denote an
     invocation number of an ancestral goal.  The system tries to get
     you to the Exit or Fail port of the invocation box you have
     specified.  

`o'
     "out" is a shorthand for skipping to the Exit or Fail port of the
     immediate ancestor goal.  If you supply an integer argument N, it
     denotes skipping to the Exit or Fail port of the Nth ancestor goal.  

`q'
     "quasi-skip" is like a combination of "zip" and "skip": execution
     stops when either control comes back to this predicate, or a
     spypoint is reached.  No debugging information is being collected
     while quasi-skipping.

     An integer argument can be supplied as for "skip".  

`r'
     "retry" can be used at any port (although at the Call port it has
     no effect).  It transfers control back to the Call port of the
     box.  This allows you to restart an invocation when, for example,
     you find yourself leaving with some weird result.  The state of
     execution is exactly the same as when you originally called,
     (unless you use side-effects in your program; i.e. asserts etc.
     will not be undone).  When a retry is performed the invocation
     counter is reset so that counting will continue from the current
     invocation number regardless of what happened before the retry.
     This is in accord with the fact that you have, in executional
     terms, returned to the state before anything else was called.

     If you supply an integer argument, this should denote an
     invocation number of an ancestral goal.  The system tries to get
     you to the Call port of the box you have specified.  It does this
     by continuously failing until it reaches the right place.
     Unfortunately this process cannot be guaranteed: it may be the
     case that the invocation you are looking for has been cut out of
     the search space by cuts (`!') in your program.  In this case the
     system fails to the latest surviving Call port before the correct
     one.  

`f'
     "fail" can be used at any of the four ports (although at the Fail
     port it has no effect).  It transfers control to the Fail port of
     the box, forcing the invocation to fail prematurely.

     If you supply an integer after the command, this is taken as
     specifying an invocation number and the system tries to get you to
     the Fail port of the invocation box you have specified.  It does
     this by continuously failing until it reaches the right place.
     Unfortunately this process cannot be guaranteed: it may be the
     case that the invocation you are looking for has been cut out of
     the search space by cuts (`!') in your program.  In this case the
     system fails to the latest surviving Fail port before the correct
     one.  

`j<p>'
     "jump to port" transfers control back to the prescribed port <P>.
     Here, <P> is one of: `c', `e', `r', `f', standing for Call, Exit,
     Redo and Fail ports. Takes an optional integer argument, an
     invocation number.

     Jumping to a Call port is the same as retrying it, i.e.  `jc' is
     the same as the `r' debugger command; and similarly `jf' is the
     same as `f'.

     The `je' "jump to Exit port" command transfers control back to the
     Exit port of the box. It can be used at a Redo or an Exit port
     (although at the latter it has no effect). This allows you to
     restart a computation following an Exit port, which you first
     leapt over, but because of its unexpected failure you arrived at
     the Redo port. If you supply an integer argument, this should
     denote an _exact_ invocation number of an exited invocation
     present in the backtrace, and then the system will get you to the
     specified Exit port. The debugger requires here an exact
     invocation number so that it does not jump too far back in the
     execution (if an Exit port is not present in the backtrace, it may
     be be a better choice to jump to the preceding Call port, rather
     than to continue looking for another Exit port).

     The `jr' "jump to Redo port" command transfers control back to the
     Redo port of the box. It can be used at an Exit or a Redo port
     (although at the latter it has no effect). This allows you to
     force the goal in question to try to deliver another solution. If
     you supply an integer argument, this should denote an _exact_
     invocation number of an exited invocation present in the
     backtrace, and then the system will get you to the specified Redo
     port.  

`d'
     "display goal" displays the current goal using `display/1'.  See
     Write (below).  

`p'
     "print goal" displays the current goal using `print/1'.  An
     argument will override the default printdepth, treating 0 as
     infinity.  

`w'
     "write goal" displays the current goal using `writeq/1'.  

`g'
     "print ancestor goals" provides you with a list of ancestors to
     the current goal, i.e. all goals that are hierarchically above the
     current goal in the calling sequence.  You can always be sure of
     jumping to the Call or Fail port of any goal in the ancestor list
     (by using retry etc).  If you supply an integer N, only that
     number of ancestors will be printed.  That is to say, the last N
     ancestors will be printed counting back from the current goal.
     Each entry is displayed just as they would be in a trace message.  

`t'
     "print backtrace" is the same as the above, but also shows any
     goals that have exited nondeterminately and their ancestors.  This
     information shows where there are outstanding choices that the
     program could backtrack to.  If you supply an integer N, only that
     number of goals will be printed.

     Ancestors to the current goal are annotated with the `Call:' port,
     as they have not yet exited, whereas goals that have exited are
     annotated with the `Exit:' port.  You can always be sure of
     jumping to the Exit or Redo port of any goal shown to be exited in
     the backtrace listing.

     The backtrace is a tree rather than a stack: to find the parent of
     a given goal with depth indicator D, look for the closest goal
     above it with depth indicator D-1.  

`&'
     "print blocked goals" prints a list of the goals that are
     currently blocked in the current debugging session together with
     the variable that each such goal is blocked on (*note
     ref-sem-sec::).  The goals are enumerated from 1 and up.  If you
     supply an integer N, only that goal will be printed.  Each entry
     is preceded by the goal number followed by the variable name.  

`n'
     "nodebug" switches the debugger off.  Note that this is the
     correct way to switch debugging off at a trace point.  You cannot
     use the `@' or `b' commands because they always return to the
     debugger.  

`='
     "debugging" outputs information concerning the status of the
     debugging package.  See the built-in predicate `debugging/0'.  

`+'
     "spy this" sets a plain spypoint on the current goal.  

`*'
     "spy this conditionally" sets a conditional spypoint on the
     current goal. Prompts for the CONDITIONS, and calls the
          spy(FUNC, CONDITIONS)
     goal, where FUNC is the predicate spec of the current
     invocation. For `spy/2', *note Breakpoint Predicates::.  

`-'
     "nospy this" removes all spypoints applicable to the current goal.
     Equivalent to `nospy FUNC', where FUNC is the predicate spec of
     the current invocation.  

`\'
     "remove this" removes the spypoint that caused the debugger to
     interact at the current port. With an argument N, it removes the
     breakpoint with identifier N.  Equivalent to
     `remove_breakpoints(BID)', where BID is the current breakpoint
     identifier, or the supplied argument (*note Breakpoint
     Predicates::).  

`D'
     "disable this" disables the spypoint that caused the debugger to
     interact at the current port. With an argument N, it disables the
     breakpoint with identifier N.  Equivalent to
     `disable_breakpoints(BID)', where BID is the current breakpoint
     identifier, or the supplied argument (*note Breakpoint
     Predicates::).  

`E'
     "enable this" enables all specific spypoints for the predicate at
     the current port. With an argument N, it enables the breakpoint
     with identifier N. Equivalent to `enable_breakpoints(BID)', where
     BID is the breakpoint identifiers for the current predicate, or
     the supplied argument (*note Breakpoint Predicates::).  

`.'
     "find this" outputs information about where the predicate being
     called is defined.  

`a'
     "abort" causes an abort of the current execution.  All the
     execution states built so far are destroyed and you are put right
     back at the top-level.  (This is the same as the built-in predicate
     `abort/0'.)  

`b'
     "break" calls the built-in predicate `break/0', thus putting you
     at a recursive top-level with the execution so far sitting
     underneath you.  When you end the break (`^D') you will be
     reprompted at the port at which you broke.  The new execution is
     completely separate from the suspended one; the invocation numbers
     will start again from 1 during the break.  The debugger is
     temporarily switched off as you call the break and will be
     re-switched on when you finish the break and go back to the old
     execution.  However, any changes to the leashing or to spypoints
     will remain in effect.  

`@'
     "command" gives you the ability to call arbitrary Prolog goals.
     It is effectively a one-off "break" (see above).  The initial
     message `| :- ' will be output on the standard error stream, and a
     command is then read from the standard input stream and executed
     as if you were at top-level.  If the term read is of form `PATTERN
     ^ BODY', PATTERN is unified with the current goal and BODY is
     executed.  

`u'
     "unify" is available at the Call port and gives you the option of
     providing a solution to the goal from the standard input stream
     rather than executing the goal.  This is convenient e.g. for
     providing a "stub" for a predicate that has not yet been written.
     A prompt will be output on the standard error stream, and the
     solution is then read from the standard input stream and unified
     with the goal.  If the term read in is of the form `HEAD :- BODY',
     HEAD will be unified with the current goal, and BODY will be
     executed in its place.  

`e'
     "raise exception" is available at all ports.  A prompt will be
     output on the standard error stream, and an exception term is then
     read from the standard input stream and raised in the program
     being debugged.  

`<'
     This command, without arguments, resets the printdepth to 10.
     With an argument of N, the printdepth is set to N, treating 0 as
     infinity.  This command works by changing the value of the
     `debugger_print_options' Prolog flag.  

`^'
     While at a particular port, a current "subterm" of the current
     goal is maintained.  It is the current subterm that is displayed,
     printed, or written when prompting for a debugger command.  Used
     in combination with the printdepth, this provides a means for
     navigating in the current goal for focusing on the part of
     interest.  The current subterm is set to the current goal when
     arriving at a new port.  This command, without arguments, resets
     the current subterm to the current goal.  With an argument of N (>
     0), the current subterm is replaced by its N:th subterm.  With an
     argument of 0, the current subterm is replaced by its parent term.
     With a list of arguments, the arguments are applied from left to
     right.  

`?'
`h'
     "help" displays the table of commands given above.  

   The user can define new debugger commands or modify the behavior of
the above ones using the `user:debugger_command_hook/2' hook predicate,
*note Breakpoint Predicates::.


File: sicstus.info,  Node: Advanced Debugging,  Next: Breakpoint Predicates,  Prev: Debug Commands,  Up: Debug Intro

5.6 Advanced Debugging -- an Introduction
=========================================

This section gives an overview of the advanced debugger features. These
center around the notion of breakpoint. Breakpoints can be classified
as either spypoints (a generalization of the plain spypoint introduced
earlier) or advice-points (e.g. for checking program invariants
independently from tracing). The first five subsections will deal with
spypoints only. Nevertheless we will use the term breakpoint, whenever
a statement is made that applies to both spypoints and advice-points.

   *Note Breakpoint Processing:: describes the breakpoint processing
mechanism in full detail.  Reference style details of built-in
predicates dealing with breakpoints are given in *Note Breakpoint
Predicates:: and in *Note Breakpoint Conditions::.

* Menu:

* Creating Breakpoints:: Creating Breakpoints
* Processing Breakpoints:: Processing Breakpoints
* Breakpoint Tests:: Breakpoint Tests
* Specific and Generic Breakpoints:: Specific and Generic Breakpoints
* Breakpoint Actions:: Breakpoint Actions
* Advice-points:: Advice-points
* Built-in Predicates for Breakpoint Handling:: Built-in Predicates for Breakpoint Handling
* Accessing Past Debugger States:: Accessing Past Debugger States
* Storing User Information  in the Backtrace:: Storing User Information  in the Backtrace
* Hooks Related to Breakpoints:: Hooks Related to Breakpoints
* Programming Breakpoints:: Programming Breakpoints


File: sicstus.info,  Node: Creating Breakpoints,  Next: Processing Breakpoints,  Up: Advanced Debugging

5.6.1 Creating Breakpoints
--------------------------

Breakpoints can be created using the `add_breakpoint/2' built-in
predicate.  Its first argument should contain the description of the
breakpoint, the so called "breakpoint spec". It will return the
"breakpoint identifier" (BID) of the created breakpoint in its second
argument. For example:

     | ?- add_breakpoint(pred(foo/2), BID).
     % Plain spypoint for user:foo/2 added, BID=1
     BID = 1

   Here, we have a simple breakpoint spec, prescribing that the
debugger should stop at all ports of all invocations of the predicate
`foo/2'. Thus the above goal actually creates a _plain spypoint_,
exactly as `?- spy foo/2.' does.

   A slightly more complicated example follows:

     | ?- add_breakpoint([pred(foo/2),line('/myhome/bar.pl',123)], _).
     % Conditional spypoint for user:foo/2 added, BID=1

   This breakpoint will be activated only for those calls of `foo/2'
that occur in line 123 of the Prolog program file `'/myhome/bar.pl''.
Because of the additional condition, this is called a _conditional
spypoint_.

   The breakpoint identifier (BID) returned by `add_breakpoint/2' is an
integer, assigned in increasing order, i.e. more recent breakpoints
receive higher identifier values. When looking for applicable
breakpoints, the debugger tries the breakpoints in descending order of
BIDs, i.e. the most recent applicable breakpoint is used. Breakpoint
identifiers can be used for referring to breakpoints to be deleted,
disabled or enabled (see later).

   Generally, the breakpoint spec is a pair `TESTS-ACTIONS'. Here, the
TESTS part describes the conditions under which the breakpoint should
be activated, while the ACTIONS part contains instructions on what
should be done at activation. The test part is built from tests, while
the action part from actions and tests. Test, actions and composite
constructs built from these are generally referred to as "breakpoint
conditions", or simply conditions.

   The action part can be omitted, and then the breakpoint spec
consists of tests only. For spypoints, the default action part is
`[show(print),command(ask)]'. This instructs the debugger to print the
goal in question and then ask the user what to do next, exactly as
described in *Note Debug Format::.  To illustrate other possibilities
let us explain the effect of the `[show(display),command(proceed)]'
action part: this will use `display/1' for presenting the goal (just as
the `d' debugger command does, *note Debug Commands::), and will then
proceed with execution without stopping (i.e. the spypoint is
unleashed).


File: sicstus.info,  Node: Processing Breakpoints,  Next: Breakpoint Tests,  Prev: Creating Breakpoints,  Up: Advanced Debugging

5.6.2 Processing Breakpoints
----------------------------

We first give a somewhat simplified sketch of how the debugger treats
the breakpoints. This description will be refined in the sequel.

   The debugger allows us to prescribe some activities to be performed
at certain points of execution, namely at the ports of procedure boxes.
In principle, the debugger is entered at each port of each procedure
invocation. It then considers the current breakpoints one by one, most
recent first. The first breakpoint for which the evaluation of the test
part succeeds is then activated, and the execution continues according
to its action part. The activated breakpoint "hides" the remaining
(older) ones, i.e. those are not tried here. If none of the current
breakpoints is activated, the debugger behaves according to the actual
debugging mode (trace, debug or zip).

   Both the test and the action part can be simple or composite.
Evaluating a simple test amounts to checking whether it holds in the
current state of execution, e.g. `pred(foo/2)' holds if the debugger is
at a port of predicate `foo/2'.

   Composite conditions can be built from simple ones by forming lists,
or using the `,', `;', `->', and `\+' operators, with the usual meaning
of conjunction, disjunction, if-then-else and negation. A list of
conditions is equivalent to a conjunction of the same conditions. For
example, the condition `[pred(foo/2), \+port(fail)]' will hold for all
ports of `foo/2', except for the Fail port.


File: sicstus.info,  Node: Breakpoint Tests,  Next: Specific and Generic Breakpoints,  Prev: Processing Breakpoints,  Up: Advanced Debugging

5.6.3 Breakpoint Tests
----------------------

This section gives a tour of the most important simple breakpoint
tests. In all examples here the action part will be empty. Note that the
examples are independent, so if you want to try out these you should get
rid of the old breakpoints (e.g. using `?- nospyall.') before you enter
a new one.

   The `goal(...)' test is a generalization of the `pred(...)' test, as
it allows us to check the arguments of the invocation. For example:

     | ?- add_breakpoint(goal(foo(1,_)), _).
     % Conditional spypoint for user:foo/2 added, BID=1

   The `goal(G)' breakpoint test specifies that the breakpoint should
be applied only if the current goal is an instance of `G', i.e. `G' and
the current goal can be unified without substituting any variables in
the latter. This unification is then carried out. The `goal(G)'
condition is thus equivalent to the `subsumes(G,CURRENTGOAL)' test
(`subsumes/2' is defined in `library(terms)', *note lib-terms::).

   In the above example the debugger will stop if `foo/2' is called
with `1' as its first argument, but not if the first argument is, say,
`2', nor if it is a variable.

   You can use non-anonymous variables in the `goal' test, and then put
further constraints on these variables using the `true' condition:

     | ?- add_breakpoint([goal(foo(X,_)),true(X>1)], _).
     % Conditional spypoint for user:foo/2 added, BID=1

   Here the first test, `goal', specifies that we are only interested
in invocations of `foo/2', and names the first argument of the goal as
`X'. The second, the `true/1' test, specifies a further condition
stated as a Prolog goal: `X' is greater than `1' (we assume here that
the argument is numeric).  Thus this breakpoint will be applicable if
and only if the first argument of `foo/2' is _greater_ than `1'.
Generally, an arbitrary Prolog goal can be placed inside the `true'
test: the test will succeed if and only if the goal completes
successfully.

   Any variable instantiations in the test part will be undone before
executing the action part, as the evaluation of the test part is
enclosed in a double negation (`\+ \+ (...)'). This ensures that the
test part has no effect on the variables of the current goal.

   Both the `pred' and the `goal' tests may include a module name. In
fact, the first argument of `add_breakpoint' is module name expanded,
and the (explicit or implicit) module name of this argument is then
inherited by default by the `pred', `goal', and `true' tests. Notice
the module qualification inserted in front of the breakpoint spec of
the last example, as shown in the output of the `debugging/0' built-in
predicate:

     | ?- debugging.
     (...)
     Breakpoints:
           1 *  user:foo/2 if user:[goal(foo(A,B)),true(A>1)]

   As no explicit module qualifications were given in the tests, this
breakpoint spec is transformed to the following form:

     [goal(user:foo(A,B)),true(user:(A>1))]

   For exported predicates, a `pred' or `goal' test will be found
applicable for all invocations of the predicate, irrespective of the
module the call occurs in. When you add the breakpoint you can use the
defining or an importing module name, but this information is not
remembered: the module name is "normalized", i.e. it is changed to the
defining module. The example below shows this: although the spypoint is
placed on `user:append', the message and the breakpoint list both
mention `lists:append'.

     | ?- use_module(library(lists)).
     (...)
     % module lists imported into user
     (...)
     | ?- spy user:append.
     % Plain spypoint for lists:append/3 added, BID=1
     | ?- debugging.
     (...)
     Breakpoints:
           1 +  lists:append/3

   Note that the debugger does not stop inside a library predicate when
doing an exhaustive trace. This is because the library modules are
declared hidden (*note ref-mod::), and no trace is produced for calls
inside hidden modules that invoke predicates defined in hidden modules.
However, a spypoint is always shown in the trace, even if it occurs in a
hidden module:

      +      1      1 Call: append([1,2],[3,4],_531) ? <RET>
      +      2      2 Call: lists:append([2],[3,4],_1182) ? <RET>
      +      3      3 Call: lists:append([],[3,4],_1670) ? <RET>
      +      3      3 Exit: lists:append([],[3,4],[3,4]) ? <RET>
     (...)

   You can narrow a breakpoint to calls from within a particular module
by using the `module' test, e.g.

     | ?- add_breakpoint([pred(append/3),module(user)], _).
     % The debugger will first zip -- showing spypoints (zip)
     % Conditional spypoint for lists:append/3 added, BID=1
     % zip
     | ?- append([1,2], [3,4], L).
      *      1      1 Call: append([1,2],[3,4],_531) ? <RET>
      *      1      1 Exit: append([1,2],[3,4],[1,2,3,4]) ? <RET>
     L = [1,2,3,4]

   With this spypoint, the debugger will only stop at the invocations
of `append/3' from the `user' module.

   Note that calling module information is not kept by the compiler for
the built-in predicates, therefore the `module' test will always unify
its argument with `prolog' in case of compiled calls to built-in
predicates.

   There are two further interesting breakpoint tests related to
invocations: `inv(Inv)' and `depth(Depth)'. These unify their arguments
with the invocation number and the depth, respectively (the two numbers
shown at the beginning of each trace message). Such tests are most
often used in more complex breakpoints, but there may be some simple
cases when they are useful.

   Assume you put a plain spypoint on `foo/2', and start leaping
through your program. After some time, you notice some inconsistency at
an Exit port, but you cannot go back to the Call port for retrying this
invocation, because of side-effects. So you would like to restart the
whole top-level goal and get back to the Call port of the suspicious
goal as fast as possible. Here is what you can do:

     | ?- spy foo/2.
     % Plain spypoint for user:foo/2 added, BID=1
     | ?- debug, foo(23, X).
     % The debugger will first leap -- showing spypoints (debug)
      +      1      1 Call: foo(23,_414) ? l
     (...)
      +     81     17 Call: foo(7,_9151) ? l
      +     86     18 Call: foo(6,_9651) ? l
      +     86     18 Exit: foo(6,8) ? -
     % Plain spypoint for user:foo/2, BID=1, removed (last)
            86     18 Exit: foo(6,8) ? *
     Placing spypoint on user:foo/2 with conditions: inv(86).
     % Conditional spypoint for user:foo/2 added, BID=1
      *     86     18 Exit: foo(6,8) ? a
     % Execution aborted
     % source_info
     | ?- debug, foo(23, X).
     % The debugger will first leap -- showing spypoints (debug)
      *     86     18 Call: foo(6,_2480) ? <RET>

   When you reach the Exit port of the suspicious invocation (number
86), you remove the plain spypoint (via the `-' debugger command), and
add a conditional one using the `*' debugger command. This
automatically includes `pred(foo/2)' among the conditions and displays
the prompt `Placing spypoint ... with conditions:', requesting further
ones.  You enter here the `inv' test with the invocation number in
question, resulting in a breakpoint with the `[pred(foo/2),inv(86)]'
conditions. If you restart the original top-level goal in debug mode,
the debugger immediately positions you at the invocation with the
specified number.

   Note that when the debugger executes a "skip" or a "zip" command, no
procedure boxes are built.  Consequently, the invocation and depth
counters are not incremented.  If "skip" and/or "zip" commands were
used during the first execution, the suspicious invocation gets an
invocation number higher than 86 in the second run. Therefore it is
better to supply the `inv(I),true(I>=86)' condition to the `*' debugger
command, which will bring you to the first call of `foo/2' at, or after
invocation number 86 (which still might not be the suspicious
invocation).

   In the examples, the `inv' test was used both with a numeric and a
variable argument (`inv(86)' and `inv(I)'). This is possible because
the debugger _unifies_ the given feature with the argument of the test.
This holds for most tests, we will mention the exceptions.

   Another similar example: if you suspect that a given predicate goes
into an infinite recursion, and would like the execution to stop when
entering this predicate somewhere inside the recursion, you can do the
following:

     | ?- add_breakpoint([pred(foo/2),depth(_D),true(_D>=100)], _).
     % Conditional spypoint for user:foo/2 added, BID=1
     % zip,source_info
     | ?- debug, foo(200, X).
     % The debugger will first leap -- showing spypoints (debug)
      *    496    100 Call: foo(101,_12156) ?

   The above breakpoint spec will cause the debugger to stop at the
first invocation of `foo/2' at depth 100 or greater. Note again that
debug mode has to be entered for this to work (in zip mode no debugging
information is kept, so the depth does not change).

   We now continue with tests that restrict the breakpoint to an
invocation at a specific place in the code.

   Assume file `/home/bob/myprog.pl' contains the following Prolog
program:

                                                _% /home/bob/myprog.pl_
     p(X, U) :-                               % line 1
             q(X, Y),                         % line 2
             q(Y, Z),                         % line 3
             (   \+ q(Z, _)                   % line 4
             ->  q(Z+1, U)                    % line 5
             ;   q(Z+2, U)                    % line 6
             ).                               % ...

     q(X, Y) :-
             X < 10, !, Y is X+1.             % line 10
     q(X, Y) :-
             Y is X+2.                        % line 12

   If you are interested only in the last invocation of `q/2' within
`p/2', you can use the following breakpoint:

     | ?- add_breakpoint([pred(q/2),line('/home/bob/myprog.pl',6)], _).
     % Conditional spypoint for user:q/2 added, BID=1

   Generally, the test `line(File,Line)' holds if the current
invocation was in line number `Line' of a file whose absolute name is
`File'. This test (as well as the `line/1' and `file/1' tests, see
below) require the presence of source information: the file in question
had to be consulted or compiled with the `source_info' Prolog flag
switched on (i.e. set to `on' or `emacs').  

   If e.g. `q/2' is called only from a single file, the file name need
not be mentioned and a `line/1' test suffices: `line(6)'. On the other
hand, if we are interested in all invocations of a predicate within a
file, we can omit the line number and use the `file(File)' test.

   For Prolog programs that are interpreted (consulted or asserted),
further positioning information can be obtained, even in the absence of
source information. The test `parent_pred(Pred)' unifies the module
name expanded `Pred' with a predicate spec (of form
`MODULE:PREDNAME/ARITY') identifying the predicate in which the current
invocation resides.  The test `parent_pred(Pred,N)' will additionally
unify `N' with the serial number of the clause containing the current
goal.

   For example, assuming the above `myprog.pl' file is consulted, the
breakpoint below will cause the execution to stop when the call of
`is/2' in the second clause of `q/2' is reached:

     | ?- add_breakpoint([pred(is/2),parent_pred(q/2,2)], _).
     % Conditional spypoint for prolog:is/2 added, BID=1
     * Predicate prolog:is/2 compiled inline, breakable only in interpreted code
     % zip,source_info
     | ?- p(20, X).
     in scope of a goal at line 12 in /home/bob/myprog.pl
      *      1      1 Call: _579 is 20+2 ?

   Notice the warning issued by `add_breakpoint/2': there are some
built-in predicates (e.g. arithmetic, `functor/3', `arg/3', etc.), for
which the compiler generates specific inline translation, rather than
the generic predicate invocation code. Therefore compiled calls to such
predicates are not visible to the debugger.

   More exact positioning information can be obtained for interpreted
programs by using the `parent_clause(Cl,Sel,I)' test. This unifies `Cl'
with the clause containing the current invocation, while `Sel' and `I'
both identify the current invocation within the body of this clause.
`Sel' is unified with a "subterm selector", while `I' with the serial
number of the call. This test has the variants `parent_clause/[1,2]',
in which only the `Cl' argument, or the `Cl,Sel' arguments are present.

   As an example, two further alternatives of putting a breakpoint on
the last call of `q/2' within `myprog.pl' (line 6) are shown below,
together with a listing showing the selectors and call serial numbers
for the body of `p/2':

     | ?- add_breakpoint([pred(q/2),parent_clause((p(_,_):-_),[2,2,2])],_).

     | ?- add_breakpoint([pred(q/2),parent_clause((p(_,_):-_),_,5)],_).

     p(X, U) :-                 % line  % call no.  % subterm selector
             q(X, Y),           %  2        1       [1]
             q(Y, Z),           %  3        2       [2,1]
             (   \+ q(Z, _)     %  4        3       [2,2,1,1,1]
             ->  q(Z+1, U)      %  5        4       [2,2,1,2]
             ;   q(Z+2, U)      %  6        5       [2,2,2]
             ).                 %  7

   Here, the first argument of the `parent_clause' test ensures that
the current invocation is in (the only clause of) `p/2'. If `p/2' had
more clauses, we would have to use an additional test, say
`parent_pred(user:p/2,1)', and then the first argument of
`parent_clause' could be an anonymous variable.

   In the examples so far the breakpoint tests referred only to the
goal in question. Therefore, the breakpoint was found applicable at all
ports of the procedure box of the predicate. We can distinguish between
ports using the `port' breakpoint test:

     | ?- add_breakpoint([pred(foo/2),port(call)], _).

   With this breakpoint, the debugger will stop at the Call port of
`foo/2', but not at other ports. Note that the `port(call)' test can be
simplified to `call' -- `add_breakpoint/2' will recognize this as a
port name, and treat it as if it were enclosed in a `port/1' functor.

   Here are two equivalent formulations for a breakpoint that will
cause the debugger to stop only at the Call and Exit ports of `foo/2':

     | ?- add_breakpoint([pred(foo/2),(call;exit)], _).

     | ?- add_breakpoint([pred(foo/2),port(P),true((P=call;P=exit(_)))], _).

   In both cases we have to use disjunction. In the first example we
have a disjunctive breakpoint condition of the two simple tests
`port(call)' and `port(exit)' (with the `port' functor omitted). In the
second case the disjunction is inside the Prolog test within the `true'
test.

   Notice that the two examples refer to the Exit port differently.
When you use `port(P)', where `P' is a variable, then, at an exit port,
`P' will be unified with either `exit(nondet)' or `exit(det)',
depending on the determinacy of the exited predicate. However, for
convenience, the test `port(exit)' will also succeed at Exit ports.  So
in the first example above, `exit' can be replaced by `exit(_)', but
the `exit(_)' in the second can not be replaced by `exit'.

   Finally, there is a subtle point to note with respect to activating
the debugger at non Call ports. Let us look at the following breakpoint:

     | ?- add_breakpoint([pred(foo/2),fail], _).

   The intention here is to have the debugger stop at only the Fail
port of `foo/2'. This is very useful if `foo/2' is not supposed to
fail, but we suspect that it does. The above breakpoint will behave as
expected when the debugger is leaping, but not while zipping.  This is
because for the debugger to be able to stop at a non Call port, a
procedure box has to be built at the Call port of the given invocation.
However, no debugging information is collected in zip mode by default,
i.e. procedure boxes are not built. Later we will show how to achieve
the required effect, even in zip mode.


File: sicstus.info,  Node: Specific and Generic Breakpoints,  Next: Breakpoint Actions,  Prev: Breakpoint Tests,  Up: Advanced Debugging

5.6.4 Specific and Generic Breakpoints
--------------------------------------

In all the examples so far a breakpoint was put on a specific
predicate, described by a `goal' or `pred' test. Such breakpoints are
called "specific", as opposed to "generic" ones.

   Generic breakpoints are the ones that do not specify a concrete
predicate. This can happen when the breakpoint spec does not contain
`goal' or `pred' tests at all, or their argument is not sufficiently
instantiated. Here are some examples of generic breakpoints:

     | ?- add_breakpoint(line('/home/bob/myprog.pl',6), _).
     % Generic spypoint added, BID=1
     | ?- add_breakpoint(pred(foo/_), _).
     % Generic spypoint added, BID=2
     | ?- add_breakpoint([goal(G),true((arg(1,G,X),X==bar))], _).
     % Generic spypoint added, BID=3

   The first breakpoint will stop at all calls in line 6 of the given
file, the second at all calls of a predicate `foo', irrespective of the
number of arguments, while the third one will stop at any predicate
with `bar' as its first argument. However, there is an additional
implicit condition: the module name expansion inserts the type-in
module as the default module name in the `goal' and `pred' conditions.
Consequently, the second and third breakpoint applies only to
predicates in the type-in module (`user' by default). If you would like
the breakpoint to cover all modules you have to include an anonymous
module prefix in the argument of the `goal' or `pred' test:

     | ?- add_breakpoint(pred(_:foo/_), _).
     % Generic spypoint added, BID=1
     % zip
     | ?- add_breakpoint([goal(_:G),true((arg(1,G,X),X==bar))], _).
     % Generic spypoint added, BID=2

   Generic breakpoints are very powerful, but there is a price to pay:
the zip mode is slowed down considerably.

   As said earlier, in principle the debugger is entered at each port
of each procedure invocation. As an optimization, the debugger can
request the underlying Prolog engine to run at full speed and invoke the
debugger only when one of the specified predicates is called. This
optimization is used in zip mode, provided there are no generic
breakpoints. In the presence of generic breakpoints, however, the
debugger has to be entered at each call, to check their applicability.
Consequently, with generic breakpoints, zip mode execution will not
give much speed-up over debug mode, although its space requirements
will still be much lower.

   It is therefore advisable to give preference to specific breakpoints
over generic ones, whenever possible. For example, if your program
includes predicates `foo/2' and `foo/3', it is much better to create
two specific breakpoints, rather than a single generic one with
conditions `[pred(foo/_),...]'.

   `spy/2' is a built-in predicate that will create specific
breakpoints only. Its first argument is a generalized predicate spec,
much like in `spy/1', and the second argument is a breakpoint spec.
`spy/2' will expand the first argument to one or more predicate specs,
and for each of these will create a breakpoint, with a `pred' condition
added to the _test_ part of the supplied breakpoint spec. For example,
in the presence of predicates `foo/2' and `foo/3'

     | ?- spy(foo/_, file(...))

is equivalent to:

     | ?- add_breakpoint([pred(foo/2),file(...)], _),
          add_breakpoint([pred(foo/3),file(...)], _).

   Note that with `spy/[1,2]' it is not possible to put a breakpoint on
a (yet) undefined predicate. On the other hand, `add_breakpoint/2' is
perfectly capable of creating such breakpoints.


File: sicstus.info,  Node: Breakpoint Actions,  Next: Advice-points,  Prev: Specific and Generic Breakpoints,  Up: Advanced Debugging

5.6.5 Breakpoint Actions
------------------------

The action part of a breakpoint spec supplies information to the
debugger as to what should be done when the breakpoint is activated.
This is achieved by setting the three so called "debugger action
variables". These are listed below, together with their most important
values.

   * The `show' variable prescribes how the debugged goal should be
     displayed:

    `print'
          write the goal according to the `debugger_print_options'
          Prolog flag.  

    `silent'
          do not display the goal.

   * The `command' variable prescribes what the debugger should do:

    `ask'
          ask the user.

    `proceed'
          continue the execution without stopping, creating a procedure
          box for the current goal at the Call port,

    `flit'
          continue the execution without stopping, without creating a
          procedure box for the current goal at the Call port.

   * The `mode' variable prescribes in what mode the debugger should
     continue the execution:

    `trace'
          creeping.

    `debug'
          leaping.

    `zip'
          zipping.

    `off'
          without debugging.

   For example, the breakpoint below specifies that whenever the Exit
port of `foo/2' is reached, no trace message should be output, no
interaction should take place and the debugger should be switched off.

     | ?- add_breakpoint([pred(foo/2),port(exit)]-
                         [show(silent),command(proceed),mode(off)], _).

   Here, the action part consists of three actions, setting the three
action variables. This breakpoint spec can be simplified by omitting
the wrappers around the variable values, as the sets of possible values
of the variables are all disjoint. If we use `spy/2', the `pred'
wrapper goes away, too, resulting in a much more concise, equivalent
formulation of the above breakpoint:

     | ?- spy(foo/2,exit-[silent,proceed,off]).

   Let us now revisit the process of breakpoint selection. When the
debugger arrives at a port it first initializes the action variables
according to the current debugging and leashing modes, as shown below:

     debugging    leashing           |        Action variables
     mode         mode               |  show        command     mode
     --------------------------------|-------------------------------
     trace        at leashed port    |  print       ask         trace
                                     |
     trace        at unleashed port  |  print       proceed     trace
                                     |
     debug        -                  |  silent      proceed     debug
                                     |
     zip          -                  |  silent      flit        zip

   It then considers each breakpoint, most recent first, until it finds
a breakpoint whose test part succeeds. If such a breakpoint is found,
its action part is evaluated, normally changing the action variable
settings. A failure of the action part is ignored, in the sense that
the breakpoint is still treated as the selected one.  However, as a
side-effect, a procedure box will always be built in such cases. More
precisely, the failure of the action part causes the `flit' command
value to be changed to `proceed', all other command values being left
unchanged. This is to facilitate the creation of breakpoints that stop
at non-Call ports (see below for an example).

   If no applicable breakpoint is found, the action variables remain
unchanged.

   The debugger then executes the actions specified by the action
variables.  This process, referred to as the "action execution", means
the following:
   * The current debugging mode is set to the value of the `mode'
     action variable.

   * A trace message is displayed according to the `show' variable.

   * The program continues according to the `command' variable.

   Specifically, if `command' is `ask', the user is prompted for a
debugger command, which in turn is converted to new assignments to the
action variables. The debugger will then repeat the action execution
process, described above. For example, the `c' (creep) interactive
command is converted to `[silent,proceed,trace]', the `d' (display)
command to `[display,ask]' (when command is `ask', the mode is
irrelevant), etc.

   The default values of the action variables correspond to the standard
debugger behavior described in *Note Basic Debug::. For example, when an
unleashed port is reached in trace mode, a trace message is printed and
the execution proceeds in trace mode, without stopping. In zip mode, no
trace message is shown, and execution continues in zip mode, without
building procedure boxes at Call ports.

   Note that a spypoint action part that is empty (`[]' or not present)
is actually treated as `[print,ask]'. Again, this is the standard
behavior of spypoints, as described in *Note Basic Debug::.

   If an action part is nonempty, but it does not set the action
variables, the only effect it will have is to hide the remaining older
spypoints, as the debugger will behave in the standard way, according
to the debugging mode. Still, such breakpoints may be useful if they
have side-effects, for example:

     | ?- spy(foo/2, -[parent_pred(P),
                       goal(G),
                       true(format('~q called from:~w~n',[G,P]))]).
     % The debugger will first zip -- showing spypoints (zip)
     % Conditional spypoint for user:foo/2 added, BID=1
     true
     % zip
     | ?- foo(3,X).
     foo(2,_701) called from:bar/3
     foo(1,_1108) called from:bar/3
     foo(0,_1109) called from:bar/3
     foo(1,_702) called from:bar/3
     X = 2 ? ;
     no

   This spypoint produces some output at ports of `foo/2', but
otherwise will not influence the debugger. Notice that a breakpoint
spec with an empty test part can be written `-'ACTIONS.

   Let us look at some simple examples of what other effects can be
achieved by appropriate action variable settings:

     | ?- spy(foo/2, -[print,proceed]).

   This is an example of an unleashed spypoint: it will print a trace
message passing each port of `foo/2', but will not stop there. Note
that because of the `proceed' command a procedure box will be built,
even in zip mode, and so the debugger will be activated at non-Call
ports of `foo/2'.

   The next example is a variant of the above:

     | ?- spy(foo/2, -[print,flit]).

   This will print a trace message at the Call port of `foo/2' and will
then continue the execution in the current debugging mode, without
building a procedure box for this call. This means that the debugger
will not be able to notice any other ports of `foo/2'.

   Now let us address the task of stopping at a specific non-Call port
of a predicate. For this to work in zip mode, one has to ensure that a
procedure box is built at the Call port. In the following example, the
first spypoint causes a box to be built for each call of `foo/2', while
the second one makes the debugger stop when the Fail port of `foo/2' is
reached.

     | ?- spy(foo/2, call-proceed), spy(foo/2, fail).
     % Conditional spypoint for user:foo/2 added, BID=1
     % Conditional spypoint for user:foo/2 added, BID=2

   You can achieve the same effect with a single spypoint, by putting
the `fail' condition (which is a shortcut for `port(fail)') in the
_action_ part, rather than in the _test_ part.

     | ?- spy(foo/2, -[fail,print,ask]).

   Here, when the execution reaches the Call port of `foo/2', the test
part (which contains the `pred(foo/2)' condition only) succeeds, so the
breakpoint is found applicable.  However, the action part fails at the
Call port. This has a side-effect in zip mode, as the default `flit'
command value is changed to `proceed'. In other modes the action
variables are unaffected. The net result is that a procedure box is
always built for `foo/2', which means that the debugger will actually
reach the Fail port of this predicate. When this happens, the action
part succeeds, and executing the actions `print,ask' will cause the
debugger to stop.

   Note that we have to explicitly mention the `print,ask' actions
here, because the action part is otherwise nonempty (contains the
`fail' condition). It is only the empty or missing action part, which
is replaced by the default `[print,ask]'. If you want to include a
condition in the action part, you have to explicitly mention all action
variable settings you need.

   To make this simpler, the debugger handles breakpoint condition
macros, which expand to other conditions. For example `leash' is a
macro that expands to `[print,ask]'. Consequently, the last example can
be simplified to:

     | ?- spy(foo/2, -[fail,leash]).

   Similarly, the macro `unleash' expands to `[print,proceed]', while
`hide' to `[silent,proceed]'.

   We now briefly describe further possible settings to the action
variables.

   The `mode' variable can be assigned the values `skip(INV)' and
`qskip(INV)', meaning skipping and quasi-skipping until a port is
reached whose invocation number is less or equal to INV. When the
debugger arrives at this port it sets the `mode' variable to `trace'.

   It may be surprising that `skip(...)' is a mode, rather than a
command. This is because commands are executed and immediately
forgotten, but skipping has a lasting effect: the program is to be run
with no debugging until a specific point, without creating new
procedure boxes, and ignoring the existing ones in the meantime.

   Here is an example using the `skip' mode:

     | ?- spy(foo/2,call-[print,proceed,inv(Inv),skip(Inv)]).

   This breakpoint will be found applicable at Call ports of `foo/2'.
It will print a trace message there and will skip over to the Exit or
Fail port without stopping. Notice that the number of the current
invocation is obtained in the action part, using the `inv' condition
with a variable argument. A variant of this example follows:

     | ?- spy(foo/2,-[silent,proceed,
                            (   call -> inv(Inv), skip(Inv)
                            ;   true
                            )]).

   This spypoint makes `foo/2' invisible in the output of the debugger:
at all ports we silently proceed (i.e. display nothing and do not
stop).  Furthermore, at the Call port we perform a skip, so neither
`foo/2' itself, nor any predicate called within it will be shown by the
debugger.

   Notice the use of the `true/0' test in the above conditional!  This
is a breakpoint test that always succeeds.  The debugger also
recognizes `false' as a test that always fails. Note that while `false'
and `fail' are synonyms as built-in predicates, they are completely
different as breakpoint conditions: the latter is a shortcut for
`port(fail)'.

   The `show' variable has four additional value patterns. Setting it
to `display', `write', or `write_term(OPTIONS)' will result in the
debugged goal G being shown using `display(G)', `writeq(G)', or
`write_term(G, OPTIONS)', respectively. The fourth pattern,
`METHOD-SEL', can be used for replacing the goal in the trace message
by one of its subterms, the one pointed to by the selector SEL.

   For example, the following spypoint instructs the debugger to stop
at each port of `foo/2', and to only display the first argument of
`foo/2' in the trace message, instead of the complete goal.

     | ?- spy(foo/2, -[print-[1],ask]).
     % Conditional spypoint for user:foo/2 added, BID=1
     | ?- foo(5,X).
      *      1      1 Call: ^1 5 ?

   The `command' variable has several further value patterns.  The
variable can be set to `proceed(OLDGOAL,NEWGOAL)'. At a Call port this
instructs the debugger to first build a procedure box for the current
goal, then to unify it with OLDGOAL and finally execute NEWGOAL in its
place (cf.  the `u' (unify) interactive debugger command). At non-Call
ports this command first goes back to the Call port (cf.  the `r'
(retry) command), and then does the above activities.

   A variant of the `proceed/2' command is `flit(OLDGOAL,NEWGOAL)'.
This has the same effect, except for not building a procedure box for
OLDGOAL.

   We now just briefly list further command values (for the details, see
*Note Action Variables::). Setting `command' to `exception(E)' will
raise an exception E, `abort' will abort the execution. The values
`retry(INV)', `reexit(INV)', `redo(INV)', `fail(INV)' will cause the
debugger to go back to an earlier Call, Exit, Redo, or Fail port with
invocation number INV (cf. the `j' (jump) interactive debugger command).

   Sometimes it may be useful to access the value of an action
variable. This can be done with the `get' condition: e.g.
`get(mode(M))' will unify `M' with the current execution mode. The
`get(...)' wrapper can be omitted in the test part, but not in the
action part (since there a `mode(M)' action will set, rather than read,
the mode action variable).  For example:

     | ?- spy(foo/2, mode(trace)-show(print-[1])).

   This spypoint will be found applicable only in trace mode (and will
cause the first argument of `foo/2' to appear in the trace message).
(The `mode' and `show' wrappers can also be omitted in the above
example, they are used only to help with interpreting the breakpoint
spec.)


File: sicstus.info,  Node: Advice-points,  Next: Built-in Predicates for Breakpoint Handling,  Prev: Breakpoint Actions,  Up: Advanced Debugging

5.6.6 Advice-points
-------------------

As mentioned earlier, there are two kinds of breakpoints: spypoints and
advice-points.  The main purpose of spypoints is to support interactive
debugging. In contrast with this, advice-points can help you to perform
non-interactive debugging activities. For example, the following
advice-point will check a program invariant: whether the condition
`Y-X<3' always holds at exit from `foo(X,Y)'.

     | ?- add_breakpoint([pred(foo/2),advice]
                         -[exit,goal(foo(X,Y)),\+true(Y-X<3),trace], _).
     % Conditional advice point for user:foo/2 added, BID=1
     % advice
     | ?- foo(4, Y).
     Y = 3
     % advice
     | ?- foo(9, Y).
             3      3 Exit: foo(7,13) ? n
             2      2 Exit: foo(8,21) ?

   The test part of the above breakpoint contains a `pred' test, and
the `advice' condition, making it an advice-point.  (You can also
include the `debugger' condition in spypoint specs, although this is
the default interpretation.)

   The action part starts with the `exit' port condition. Because of
this the rest of the action part is evaluated only at Exit ports. By
placing the port condition in the action part, we ensure the creation
of a procedure box at the Call port, as explained earlier.

   Next, we get hold of the goal arguments using the `goal' condition,
and use the `\+true(Y-X<3)' test to check if the invariant is violated.
If this happens, the last condition sets the `mode' action variable to
`trace', switching on the interactive debugger.

   Following the `add_breakpoint/2' call the above example shows two
top-level calls to `foo/2'. The invariant holds within the first goal,
but is violated within the second. Notice that the advice mechanism
works with the interactive debugger switched off.

   You can ask the question, why do we need advice-points? The same
task could be implemented using a spypoint. For example:

     | ?- add_breakpoint(pred(foo/2)
                         -[exit,goal(foo(X,Y)),\+true(Y-X<3),leash], _).
     % The debugger will first zip -- showing spypoints (zip)
     % Conditional spypoint for user:foo/2 added, BID=1
     % zip
     | ?- foo(4, X).
     X = 3
     % zip
     | ?- foo(9, X).
      *      3      3 Exit: foo(7,13) ? z
      *      2      2 Exit: foo(8,21) ?

   The main reason to have a separate advice mechanism is to be able to
perform checks independently of the interactive debugging. With the
second solution, if you happen to start some interactive debugging, you
cannot be sure that the invariant is always checked. For example, no
spypoints will be activated during a skip. In contrast with this, the
advice mechanism is watching the program execution all the time,
independently of the debugging mode.

   Advice-points are handled in very much the same way as spypoints
are.  When arriving at a port, advice-point selection takes place
first, followed by spypoint selection. This can be viewed as the
debugger making two passes over the current breakpoints, considering
advice-points only in the first pass, and spypoints only in the second.

   In both passes the debugger tries to find a breakpoint that can be
activated, checking the test and action parts, as described earlier.
However, there are some differences between the two passes:

   * Advice processing is performed if there are any (non-disabled)
     advice-points. Spypoint processing is only done if the debugger is
     switched on, and is not doing a skip.

   * For advice-points, the action variables are initialized as follows:
     `mode' is set to current debugging mode, `command = proceed',
     `show = silent'. Note that this is done independently of the
     debugging mode (in contrast with the spypoint search
     initialization).

   * The default action part for advice-points is `[]'. This means that
     if no action part is given, the only effect of the advice-point
     will be to build a procedure box (because of the `command =
     proceed' initialization).

   * If no advice-point was found applicable, `command' is set to
     `flit'.

   Having performed advice processing, the debugger inspects the
`command' variable. The command values different from `proceed' and
`flit' are called "divertive", as they alter the normal flow of control
(e.g. `proceed(...,...)'), or involve user interaction (`ask'). If the
`command' value is divertive, the prescribed action is performed
immediately, without executing the spypoint selection process.
Otherwise, if `command = proceed', it is noted that the advice part
requests the building of a procedure box.  Next, the second, spypoint
processing pass is carried out, and possible user interaction takes
place, as described earlier. A procedure box is built if either the
advice-point or the spypoint search requests this.

   Let us conclude this section by another example, a generic
advice-point for collecting branch coverage information:

     | ?- add_breakpoint(
           (advice,call) -
               (   line(F,L) -> true(assert(line_reached(F,L))), flit
               ;   flit
               ), _).
     % Generic advice point added, BID=1
     % advice,source_info
     | ?- foo(4,X).
     X = 3 ? ;
     no
     % advice,source_info
     | ?- setof(X, line_reached(F,X), S).
     F = '/home/bob/myprog.pl',
     S = [31,33,34,35,36]

   This advice-point will be applicable at every Call port. It will
then assert a fact with the file name and the line number if source
information is available. Finally, it will set the `command' variable
to `flit' on both branches of execution. This is to communicate the
fact that the advice-point does not request the building of a procedure
box.

   It is important to note that this recording of the line numbers
reached is performed independently of the interactive debugging.

   In this example we used the `','/2' operator, rather than list
notation, for describing the conjunction of conditions, as this seems
to better fit the if-then-else expression used in the action part. We
could have still used lists in the tests part, and in the "then" part
of the actions. Note that if we omit the "else" branch, the action part
will fail if no source information is available for the given call.
This will cause a procedure box to be built, which is an unnecessary
overhead. An alternative solution, using the `line/2' test twice, is
the following:

     | ?- add_breakpoint([advice,call,line(_,_)]-
                         [line(F,L),true(assert(line_reached(F,L))),flit], _).

   Further examples of advice-points are available in
`library(debugger_examples)'.


File: sicstus.info,  Node: Built-in Predicates for Breakpoint Handling,  Next: Accessing Past Debugger States,  Prev: Advice-points,  Up: Advanced Debugging

5.6.7 Built-in Predicates for Breakpoint Handling
-------------------------------------------------

This section introduces built-in predicates for evaluating breakpoint
conditions, and for retrieving, deleting, disabling and enabling
breakpoints.

   The breakpoint spec of the last advice-point example was quite
complex. And, to be practical, it should be improved to assert only
line numbers not recorded so far. For this you will write a Prolog
predicate for the conditional assertion of file/line information,
`assert_line_reached(File,Line)', and use it instead of the
`assert(line_reached(F,L))' condition.

   Because of the complexity of the breakpoint spec, it looks like a
good idea to move the if-then-else condition into Prolog code. This
requires that we test the `line(F,L)' condition from Prolog.  The
built-in predicate `execution_state/1' serves for this purpose. It
takes a simple or a composite breakpoint condition as its argument and
evaluates it, as if in the test part of a breakpoint spec. The
predicate will succeed if and only if the breakpoint condition
evaluates successfully. Thus `execution_state/1' allows you to access
debugging information from within Prolog code. For example, you can
write a Prolog predicate, `assert_line_reached/0', which queries the
debugger for the current line information and then processes the line
number:

     assert_line_reached :-
             (   execution_state(line(F,L)) -> assert_line_reached(F,L).
             ;   true
             ).

     | ?- add_breakpoint([advice,call]-[true(assert_line_reached),flit], _).

   Arbitrary tests can be used in `execution_state/1', if it is called
from within a `true' condition. It can also be called from outside the
debugger, but then only a subset of conditions is available.
Furthermore, the built-in predicate `execution_state/2' allows
accessing information from past debugger states (*note Accessing Past
Debugger States::).

   The built-in predicates `remove_breakpoints(BIDS)',
`disable_breakpoints(BIDS)' and `enable_breakpoints(BIDS)' serve for
removing, disabling and enabling the given breakpoints. Here BIDS can
be a single breakpoint identifier, a list of these, or one of the atoms
`all', `advice', `debugger'.

   We now show an application of `remove_breakpoints/1' for
implementing one-off breakpoints, i.e. breakpoints that are removed
when first activated.

   For this we need to get hold of the currently selected breakpoint
identifier.  The `bid(BID)' condition serves for this purpose: it
unifies its argument with the identifier of the breakpoint being
processed. The following is an example of a one-off breakpoint.

     | ?- spy(foo/2, -[bid(BID),true(remove_breakpoints(BID)),leash]).
     % Conditional spypoint for user:foo/2 added, BID=1
     % zip
     | ?- foo(2, X).
     % Conditional spypoint for user:foo/2, BID=1, removed (last)
             1      1 Call: foo(2,_402) ? z
     X = 1

   The action part of the above breakpoint calls the `bid' test to
obtain the breakpoint identifier. It then uses this number as the
argument to the built-in predicate `remove_breakpoints/1', which
removes the activated breakpoint.

   The built-in predicate `current_breakpoint(SPEC, BID, STATUS, KIND,
TYPE)' enumerates all breakpoints present in the debugger. For example,
if we call `current_breakpoint/5' before the invocation of `foo/2' in
the last example, we get this:

     | ?- current_breakpoint(Spec, BID, Status, Kind, Type).
     Spec = [pred(user:foo/2)]-[bid(_A),true(remove_breakpoints(_A)),leash],
     BID = 1,
     Status = on,
     Kind = conditional(user:foo/2),
     Type = debugger

   Here SPEC is the breakpoint spec of the breakpoint with identifier
BID. STATUS is `on' for enabled breakpoints and `off' for disabled
ones. KIND is one of `plain(MFUNC)', `conditional(MFUNC)' or `generic',
where MFUNC is the module qualified functor of the specific breakpoint.
Finally TYPE is the breakpoint type: `debugger' or `advice'.

   The SPEC returned by `current_breakpoint/5' is exactly the same as
the one given in `add_breakpoint/2'. If the breakpoint was created by
`spy/2', the test part is extended by a `pred' condition, as
exemplified above.  Earlier we described some pre-processing steps that
the spec goes through, such as moving the module qualification of the
spec to certain conditions. These transformations are performed on the
copy of the breakpoint used for testing. Independently of this, the
debugger also stores the original breakpoint, which is returned by
`current_breakpoint/5'.


File: sicstus.info,  Node: Accessing Past Debugger States,  Next: Storing User Information in the Backtrace,  Prev: Built-in Predicates for Breakpoint Handling,  Up: Advanced Debugging

5.6.8 Accessing Past Debugger States
------------------------------------

In this section we introduce the built-in predicates for accessing past
debugger states, and the breakpoint conditions related to these.

   The debugger collects control flow information about the goals being
executed, more precisely about those goals, for which a procedure box
is built.  This collection of information, the backtrace, includes the
invocations that were called but not exited yet, as well as those that
exited nondeterminately. For each invocation, the main data items
present in the backtrace are the following: the goal, the module, the
invocation number, the depth and the source information, if any.

   Furthermore, as you can enter a new break level from within the
debugger, there can be multiple backtraces, one for each active break
level.

   You can access all the information collected by the debugger using
the built-in predicate `execution_state(FOCUS, TESTS)'.  Here FOCUS is
a ground term specifying which break level and which invocation to
access.  It can be one of the following:

   * `break_level(BL)' selects the _current_ invocation within the
     break level BL.

   * `inv(INV)' selects the invocation number INV within the current
     break level.

   * A list containing the above two elements, selects the invocation
     with number INV within break level BL.

   Note that the top-level counts as break level 0, while the
invocations are numbered from 1 upwards.

   The second argument of `execution_state/2', TESTS, is a simple or
composite breakpoint condition. Most simple tests can appear inside
TESTS, with the exception of the `port', `bid', `advice', `debugger',
and `get' tests.  These tests will be interpreted in the context of the
specified past debugger state. Specifically, if a `true/1' condition is
used, any `execution_state/1' queries appearing in it will be evaluated
in the past context.

   To illustrate the use of `execution_state/2', we now define a
predicate `last_call_arg(ArgNo, Arg)', which is to be called from
within a break, and which will look at the last debugged goal of the
previous break level, and return in `Arg' the `ArgNo'th argument of
this goal.

     last_call_arg(ArgNo, Arg) :-
             execution_state(break_level(BL1)),
             BL is BL1-1,
             execution_state(break_level(BL), goal(Goal)),
             arg(ArgNo, Goal, Arg).

   We see two occurrences of the term `break_level(...)' in the above
example. Although these look very similar, they have different roles.
The first one, in `execution_state/1', is a breakpoint test, which
unifies the current break level with its argument.  Here it is used to
obtain the current break level and store it in `BL1'.  The second use
of `break_level(...)', in the first argument of `execution_state/2', is
a focus condition, whose argument has to be instantiated, and which
prescribes the break level to focus on. Here we use it to obtain the
goal of the current invocation of the previous break level.

   Note that the goal retrieved from the backtrace is always in its
latest instantiation state.  For example, it is not possible to get
hold of the goal instantiation at the Call port, if the invocation in
question is at the Exit port.

   Here is an example run, showing how `last_call_arg/2' can be used:

             5      2 Call: _937 is 13+8 ? b
     % Break level 1
     % 1
     | ?- last_call_arg(2, A).
     A = 13+8

   There are some further breakpoint tests that are primarily used in
looking at past execution states.

   The test `max_inv(MAXINV)' returns the maximal invocation number
within the current (or selected) break level. The test
`exited(BOOLEAN)' unifies BOOLEAN with `true' if the invocation has
exited, and with `false' otherwise.

   The following example predicate lists those goals in the backtrace,
together with their invocation numbers, that have exited. These are the
invocations that are listed by the `t' interactive debugger command
(print backtrace), but not by the `g' command (print ancestor goals).
Note that the predicate `between(N,M,I)' enumerates all integers such
that N \leq I \leq M.

     exited_goals :-
          execution_state(max_inv(Max)),
          between(1, Max, Inv),
          execution_state(inv(Inv), [exited(true),goal(G)]),
          format('~t~d~6| ~p\n', [Inv,G]),
          fail.
     exited_goals.
     (...)

     ?*     41     11 Exit: foo(2,1) ? @
     | :- exited_goals.
         26 foo(3,2)
         28 bar(3,1,1)
         31 foo(2,1)
         33 bar(2,1,0)
         36 foo(1,1)
         37 foo(0,0)
         39 foo(1,1)
         41 foo(2,1)
         43 bar(2,1,0)
         46 foo(1,1)
         47 foo(0,0)
     ?*     41     11 Exit: foo(2,1) ?

   Note that similar output can be obtained by entering a new break
level and calling `exited_goals' from within an `execution_state/2':

     % 1
     | ?- execution_state(break_level(0), true(exited_goals)).

   The remaining two breakpoint tests allow you to find parent and
ancestor invocations in the backtrace. The `parent_inv(INV)' test
unifies INV with the invocation number of the youngest ancestor present
in the backtrace, called "debugger-parent" for short. The test
`ancestor(ANCGOAL,INV)' looks for the youngest ancestor in the
backtrace that is an instance of ANCGOAL. It then unifies the ancestor
goal with ANCGOAL and its invocation number with INV.

   Assume you would like to stop at all invocations of `foo/2' that are
somewhere within `bar/1', possibly deeply nested. The following two
breakpoints achieve this effect:

     | ?- spy(bar/1, advice), spy(foo/2, ancestor(bar(_),_)).
     % Plain advice point for user:bar/1 added, BID=3
     % Conditional spypoint for user:foo/2 added, BID=4

   We added an advice-point for `bar/1' to ensure that all calls to it
will have procedure boxes built, and so become part of the backtrace.
Advice-points are a better choice than spypoints for this purpose, as
with `?- spy(bar/1, -proceed)' the debugger will not stop at the call
port of `bar/1' in trace mode. Note that it is perfectly all right to
create an advice-point using `spy/2', although this is a bit of
terminological inconsistency.

   Further examples of accessing past debugger states can be found in
`library(debugger_examples)'.


File: sicstus.info,  Node: Storing User Information in the Backtrace,  Next: Hooks Related to Breakpoints,  Prev: Accessing Past Debugger States,  Up: Advanced Debugging

5.6.9 Storing User Information  in the Backtrace
------------------------------------------------

The debugger allows the user to store some private information in the
backtrace. It allocates a Prolog variable in each break level and in
each invocation. The breakpoint test `private(PRIV)' unifies PRIV with
the private information associated with the break level, while the test
`goal_private(GPRIV)' unifies GPRIV with the Prolog variable stored in
the invocation.

   Both variables are initially unbound, and behave as if they were
passed around the program being debugged in additional arguments. This
implies that any variable assignments done within these variables are
undone on backtracking.

   In practice, the `private' condition gives you access to a Prolog
variable shared by all invocations of a break level. This makes it
possible to remember a term and look at it later, in a possibly more
instantiated form, as shown by the following example.

     memory(Term) :-
             execution_state(private(P)),
             memberchk(myterm(Term), P).

     | ?- trace, append([1,2,3,4], [5,6], L).
             1      1 Call: append([1,2,3,4],[5,6],_514) ? @
     | :- append(_,_,L)^memory(L).
             1      1 Call: append([1,2,3,4],[5,6],_514) ? c
             2      2 Call: append([2,3,4],[5,6],_2064) ? c
             3      3 Call: append([3,4],[5,6],_2422) ? c
             4      4 Call: append([4],[5,6],_2780) ? @
     | :- memory(L), write(L), nl.
     [1,2,3|_2780]
             4      4 Call: append([4],[5,6],_2780) ?

   The predicate `memory/1' receives the term to be remembered in its
argument. It gets hold of the private field associated with the break
level in variable `P', and calls `memberchk/2' (*note lib-lists::),
with the term to be remembered, wrapped in `myterm', as the list
element, and the private field, as the list.  Thus the latter,
initially unbound variable, is used as an open-ended list.  For
example, when `memory/1' is called for the first time, the private
field gets instantiated to `[myterm(Term)|_]'.  If later you call
`memory/1' with an uninstantiated argument, it will retrieve the term
remembered earlier and unify it with the argument.

   The above trace excerpt shows how this utility predicate can be used
to remember an interesting Prolog term. Within invocation number 1 we
call `memory/1' with the third, output argument of `append/3', using
the `@' command (*note Debug Commands::). A few tracing steps later, we
retrieve the term remembered and print it, showing its current
instantiation. Being able to access the instantiation status of some
terms of interest can be very useful in debugging. In
`library(debugger_examples)' we describe new debugger commands for
naming Prolog variables and providing name-based access to these
variables, based on the above technique.

   We could have avoided the use of `memberchk/2' in the example by
simply storing the term to be remembered in the private field itself
(`memory(Term) :- execution_state(private(Term)).'). But this would
have made the private field unusable for other purposes. For example,
the finite domain constraint debugger (*note lib-fdbg::) would stop
working, as it relies on the private fields.

   There is only a single private variable of both kinds within the
given scope. Therefore the convention of using an open ended list for
storing information in private fields, as shown in the above example,
is very much recommended. The different users of the private field are
distinguished by the wrapper they use (e.g. `myterm/1' above, `fdbg/1'
for the constraint debugger, etc.). Future SICStus Prolog releases may
enforce this convention by providing appropriate breakpoint tests.

   We now present an example of using the goal private field. Earlier
we have shown a spypoint definition that made a predicate invisible in
the sense that its ports are silently passed through and it is
automatically skipped over. However, with that earlier solution,
execution always continues in trace mode after skipping. We now improve
the spypoint definition: the mode in which the Call port was reached is
remembered in the goal private field, and the mode action variable is
reset to this value at the Exit port.

     mode_memory(Mode) :-
             execution_state(goal_private(GP)),
             memberchk(mymode(Mode), GP).

     | ?- spy(foo/2, -[silent,proceed,
                      true(mode_memory(MM)),
                     (   call -> get(mode(MM)), inv(Inv), skip(Inv)
                     ;   exit -> mode(MM)
                     ;   true
                     )]).

   Here, we first define an auxiliary predicate `mode_memory/1', which
uses the open list convention for storing information in the goal
private field, applying the `mymode/1' wrapper. We then create a
spypoint for `foo/2', whose action part first sets the `print' and
`command' action variables. Next, the `mode_memory/1' predicate is
called, unifying the mode memory with the `MM' variable. We then branch
in the action part: at Call ports the uninstantiated `MM' is unified
with the current mode, and a `skip' command is issued. At Exit ports
`MM' holds the mode saved at the Call port, so the `mode(MM)' action
re-activates this mode. At all other ports we just silently proceed
without changing the debugger mode.


File: sicstus.info,  Node: Hooks Related to Breakpoints,  Next: Programming Breakpoints,  Prev: Storing User Information in the Backtrace,  Up: Advanced Debugging

5.6.10 Hooks Related to Breakpoints
-----------------------------------

There are two hooks related to breakpoints.

   The hook `breakpoint_expansion(MACRO,BODY)' makes it possible for
the user to extend the set of allowed conditions. This hook is called,
at breakpoint addition time, with each simple test or action within the
breakpoint spec, as the MACRO argument. If the hook succeeds, the term
returned in the BODY argument is substituted for the original test or
action.  Note that BODY can not span both the test and the action part,
i.e. it cannot contain the `- /2' operator. The whole BODY will be
interpreted either as a test or as an action, depending on the context
of the original condition.

   We now give a few examples for breakpoint macros. The last example
defines a condition making a predicate invisible, a reformulation of
the last example of the previous subsection.

     :- multifile user:breakpoint_expansion/2.
     user:breakpoint_expansion(
                 skip, [inv(I),skip(I)]).

     user:breakpoint_expansion(
                 gpriv(Value),
                 [goal_private(GP),true(memberchk(Value,GP))]).

     user:breakpoint_expansion(
                 invisible,
                 [silent,proceed,
                     (   call -> get(mode(M)), gpriv(mymode(M)), skip
                     ;   exit -> gpriv(mymode(MM)), mode(MM)
                     ;   true
                     )]).

     | ?- spy(foo/2, -invisible).

   We first define the `skip' macro, instructing the debugger to skip
the current invocation.  This macro is only meaningful in the action
part.

   The second clause defines the `gpriv/2' macro, a generalization of
the earlier `mode_memory/1' predicate. For example, `gpriv(mymode(M))'
expands to `goal_private(GP),true(memberchk(mymode(M),GP))'. This
embodies the convention of using open-ended lists for the goal private
field.

   Finally, the last clause implements the action macro `invisible/0',
which makes the predicate in question disappear from the trace. The
last line shows how this macro can be used to make `foo/2' invisible.

   Below is an alternative implementation of the same macro. Here we
use a Prolog predicate that returns the list of action variable settings
to be applied at the given port. Notice that a variable can be used as
a breakpoint condition, as long as this variable gets instantiated to a
(simple or composite) breakpoint condition by the time it is reached in
the process of breakpoint evaluation.

     user:breakpoint_expansion(invisible,
                               [true(invisible(Settings)),Settings]).

     invisible([proceed,silent,NewMode]) :-
             execution_state([mode(M),port(P),inv(Inv),goal_private(GP)]),
             memberchk(mymode(MM), GP),
             (   P == call -> MM = M, NewMode = skip(Inv)
             ;   P = exit(_) -> NewMode = MM
             ;   NewMode = M
             ).

   The second hook related to breakpoints is
`debugger_command_hook(DCOMMAND, ACTIONS)'. This hook serves for
customizing the behavior of the interactive debugger, i.e. for
introducing new interactive debugger commands. The hook is called for
each debugger command read in by the debugger. DCOMMAND contains the
abstract format of the debugger command read in, as returned by the
query facility (*note Query Processing::). If the hook succeeds, it
should return in ACTIONS an action part to be evaluated as the result
of the command.

   If you want to redefine an existing debugger command, you should
study `library('SU_messages')' to learn the abstract format of this
command, as returned by the query facility. If you want to add a new
command, it suffices to know that unrecognized debugger commands are
returned as `unknown(Line,Warning)'. Here, `Line' is the code-list
typed in, with any leading layout removed, and `Warning' is a warning
message.

   The following example defines the `S' interactive debugger command
to behave as skip at Call and Redo ports, and as creep otherwise:

     :- multifile user:debugger_command_hook/2.
     user:debugger_command_hook(unknown([0'S|_],_), Actions) :-
             execution_state([port(P),inv(I)]),
             Actions = [Mode,proceed,silent],
             (   P = call -> Mode = skip(I)
             ;   P = redo -> Mode = skip(I)
             ;   Mode = trace
             ).

   Note that the `silent' action is needed above; otherwise, the trace
message will be printed a second time, before continuing the execution.

   `library(debugger_examples)' contains some of the above hooks, as
well as several others.


File: sicstus.info,  Node: Programming Breakpoints,  Prev: Hooks Related to Breakpoints,  Up: Advanced Debugging

5.6.11 Programming Breakpoints
------------------------------

We will show two examples using the advanced features of the debugger.

   The first example defines a `hide_exit(Pred)' predicate, which will
hide the Exit port for `Pred' (i.e. it will silently proceed), provided
the current goal was already ground at the Call port, and nothing was
traced inside the given invocation. The `hide_exit(Pred)' goal creates
two spypoints for predicate `Pred':

     :- meta_predicate hide_exit(:).
     hide_exit(Pred) :-
             add_breakpoint([pred(Pred),call]-
                              true(save_groundness), _),
             add_breakpoint([pred(Pred),exit,true(hide_exit)]-hide, _).

   The first spypoint is applicable at the Call port, and it calls
`save_groundness' to check if the given invocation was ground, and if
so, it stores a term `hide_exit(ground)' in the `goal_private'
attribute of the invocation.

     save_groundness :-
             execution_state([goal(_:G),goal_private(Priv)]),
             ground(G), !, memberchk(hide_exit(ground), Priv).
     save_groundness.

   The second spypoint created by `hide_exit/1' is applicable at the
Exit port and it checks whether the `hide_exit/0' condition is true. If
so, it issues a `hide' action, which is a breakpoint macro expanding to
`[silent,proceed]'.

     hide_exit :-
             execution_state([inv(I),max_inv(I),goal_private(Priv)]),
             memberchk(hide_exit(Ground), Priv), Ground == ground.

   Here, `hide_exit' encapsulates the tests that the invocation number
be the same as the last invocation number used (`max_inv'), and that
the `goal_private' attribute of the invocation be identical to
`ground'. The first test ensures that nothing was traced inside the
current invocation.

   If we load the above code, as well as the small example below, the
following interaction, discussed below, can take place. Note that the
`hide_exit' predicate is called with the `_:_' argument, resulting in
generic spypoints being created.

     | ?- consult(user).
     | cnt(0) :- !.
     | cnt(N) :-
             N > 0, N1 is N-1, cnt(N1).
     | ^D
     % consulted user in module user, 0 msec 424 bytes

     | ?- hide_exit(_:_), trace, cnt(1).
     % The debugger will first zip -- showing spypoints (zip)
     % Generic spypoint added, BID=1
     % Generic spypoint added, BID=2
     % The debugger will first creep -- showing everything (trace)
      #      1      1 Call: cnt(1) ? c
      #      2      2 Call: 1>0 ? c
      #      3      2 Call: _2019 is 1-1 ? c
             3      2 Exit: 0 is 1-1 ? c
      #      4      2 Call: cnt(0) ? c
             1      1 Exit: cnt(1) ? c

     % trace
     | ?-

   Invocation 1 is ground, its Exit port is not hidden, because further
goals were traced inside it. On the other hand, Exit ports of ground
invocations 2 and 4 are hidden.

   Our second example defines a predicate `call_backtrace(Goal,
BTrace)', which will execute `Goal' and build a backtrace showing the
successful invocations executed during the solution of `Goal'.

   The advantages of such a special backtrace over the one incorporated
in the debugger are the following:

   * it has much lower space consumption;

   * the user can control what is put on and removed from the backtrace
     (e.g. in this example all goals are kept, even the ones that
     exited determinately);

   * the interactive debugger can be switched on and off without
     affecting the "private" backtrace being built.

   The `call_backtrace/2' predicate is based on the advice facility.
It uses the variable accessible via the `private(_)' condition to store
a mutable (*note ref-lte-mut::) holding the backtrace. Outside the
`call_backtrace' predicate the mutable will have the value `off'.

   The example is a module-file, so that internal invocations can be
identified by the module name. We load the `lists' library, because
`memberchk/2' will be used in the handling of the private field.

     :- module(backtrace, [call_backtrace/2]).
     :- use_module(library(lists)).

     :- meta_predicate call_backtrace(:, ?).
     call_backtrace(Goal, BTrace) :-
             Spec = [advice,call]
                    -[true((goal(M:G),store_goal(M,G))),flit],
             (   current_breakpoint(Spec, _, on, _, _) -> B = []
             ;   add_breakpoint(Spec, B)
             ),
             call_cleanup(call_backtrace1(Goal, BTrace),
                          remove_breakpoints(B)).

   `call_backtrace(Goal, BTrace)' is a meta-predicate, which first sets
up an appropriate advice-point for building the backtrace. The
advice-point will be activated at each Call port and will call the
`store_goal/2' predicate with arguments containing the module and the
goal in question. Note that the advice-point will not build a procedure
box (cf. the `flit' command in the action part).

   The advice-point will be added just once: any further (recursive)
calls to `call_backtrace/2' will notice the existence of the breakpoint
and will skip the `add_breakpoint/2' call.

   Having ensured the appropriate advice-point exists,
`call_backtrace/2' calls `call_backtrace1/2' with a cleanup operation
that removes the breakpoint added, if any.

     :- meta_predicate call_backtrace1(:, ?).
     call_backtrace1(Goal, BTrace) :-
             execution_state(private(Priv)),
             memberchk(backtrace_mutable(Mut), Priv),
             (   mutable(Mut) -> get_mutable(Old, Mut),
                 update_mutable([], Mut)
             ;   create_mutable([], Mut), Old = off
             ),
             call(Goal),
             get_mutable(BTrace, Mut), update_mutable(Old, Mut).

   The predicate `call_backtrace1/2' retrieves the private field of the
execution state and uses it to store a mutable, wrapped in
`backtrace_mutable'. When first called within a top-level the mutable
is created with the value `[]'. In later calls the mutable is
re-initialized to `[]'. Having set up the mutable, `Goal' is called. In
the course of the execution of the `Goal' the debugger will accumulate
the backtrace in the mutable. Finally, the mutable is read, its value
is returned in `BTrace', and it is restored to its old value (or `off').

     store_goal(M, G) :-
             M \== backtrace,
             G \= call(_),
             execution_state(private(Priv)),
             memberchk(backtrace_mutable(Mut), Priv),
             mutable(Mut),
             get_mutable(BTrace, Mut),
             BTrace \== off, !,
             update_mutable([M:G|BTrace], Mut).
     store_goal(_, _).

   `store_goal/2' is the predicate called by the advice-point, with the
module and the goal as arguments. We first ensure that calls from
within the `backtrace' module and those of `call/1' get ignored. Next,
the module qualified goal term is prepended to the mutable value
retrieved from the private field, provided the mutable exists and its
value is not `off'.

   Below is an example run, using a small program:

     | ?- consult(user).
     | cnt(N):- N =< 0, !.
     | cnt(N) :-
          N > 0, N1 is N-1, cnt(N1).
     | ^D
     % consulted user in module user, 0 msec 424 bytes

     | ?- call_backtrace(cnt(1), B).
     % Generic advice point added, BID=1
     % Generic advice point, BID=1, removed (last)

     B = [user:(0=<0),user:cnt(0),user:(0 is 1-1),user:(1>0),user:cnt(1)]

     | ?-

   Note that the backtrace produced by `call_backtrace/2' can not
contain any information regarding failed branches.  For example, the
very first invocation within the above execution, `1 =< 0', is first
put on the backtrace at its Call port, but this is immediately undone
because the goal fails. If you would like to build a backtrace that
preserves failed branches, you have to use side-effects, e.g. dynamic
predicates.

   Further examples of complex breakpoint handling are contained in
`library(debugger_examples)'.

   This concludes the tutorial introduction of the advanced debugger
features.


File: sicstus.info,  Node: Breakpoint Predicates,  Next: Breakpoint Processing,  Prev: Advanced Debugging,  Up: Debug Intro

5.7 Breakpoint Handling Predicates
==================================

This section describes the advanced built-in predicates for creating
and removing breakpoints.

`add_breakpoint(:SPEC, ?BID)  "development"'
     Adds a breakpoint with a spec SPEC, the breakpoint identifier
     assigned is unified with BID.  SPEC is one of the following:

    TESTS`-'ACTIONS

    TESTS
          standing for TESTS`-[]'

    `-'ACTIONS
          standing for `[]-'ACTIONS

     Here, both TESTS and ACTIONS are either a simple CONDITION, *note
     Breakpoint Conditions::, or a composite Condition. Conditions can
     be composed by forming lists, or by using the `,', `;', `->', and
     `\+' operators, with the usual meaning of conjunction, disjunction,
     if-then-else, and negation, respectively. A list of conditions is
     equivalent to a conjunction of the same conditions (`[A|B]' is
     treated as `(A,B)').

     The `add_breakpoint/2' predicate performs some transformations and
     checks before adding the breakpoint.  All condition macros invoked
     are expanded into their bodies, and this process is repeated for
     the newly introduced bodies. The `goal' and `pred' conditions are
     then extracted from the outermost conjunctions of the _test_ part
     and moved to the beginning of the conjunction. If these are
     inconsistent, a consistency error is signalled. Module name
     expansion is performed for certain tests, as described below.

     Both the original and the transformed breakpoint spec is recorded
     by the debugger. The original is returned in
     `current_breakpoint/5', while the transformed spec is used in
     determining the applicability of breakpoints.

     There can only be a single plain spypoint for each predicate.  If
     a plain spypoint is added, and there is already a plain spypoint
     for the given predicate, then:

       a. the old spypoint is deleted and a new added as the most recent
          breakpoint, if this change affects the breakpoint selection
          mechanism.

       b. otherwise, the old spypoint is kept and enabled if needed.

`spy(:PREDSPEC, :SPEC)  "development"'
     Adds a conditional spypoint with a breakpoint spec formed by
     adding `pred(PRED)' to the test part of SPEC, for each predicate
     PRED designated by the generalized predicate spec PREDSPEC.

`current_breakpoint(:SPEC, ?BID, ?STATUS, ?KIND, ?TYPE)  "development"'
     There is a breakpoint with breakpoint spec SPEC, identifier BID,
     status STATUS, kind KIND, and type TYPE.  STATUS is one of `on' or
     `off', referring to enabled and disabled breakpoints.  KIND is one
     of `plain(MFUNC)', `conditional(MFUNC)' or `generic', where MFUNC
     is the module qualified functor of the specific breakpoint. TYPE
     is the breakpoint type: `debugger' or `advice'.

     `current_breakpoint/5' enumerates all breakpoints on backtracking.

     The SPEC as returned by `current_breakpoint/5' is exactly the same
     as supplied at the creation of the breakpoint,

`remove_breakpoints(+BIDS)  "development"'
`disable_breakpoints(+BIDS)  "development"'
`enable_breakpoints(+BIDS)  "development"'
     Removes, disables or enables the breakpoints with identifiers
     specified by BIDS. BIDS can be a number, a list of numbers or one
     of the atoms: `all', `debugger', `advice'. The atoms specify all
     breakpoints, debugger type breakpoints and advice type
     breakpoints, respectively.

`execution_state(:TESTS)  "development"'
     TESTS are satisfied in the current state of the execution.
     Arbitrary tests can be used in this predicate, if it is called
     from inside the debugger, i.e. from within a `true' condition.
     Otherwise only those tests can be used, which query the data
     stored in the backtrace. An exception is raised if the latter
     condition is violated, i.e. a non-backtraced test (*note
     Breakpoint Conditions::) occurs in a call of `execution_state/1'
     from outside the debugger.

`execution_state(+FOCUSCONDITIONS, :TESTS)  "development"'
     TESTS are satisfied in the state of the execution pointed to by
     FOCUSCONDITIONS (*note Past States::). An exception is raised if
     there is a non-backtraced test among TESTS.

   Note that the predicate arguments holding a breakpoint spec (SPEC or
TESTS above) are subject to module name expansion.  The first argument
within simple tests `goal(_)', `pred(_)', `parent_pred(_)',
`parent_pred(_,_)', `ancestor(_,_)', and `true(_)' will inherit the
module name from the (module name expanded) breakpoint spec/tests
predicate argument, if there is no explicit module qualification within
the simple test. Within the `proceed(OLD,NEW)' and `flit(OLD,NEW)'
command value settings, OLD will get the module name from the `goal' or
`pred' condition by default, while NEW from the whole breakpoint spec
argument.

   The following hook predicate can be used to customize the behavior
of the interactive debugger.

`debugger_command_hook(+DCOMMAND,?ACTIONS)  "hook,development"'
`user:debugger_command_hook(+DCOMMAND,?ACTIONS)'
     This predicate is called for each debugger command SICStus Prolog
     reads in. The first argument is the abstract format of the
     debugger command DCOMMAND, as returned by the query facility
     (*note Query Processing::). If it succeeds, ACTIONS is taken as
     the list of actions (*note Action Conditions::) to be done for the
     given debugger command. If it fails, the debugger command is
     interpreted in the standard way.

     Note that if a line typed in in response to the debugger prompt
     can not be parsed as a debugger command, `debugger_command_hook/2'
     is called with the term `unknown(Line,Warning)'. Here, `Line' is
     the code-list typed in, with any leading layout removed, and
     `Warning' is a warning message. This allows the user to define new
     debugger commands, *note Hooks Related to Breakpoints:: for an
     example.


File: sicstus.info,  Node: Breakpoint Processing,  Next: Breakpoint Conditions,  Prev: Breakpoint Predicates,  Up: Debug Intro

5.8 The Processing of Breakpoints
=================================

This section describes in detail how the debugger handles the
breakpoints. For the purpose of this section disabled breakpoints are
not taken into account: whenever we refer to the existence of some
breakpoint(s), we always mean the existence of _enabled_ breakpoint(s).

   The Prolog engine can be in one of the following three states with
respect to the debugger:

_no debugging_
     if there are no advice-points and the debugger is either switched
     off, or doing a skip;

_full debugging_
     if the debugger is in trace or debug mode (creeping or leaping), or
     there are any generic breakpoints;

_selective debugging_
     in all other cases.

   In the _selective debugging_ state only those predicate invocations
are examined, for which there exists a specific breakpoint. In the
_full debugging_ state all invocations are examined, except those
calling a predicate of a hidden module (but even these will be
examined, if there is a specific breakpoint for them). In the _no
debugging_ state the debugger is not entered at predicate invocations.

   Now we describe what the debugger does when examining an invocation
of a predicate, i.e. executing its Call port. The debugger activities
can be divided into three stages: advice-point processing, spypoint
processing and interaction with the user. The last stage may be
repeated several times before program execution continues.

   The first two stages are similar, as they both search for an
applicable breakpoint (spypoint or advice-point). This common
breakpoint search is carried out as follows. The debugger considers all
breakpoints of the given type, most recent first. For each breakpoint,
the test part of the spec is evaluated, until one successful is found.
Any variable bindings created in this successful evaluation are then
discarded (this is implemented by enclosing it in double negation).
The first breakpoint, for which the evaluation of the test part
succeeds is selected. If such a breakpoint can be found, the breakpoint
search is said to have completed successfully, otherwise it is said to
have failed.

   If a breakpoint has been selected, its action part is evaluated,
normally setting some debugger action variables. If the action part
fails, as a side-effect, it is ensured that a procedure box will be
built. This is achieved by changing the value of the `command' action
variable from `flit' to `proceed'.

   Having described the common breakpoint search, let us look at the
details of the first stage, advice-point processing. This stage is
executed only if there are any advice-points set. First, the debugger
action variables are initialized: `mode' is set to the current debugger
mode, `command' to `proceed' and `show' to `silent'. Next, advice-point
search takes place.  If this fails, `command' is set to `flit',
otherwise its value is unchanged.

   After completing the advice-point search the `command' variable is
examined. If its value is divertive, i.e. different from `proceed' and
`flit', the spypoint search stage is omitted, and the debugger
continues with the third stage. Otherwise, it is noted that the
advice-point processing has requested the building of a procedure box
(i.e. `command = proceed'), and the debugger continues with the second
stage.

   The second stage is spypoint processing. This stage is skipped if
the debugger is switched off or doing a skip (`mode' is `off' or
`skip(_)'). First the the `show' and `command' variables are
re-assigned, based on the hiddenness of the predicate being invoked,
the debugger mode, and the leashing status of the port. If the
predicate is both defined in, and called from a hidden module, their
values will be `silent' and `flit'. An example of this is when a
built-in predicate is called from a hidden module, e.g.  from a
library. Otherwise, in trace mode, their values are `print' and `ask'
for leashed ports, and `print' and `proceed' for unleashed ports. In
debug mode, the variables are set to `silent' and `proceed', while in
zip mode to `silent' and `flit' (*Note Breakpoint Actions:: contains a
tabulated listing of these initialization values).

   Having initialized the debugger action variables, the spypoint
search phase is performed.  If an empty action part has been selected in
a successful search, `show' and `command' are set to `print' and `ask'.
The failure of the search is ignored.

   The third stage is the interactive part. First, the goal in question
is displayed according to the value of `show'. Next, the value of
`command' is checked: if it is other than `ask', the interactive stage
ends. Otherwise, (it is `ask'), the variable `show' is re-initialized
to `print', or to `print-SEL', if its value was of form `METHOD-SEL'.
Next, the debugger prompts the user for a command, which is interpreted
either in the standard way, or through `user:debugger_command_hook/2'.
In both cases the debugger action variables are modified as requested,
and the interactive part is repeated.

   After the debugger went through all the three stages, it decides
whether to build a procedure box. This will happen if either the
advice-point stage or the other two stages require it. The latter is
decided by checking the `command' variable: if that is `flit' or
`flit(OLD,NEW)', no procedure box is required by the spypoint part.  If
the advice-point does require the building of a procedure box, the above
`command' values are replaced by `proceed' and `proceed(OLD,NEW)',
respectively.

   At the end of the process the value of `mode' will be the new
debugging mode, and `command' will determine what the debugger will do;
*note Action Variables::.

   A similar three-stage process is carried out when the debugger
arrives at a non-Call port of a predicate. The only difference is that
the building of a procedure box is not considered (`flit' is equivalent
to `proceed'), and the hiddenness of the predicate is not taken into
account.

   While the Prolog system is executing the above three-stage process
for any of the ports, it is said to be _inside the debugger_. This is
relevant, because some of the conditions can only be evaluated in this
context.

