This is info/sicstus.info, produced by makeinfo version 4.8 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 6 November 2007.


File: sicstus.info,  Node: Combinatorial Constraints,  Next: User-Defined Constraints,  Prev: Propositional Constraints,  Up: Available Constraints

10.34.3.4 Combinatorial Constraints
...................................

The constraints listed here are sometimes called symbolic constraints.
They are currently not reifiable.  Unless documented otherwise, they
maintain (at most) bound-consistency in their arguments; *note The
Constraint System::.

`global_cardinality(+XS,+VALS)'
`global_cardinality(+XS,+VALS,+OPTIONS)'
     where XS = [X_1,\ldots,X_d] is a list of integers or domain
     variables, and VALS = [K_1-V_1,\ldots,K_n-V_n] is a list of pairs
     where each key K_i is a unique integer and V_i is a domain
     variable or an integer.  True if every element of XS is equal to
     some key and for each pair K_i-V_i, exactly V_i elements of XS are
     equal to K_i.

     If either XS or VALS is ground, and in many other special cases,
     `global_cardinality/[2,3]' maintains arc-consistency, but
     generally, bound-consistency cannot be guaranteed.  An
     arc-consistency algorithm [Regin 96] is used, roughly linear in
     the total size of the domains.

     OPTIONS is a list of zero or more of the following:

    `consistency(CONS)'
          Which filtering algorithm to use.  One of the following:
         `domain'
               The constraint will use the algorithm mentioned above.
               Implies `on(dom)'.  The default.

         `bound'
               The constraint will use the algorithm mentioned above.
               Implies `on(minmax)'.

         `value'
               The constraint will use a simple algorithm, which
               prevents too few or too many of the XS from taking
               values among the VALS.  Implies `on(val)'.

    `on(ON)'
          How eagerly to wake up the constraint.  One of the following:
         `dom'
               to wake up when the domain of a variable is changed (the
               default);

         `minmax'
               to wake up when the domain bound of a variable is
               changed;

         `val'
               to wake up when a variable becomes ground.

    `cost(COST,MATRIX)'
          Overrides any `consistency/1' option value.  A cost is
          associated with the constraint and reflected into the domain
          variable COST.  MATRIX should be a d\times n matrix,
          represented as a list of d lists, each of length n.  Assume
          that each X_i equals K_(p_i).  The cost of the constraint is
          then \Matrix[1,p_1]+\cdots+\Matrix[d,p_d].

          With this option, an arc-consistency algorithm [Regin 99] is
          used, the complexity of which is roughly O(d(m + n \log n))
          where m is the total size of the domains.

`element(?X,+LIST,?Y)'
     where X and Y are integers or domain variables and LIST is a list
     of integers or domain variables.  True if the X:th element of LIST
     is Y.  Operationally, the domains of X and Y are constrained so
     that for every element in the domain of X, there is a compatible
     element in the domain of Y, and vice versa.

     Maintains arc-consistency in X and bound-consistency in LIST and Y.
     Corresponds to `nth1/3' in `library(lists)'.

`table(+TUPLES,+EXTENSION)'
`table(+TUPLES,+EXTENSION,+OPTIONS)'
     Defines an n-ary constraint by extension.  EXTENSION should be a
     list of lists of integers, each of length N.  TUPLES should be a
     list of lists of domain variables or integers, each also of length
     N.  The constraint holds if every TUPLE in TUPLES occurs in the
     EXTENSION.

     For convenience, EXTENSION may contain CONSTANTRANGE (*note Syntax
     of Indexicals::) expressions in addition to integers.

     OPTIONS is a list of zero or more of the following.  It can be
     used to control the waking and pruning conditions of the
     constraint:

    `consistency(CONS)'
          The value is one of the following:
         `domain'
               The constraint will maintain arc-consistency (the
               default).

         `bound'
               The constraint will maintain bound-consistency.

         `value'
               The constraint will wake up when a variable has become
               ground, and only prune a variables when its domain has
               been reduced to a singleton.

     `table/[2,3]' is implemented in terms of the following, more
     general constraint, with which arbitrary relations can be defined
     compactly:

`case(+TEMPLATE, +TUPLES, +DAG)'
`case(+TEMPLATE, +TUPLES, +DAG, +OPTIONS)'
     TEMPLATE is an arbitrary non-ground Prolog term.  Its variables
     are merely place-holders; they should not occur outside the
     constraint nor inside TUPLES.

     TUPLES is a list of terms of the same shape as TEMPLATE.  They
     should not share any variables with TEMPLATE.

     DAG is a list of "nodes" of the form `node(ID,X,SUCCESSORS)',
     where X is a place-holder variable.  The set of all X should equal
     the set of variables in TEMPLATE.  The first node in the list is
     the "root node".  Let ROOTID denote its ID.

     Nodes are either INTERNAL NODES or LEAF NODES.  In the former
     case, SUCCESSORS is a list of terms `(MIN..MAX)-ID2', where the
     ID2 refers to a child node.  In the latter case, SUCCESSORS is a
     list of terms `(MIN..MAX)'.  In both cases, the `(MIN..MAX)'
     should form disjoint intervals.

     ID is a unique, integer identifier of a node.

     Each path from the root node to a leaf node corresponds to one set
     of tuples admitted by the relation expressed by the constraint.
     Each variable in TEMPLATE should occur exactly once on each path,
     and there must not be any cycles.

     OPTIONS is a list of zero or more of the following.  It can be
     used to control the waking and pruning conditions of the
     constraint, as well as to identify the leaf nodes reached by the
     tuples:

    `leaves(TLEAF,LEAVES)'
          TLEAF is a place-holder variable.  LEAVES is a list of
          variables of the same length as TUPLES.  This option
          effectively extends the relation by one argument,
          corresponding to the ID of the leaf node reached by a
          particular tuple.

    `on(SPEC)'
          Specifies how eagerly the constraint should react to domain
          changes of X.

    `prune(SPEC)'
          Specifies the extent to which the constraint should prune the
          domain of X.

     SPEC is one of the following, where X is a place-holder variable
     occurring in TEMPLATE or equal to TLEAF:

    `dom(X)'
          wake up when the domain of X has changed, resp.  perform full
          pruning on X.  This is the default for all variables
          mentioned in the constraint.

    `min(X)'
          wake up when the lower bound of X has changed, resp.  prune
          only the lower bound of X.

    `max(X)'
          wake up when the upper bound of X has changed, resp.  prune
          only the upper bound of X.

    `minmax(X)'
          wake up when the lower or upper bound of X has changed, resp.
          prune only the bounds of X.

    `val(X)'
          wake up when X has become ground, resp.  only prune X when
          its domain has been reduced to a singleton.

    `none(X)'
          ignore domain changes of X, resp. never prune X.

     The constraint holds if PATH(ROOTID,TUPLE,LEAF) holds for each
     TUPLE in TUPLES and LEAF is the corresponding element of LEAVES if
     given (otherwise, LEAF is a free variable).

     PATH(ID,TUPLE,LEAF) holds if DAG contains a term
     `node(ID,VAR,SUCCESSORS)', VAR is the unique K:th element of
     TEMPLATE, I is the K:th element of TUPLE, and:

        * The node is an internal node, and
            1. SUCCESSORS contains a term `(MIN..MAX)-CHILD',

            2. \Min \leq i \leq \Max, and

            3. PATH(CHILD,TUPLE,LEAF) holds; or

        * The node is a leaf node, and
            1. SUCCESSORS contains a term `(MIN..MAX)',

            2. \Min \leq i \leq \Max, and LEAF = ID.

     For example, recall that `element(X,L,Y)' wakes up when the domain
     of X or the lower or upper bound of Y has changed, performs full
     pruning of X, but only prunes the bounds of Y.  The following two
     constraints:

          element(X, [1,1,1,1,2,2,2,2], Y),
          element(X, [10,10,20,20,10,10,30,30], Z)

     can be replaced by the following single constraint, which is
     equivalent declaratively as well as wrt. pruning and waking.  The
     fourth argument illustrates the leaf feature:

          elts(X, Y, Z, L) :-
              case(f(A,B,C), [f(X,Y,Z)],
                   [node(0, A,[(1..2)-1,(3..4)-2,(5..6)-3,(7..8)-4]),
                    node(1, B,[(1..1)-5]),
                    node(2, B,[(1..1)-6]),
                    node(3, B,[(2..2)-5]),
                    node(4, B,[(2..2)-7]),
                    node(5, C,[(10..10)]),
                    node(6, C,[(20..20)]),
                    node(7, C,[(30..30)])],
                   [on(dom(A)),on(minmax(B)),on(minmax(C)),
                    prune(dom(A)),prune(minmax(B)),prune(minmax(C)),
                    leaves(_,[L])]).

     The DAG of the previous example has the following shape:


      [image src="images/clpfd1.png" text="" ]                      DAG corresponding to `elts/4'

     A couple of sample queries:

          | ?- elts(X, Y, Z, L).
          L in 5..7,
          X in 1..8,
          Y in 1..2,
          Z in 10..30

          | ?- elts(X, Y, Z, L), Z #>= 15.
          L in 6..7,
          X in(3..4)\/(7..8),
          Y in 1..2,
          Z in 20..30

          | ?- elts(X, Y, Z, L), Y = 1.
          Y = 1,
          L in 5..6,
          X in 1..4,
          Z in 10..20

          | ?- elts(X, Y, Z, L), L = 5.
          Z = 10,
          X in(1..2)\/(5..6),
          Y in 1..2

`all_different(+VARIABLES)'
`all_different(+VARIABLES, +OPTIONS)'
`all_distinct(+VARIABLES)'
`all_distinct(+VARIABLES, +OPTIONS)'
     where VARIABLES is a list of domain variables or integers.  Each
     variable is constrained to take a value that is unique among the
     variables.  Declaratively, this is equivalent to an inequality
     constraint for each pair of variables.

     OPTIONS is a list of zero or more of the following:

    `consistency(CONS)'
          Which algorithm to use, one of the following:

         `domain'
               The default for `all_distinct/[1,2]' and
               `assignment/[2,3]'.  an arc-consistency algorithm [Regin
               94] is used, roughly linear in the total size of the
               domains.  Implies `on(dom)'.

         `bound'
               a bound-consistency algorithm [Mehlhorn 00] is used.
               This algorithm is nearly linear in the number of
               variables and values.  Implies `on(minmax)'.

         `value'
               The default for `all_different/[1,2]'.  An algorithm
               achieving exactly the same pruning as a set of pairwise
               inequality constraints is used, roughly linear in the
               number of variables.  Implies `on(val)'.

    `on(ON)'
          How eagerly to wake up the constraint.  One of the following:
         `dom'
               (the default for `all_distinct/[1,2]' and
               `assignment/[2,3]'), to wake up when the domain of a
               variable is changed;

         `min'
               to wake up when the lower bound of a domain is changed;

         `max'
               to wake up when the upper bound of a domain is changed;

         `minmax'
               to wake up when some bound of a domain is changed;

         `val'
               (the default for `all_different/[1,2]'), to wake up when
               a variable becomes ground.

`nvalue(?N, +VARIABLES)'
     where VARIABLES is a list of domain variables with finite bounds
     or integers, and N is an integer or a domain variable.  True if N
     is the number of distinct values taken by VARIABLES.  Approximates
     bound-consistency in N and arc-consistency in VARIABLES.  Can be
     thought of as a relaxed version of `all_distinct/2'.

   The following is a constraint over two lists of length n of
variables.  Each variable is constrained to take a value in [1,n] that
is unique for its list.  Furthermore, the lists are dual in a sense
described below.

`assignment(+XS, +YS)'
`assignment(+XS, +YS, +OPTIONS)'
     where XS = [X_1,\ldots,X_n] and YS = [Y_1,\ldots,Y_n] are lists of
     domain variables or integers.  True if all X_i, Y_i \in [1,n] and
     X_i=j \equiv Y_j=i.

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false' (`false' is the default):

    `on(ON)'
          Same meaning as for `all_different/2'.

    `consistency(CONS)'
          Same meaning as for `all_different/2'.

    `circuit(BOOLEAN)'
          If `true', `circuit(XS,YS)' must hold for the constraint to
          be true.

    `cost(COST,MATRIX)'
          A cost is associated with the constraint and reflected into
          the domain variable COST.  MATRIX should be an n\times n
          matrix, represented as a list of lists.  The cost of the
          constraint is \Matrix[1,X_1]+\cdots+\Matrix[n,X_n].

          With this option, an arc-consistency algorithm [Sellmann 02]
          is used, the complexity of which is roughly O(n(m + n \log
          n)) where m is the total size of the domains.

   The following constraint can be thought of as constraining n nodes
in a graph to form a Hamiltonian circuit.  The nodes are numbered from
1 to n.  The circuit starts in node 1, visits each node, and returns to
the origin.

`circuit(+SUCC)'
`circuit(+SUCC, +PRED)'
     where SUCC is a list of length n of domain variables or integers.
     The i:th element of SUCC (PRED) is the successor (predecessor) of
     i in the graph.  True if the values form a Hamiltonian circuit.

   The following constraint can be thought of as constraining n tasks
so that the total resource consumption does not exceed a given limit at
any time:

`cumulative(+TASKS)'
`cumulative(+TASKS,+OPTIONS)'
     A task is represented by a term `task(O_i,D_i,E_i,H_i,T_i)' where
     O_i is the start time, D_i the non-negative duration, E_i the end
     time, H_i the non-negative resource consumption, and T_i the task
     identifier.  All fields are domain variables with bounded domains,
     or integers.

     Let L be a global resource limit (by default 1, but see below),
     and:

          A = min(S1,...,SN),
          B = max(S1+D1,...,SN+DN)
          RIJ = RJ, if SJ =< I < SJ+DJ
          RIJ = 0 otherwise

     The constraint holds if:

       1. For every task i, SI+DI=EI.

       2.      RI1+...+RIN =< L, for all A =< I < B

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false' (`false' is the default, except for the
     `bounds_only' option):

    `limit(L)'
          See above.

    `precedences(PS)'
          PS encodes a set of precedence constraints to apply to the
          tasks.  PS should be a list of terms of the form

               `TI-TJ #= DIJ'

          where TI and TJ should be task identifiers, and DIJ should be
          a a domain variable (or an integer), denoting:

               S_i-S_j = D_ij \land D_ij \in r

    `global(BOOLEAN)'
          if `true', a more expensive algorithm will be used in order to
          achieve tighter pruning of the bounds of the parameters.

     This constraint is due to Aggoun and Beldiceanu [Aggoun &
     Beldiceanu 93].


   The following constraint can be thought of as constraining N tasks
to be placed in time and on M machines.  Each machine has a resource
limit, which is interpreted as a lower or upper bound on the total
amount of resource used on that machine at any point in time that
intersects with some task.

`cumulatives(+TASKS,+MACHINES)'
`cumulatives(+TASKS,+MACHINES,+OPTIONS)'
     A task is represented by a term `task(O_i,D_i,E_i,H_i,M_i)' where
     O_i is the start time, D_i the duration, E_i the end time, H_i the
     resource consumption, and M_i a machine identifier.

     A machine is represented by a term `machine(M_j,L_j)' where M_j is
     the identifier and L_j is the resource limit of the machine.

     All fields are domain variables with bounded domains, or integers.
     L_j must be an integer.  D_i must be non-negative, but H_i may be
     either positive or negative.  Negative resource consumption is
     interpreted as resource production.

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false' (`false' is the default):

    `bound(B)'
          If `lower' (the default), each resource limit is treated as a
          lower bound.  If `upper', each resource limit is treated as
          an upper bound.

    `prune(P)'
          If `all' (the default), the constraint will try to prune as
          many variables as possible.  If `next', only variables that
          occur in the first non-ground task term (wrt. the order given
          when the constraint was posted) can be pruned.

    `generalization(BOOLEAN)'
          If `true', extra reasoning based on assumptions on machine
          assignment will be done to infer more.

    `task_intervals(BOOLEAN)'
          If `true', extra global reasoning will be performed in an
          attempt to infer more.

   The following constraint captures the relation between a list of
values, a list of the values in ascending order, and their positions in
the original list:

`sorting(+XS,+PS,+YS)'
     where XS = [X_1,\ldots,X_n], PS = [P_1,\ldots,P_n], and YS =
     [Y_1,\ldots,Y_n] are lists of domain variables or integers.  The
     constraint holds if the following are true:

        * YS is in ascending order.

        * PS is a permutation of [1,n].

        * \forall i \in [1,n] : X_i = Y_(P_i)

     In practice, the underlying algorithm [Mehlhorn 00] is likely to
     achieve bound-consistency, and is guaranteed to do so if PS is
     ground or completely free.

   The following constraints model a set or lines or rectangles,
respectively, so that no pair of objects overlap:

`disjoint1(+LINES)'
`disjoint1(+LINES,+OPTIONS)'
     where LINES is a list of terms F(S_j,D_j) or F(S_j,D_j,T_j), S_j
     and D_j are domain variables with finite bounds or integers
     denoting the origin and length of line j respectively, F is any
     functor, and the optional T_j is an atomic term denoting the type
     of the line.  T_j defaults to 0 (zero).

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false' (`false' is the default):

    `decomposition(BOOLEAN)'
          if `true', an attempt is made to decompose the constraint
          each time it is resumed.

    `global(BOOLEAN)'
          if `true', a redundant algorithm using global reasoning is
          used to achieve more complete pruning.

    `wrap(MIN,MAX)'
          If used, the space in which the lines are placed should be
          thought of as a circle where positions MIN and MAX coincide,
          where MIN and MAX should be integers.  That is, the space
          wraps around.  Furthermore, this option forces the domains of
          the origin variables to be inside [MIN,MAX-1].

    `margin(T_1,T_2,D)'
          This option imposes a minimal distance D between the end
          point of any line of type T_1 and the origin of any line of
          type T_2.  D should be a positive integer or `sup'.  If `sup'
          is used, all lines of type T_2 must be placed before any line
          of type T_1.

          This option interacts with the `wrap/2' option in the sense
          that distances are counted with possible wrap-around, and the
          distance between any end point and origin is always finite.

     The file `library('clpfd/examples/bridge.pl')' contains an example
     where `disjoint1/2' is used for scheduling non-overlapping tasks.

`disjoint2(+RECTANGLES)'
`disjoint2(+RECTANGLES,+OPTIONS)'
     where RECTANGLES is a list of terms
     F(S_(j_1),D_(j_1),S_(j_2),D_(j_2)) or
     F(S_(j_1),D_(j_1),S_(j_2),D_(j_2),T_j), S_(j_1) and D_(j_1) are
     domain variables with finite bounds or integers denoting the
     origin and size of rectangle j in the X dimension, S_(j_2) and
     D_(j_2) are the values for the Y dimension, F is any functor, and
     the optional T_j is an atomic term denoting the type of the
     rectangle.  T_j defaults to 0 (zero).

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false' (`false' is the default):

    `decomposition(BOOLEAN)'
          If `true', an attempt is made to decompose the constraint
          each time it is resumed.

    `global(BOOLEAN)'
          If `true', a redundant algorithm using global reasoning is
          used to achieve more complete pruning.

    `wrap(MIN1,MAX1,MIN2,MAX2)'
          MIN1 and MAX1 should be either integers or the atoms `inf'
          and `sup' respectively.  If they are integers, the space in
          which the rectangles are placed should be thought of as a
          cylinder wrapping around the X dimension where positions MIN1
          and MAX1 coincide.  Furthermore, this option forces the
          domains of the S_(j_1) variables to be inside [MIN1,MAX1-1].

          MIN2 and MAX2 should be either integers or the atoms `inf'
          and `sup' respectively.  If they are integers, the space in
          which the rectangles are placed should be thought of as a
          cylinder wrapping around the Y dimension where positions MIN2
          and MAX2 coincide.  Furthermore, this option forces the
          domains of the S_(j_2) variables to be inside [MIN2,MAX2-1].

          If all four are integers, the space is a toroid wrapping
          around both dimensions.

    `margin(T_1,T_2,D_1,D_2)'
          This option imposes minimal distances D_1 in the X dimension
          and D_2 in the Y dimension between the end point of any
          rectangle of type T_1 and the origin of any rectangle of type
          T_2.  D_1 and D_2 should be positive integers or `sup'.  If
          `sup' is used, all rectangles of type T_2 must be placed
          before any rectangle of type T_1 in the relevant dimension.

          This option interacts with the `wrap/4' option in the sense
          that distances are counted with possible wrap-around, and the
          distance between any end point and origin is always finite.

    `synchronization(BOOLEAN)'
          Let the "assignment dimension" and the "temporal dimension"
          denote the two dimensions, no matter which is the X and which
          is the Y dimension.  If BOOLEAN is `true', a redundant
          algorithm is used to achieve more complete pruning for the
          following case:

             * All rectangles have size 1 in the assignment dimension.

             * Some rectangles have the same origin and size in the
               temporal dimension, and that origin is not yet fixed.

          The following example shows an artificial placement problem
          involving 25 rectangles including four groups of rectangles
          whose left and right borders must be aligned.  If `Synch' is
          `true', it can be solved with first-fail labeling in 23
          backtracks.  If `Synch' is `false', 60 million backtracks do
          not suffice to solve it.

               ex([O1,Y1a,Y1b,Y1c,
                   O2,Y2a,Y2b,Y2c,Y2d,
                   O3,Y3a,Y3b,Y3c,Y3d,
                   O4,Y4a,Y4b,Y4c],
                  Synch) :-
                       domain([Y1a,Y1b,Y1c,
                               Y2a,Y2b,Y2c,Y2d,
                               Y3a,Y3b,Y3c,Y3d,
                               Y4a,Y4b,Y4c], 1, 5),
                       O1 in 1..28,
                       O2 in 1..26,
                       O3 in 1..22,
                       O4 in 1..25,
                       disjoint2([t(1,1,5,1),    t(20,4,5,1),
                                  t(1,1,4,1),    t(14,4,4,1),
                                  t(1,2,3,1),    t(24,2,3,1),
                                  t(1,2,2,1),    t(21,1,2,1),
                                  t(1,3,1,1),    t(14,2,1,1),
                                  t(O1,3,Y1a,1),
                                  t(O1,3,Y1b,1),
                                  t(O1,3,Y1c,1),
                                  t(O2,5,Y2a,1),
                                  t(O2,5,Y2b,1),
                                  t(O2,5,Y2c,1),
                                  t(O2,5,Y2d,1),
                                  t(O3,9,Y3a,1),
                                  t(O3,9,Y3b,1),
                                  t(O3,9,Y3c,1),
                                  t(O3,9,Y3d,1),
                                  t(O4,6,Y4a,1),
                                  t(O4,6,Y4b,1),
                                  t(O4,6,Y4c,1)],
                                 [synchronization(Synch)]).

     The file `library('clpfd/examples/squares.pl')' contains an
     example where `disjoint2/2' is used for tiling squares.


   The following constraints express the fact that several vectors of
domain variables are in ascending lexicographic order:

`lex_chain(+VECTORS)'
`lex_chain(+VECTORS,+OPTIONS)'
     where VECTORS is a list of vectors (lists) of domain variables
     with finite bounds or integers.  The constraint holds if VECTORS
     are in ascending lexicographic order.

     OPTIONS is a list of zero or more of the following:

    `op(OP)'
          If OP is the atom `#=<' (the default), the constraints holds
          if VECTORS are in non-descending lexicographic order.  If OP
          is the atom `#<', the constraints holds if VECTORS are in
          strictly ascending lexicographic order.

    `increasing'
          This option imposes the additional constraint that each
          vector in VECTORS be sorted in strictly ascending order.

    `among(LEAST,MOST,VALUES)'
          If given, LEAST and MOST should be integers such that 0 \leq
          \Least \leq \Most and VALUES should be a list of distinct
          integers.  This option imposes the additional constraint on
          each vector in VECTORS that at least LEAST and at most MOST
          elements belong to VALUES.

     Unless the `increasing/0' or `among/3' options are given, the
     underlying algorithm [Carlsson & Beldiceanu 02] guarantees
     arc-consistency.

   The following constraint provides a general way of defining any
constraint involving sequences whose "checker", i.e. a procedure that
classifies ground instances as solutions or non-solutions, can be
expressed by a finite automaton, extended with counter operations on
its arcs. The point is that it is very much easier to come up with such
a checker that to come up with a filtering algorithm for the constraint
of interest.

`automaton(...)'
     The constraint has the form CTR according to the grammar shown
     below, which describes its abstract syntax.  The arguments are:

    SEQUENCE
          The sequence of terms of interest.

    TEMPLATE
          A template for an item of the sequence.  Only relevant if
          some state transition involving counter arithmetic mentions a
          variable occurring in TEMPLATE, in which case the
          corresponding term in a sequence element will be accessed.

    SIGNATURE
          The "signature" of SEQUENCE.  The automaton is not driven by
          the SEQUENCE itself, but by SIGNATURE, which ranges over an
          alphabet, defined in the following argument.  In addition to
          `automaton/8', you must call a constraint that maps SEQUENCE
          to SIGNATURE.

    NODES
          The nodes of the automaton, classified as source, sink or
          internal.

    ARCS
          The arcs (transitions) of the automaton.  Any transition not
          mentioned is assumed to go to an implicit failure node. An
          arc optionally contains expressions for updated counter
          values; by default, the counters remain unchanged.
          Conditional updates can be specified.

    COUNTERS
          For K counters, a list of K variables.

    INITIAL
          For K counters, a list of K initial values, usually
          instantiated.

    FINAL
          For K counters, a list of K final values, usually
          uninstantiated.

     Abstract syntax:

     CTR           ::= `automaton(SEQUENCE,    
                   TEMPLATE, SIGNATURE,'       
                   `NODES, ARCS, '             
                   `COUNTERS, INITIAL, FINAL)' 

     SEQUENCE      ::= LIST OF TEMPLATE        {all of which of the same
                                               shape}

     TEMPLATE      ::= TERM                    {most general shape of the
                                               SEQUENCE}
                                               {its variables should be
                                               local to CTR}

     SIGNATURE     ::= LIST OF VARIABLE        

     NODES         ::= LIST OF NODESPEC        {all of which of the same
                                               shape}

     NODESPEC      ::= `source(NODE)'          {the initial state}
                   | `sink(NODE)'              {an accept state}

     NODE          ::= ATOMIC                  

     ARCS          ::= LIST OF ARC             {all of which of the same
                                               shape}

     ARC           ::=                         {from node, integer, to
                   `arc(NODE,INTEGER,NODE)'    node}
                   |                           {EXPRS correspond to new
                   `arc(NODE,INTEGER,NODE,EXPRS)'counter values}
                   |                           
                   `arc(NODE,INTEGER,NODE,CONDITIONAL)'

     CONDITIONAL   ::= (COND -> EXPRS)         
                   | (CONDITIONAL ;            
                   CONDITIONAL)                

     EXPRS         ::= LIST OF EXPR            {of same length as
                                               COUNTERS}
                                               {EXPR as defined in *Note
                                               Syntax of Arithmetic
                                               Expressions::}
                                               {over COUNTERS, TEMPLATE
                                               and constants}
                                               {variables occurring in
                                               COUNTERS correspond to old
                                               counter values}
                                               {variables occurring in
                                               TEMPLATE refer to the
                                               current element of
                                               SEQUENCE}

     COND          ::= CONSTRAINT              {over COUNTERS, TEMPLATE
                                               and constants}
                                               {must be reifiable or
                                               `true'}

     COUNTERS      ::= LIST OF VARIABLE        {should be local to CTR}

     INITIAL       ::= LIST OF INTEGER         {of same length as
                                               COUNTERS}

     FINAL         ::= LIST OF VARIABLE        {of same length as
                                               COUNTERS}


     If no counters are used, the arguments COUNTERS, INITIAL and FINAL
     should be `[]'.  The arguments TEMPLATE and SEQUENCE are only
     relevant if some EXPR mentions a variable in TEMPLATE, in which
     case the corresponding position in SEQUENCE will be used at that
     point.

     The constraint holds for a ground instance SEQUENCE if:

        * SIGNATURE is the signature corresponding to SEQUENCE.

        * The finite automaton encoded by NODES and ARCS stops in an
          accept state.

        * Any counter arithmetic on the transitions map their INITIAL
          values to the FINAL values.

     Here is an example.  Suppose that you want to define the predicate
     `inflexion(N,L)' which should hold if L is a list of domain
     variables, and N is the number of times that the sequence order
     switches between strictly increasing and strictly decreasing.  For
     example, the sequence `[1,1,4,8,8,2,7,1]' switches order three
     times.

     Such a constraint is conveniently expressed by a finite automaton
     over the alphabet `[<,=,>]' denoting the order between consecutive
     list elements.  A counter is incremented when the order switches,
     and is mapped to the first argument of the constraint.  The
     automaton could look as follows:


      [image src="images/inflexion2.png" text="" ]                       Automaton for `inflexion/2'

     The following piece of code encodes this using `automaton/8'.  The
     auxiliary predicate `inflexion_signature/2' maps the sequence to a
     signature where the consecutive element order is encoded over the
     alphabet `[0,1,2]'.  We use one counter with initial value 0 and
     final value N (an argument of `inflexion/2').  Two transitions
     increment the counter.  All states are accept states.

          inflexion(N, VARIABLES) :-
                  inflexion_signature(VARIABLES, SIGNATURE),
                  automaton(_, _, SIGNATURE,
                            [source(s),sink(i),sink(j),sink(s)],
                            [arc(s,1,s      ),
                             arc(s,2,i      ),
                             arc(s,0,j      ),
                             arc(i,1,i      ),
                             arc(i,2,i      ),
                             arc(i,0,j,[C+1]),
                             arc(j,1,j      ),
                             arc(j,0,j      ),
                             arc(j,2,i,[C+1])],
                            [C],[0],[N]).

          inflexion_signature([], []).
          inflexion_signature([_], []) :- !.
          inflexion_signature([VAR1,VAR2|VARs], [S|Ss]) :-
                  S in 0..2,
                  VAR1 #> VAR2 #<=> S #= 0,
                  VAR1 #= VAR2 #<=> S #= 1,
                  VAR1 #< VAR2 #<=> S #= 2,
                  inflexion_signature([VAR2|VARs], Ss).

     A couple of queries:

          | ?- inflexion(N, [1,1,4,8,8,2,7,1]).
          N = 3 ? <RET>
          yes

          | ?- length(L,4), domain(L,0,1), inflexion(2,L), labeling([],L).
          L = [0,1,0,1] ? ;
          L = [1,0,1,0] ? ;
          no

     This constraint was introduced in [Beldiceanu, Carlsson & Petit
     04].



File: sicstus.info,  Node: User-Defined Constraints,  Prev: Combinatorial Constraints,  Up: Available Constraints

10.34.3.5 User-Defined Constraints
..................................

New, primitive constraints can be added defined by the user on two
different levels.  On a higher level, constraints can be defined using
the global constraint programming interface; *note Defining Global
Constraints::.  Such constraints can embody specialized algorithms and
use the full power of Prolog.  They cannot be reified.

   On a lower level, new primitive constraints can be defined with
indexicals.  In this case, they take part in the basic constraint
solving algorithm and express custom designed rules for special cases of
the overall local propagation scheme.  Such constraints are called "FD
predicates"; *note Defining Primitive Constraints::.  They can
optionally be reified.  


File: sicstus.info,  Node: Enumeration Predicates,  Next: Statistics Predicates,  Prev: Available Constraints,  Up: lib-clpfd

10.34.4 Enumeration Predicates
------------------------------

As is usually the case with finite domain constraint solvers, this
solver is not "complete".  That is, it does not ensure that the set of
posted constraints is satisfiable.  One must resort to search
(enumeration) to check satisfiability and get particular solutions.

   The following predicates provide several variants of search:

`indomain(?X)'
     where X is a domain variable with a bounded domain or an integer.
     Assigns, in increasing order via backtracking, a feasible value to
     X.

`labeling(:OPTIONS, +VARIABLES)'
     where VARIABLES is a list of domain variables or integers and
     OPTIONS is a list of search options.  The domain variables must
     all have bounded domains.  True if an assignment of the variables
     can be found, which satisfies the posted constraints.

`first_bound(+BB0, -BB)'
`later_bound(+BB0, -BB)'
     Provides an auxiliary service for the `value(ENUM)' option (see
     below).

`minimize(:GOAL,?X)'
`maximize(:GOAL,?X)'
     Uses a branch-and-bound algorithm with restart to find an
     assignment that minimizes (maximizes) the domain variable X.  GOAL
     should be a Prolog goal that constrains X to become assigned, and
     could be a `labeling/2' goal.  The algorithm calls GOAL repeatedly
     with a progressively tighter upper (lower) bound on X until a
     proof of optimality is obtained, at which time GOAL and X are
     unified with values corresponding to the optimal solution.

   The OPTIONS argument of `labeling/2' controls the order in which
variables are selected for assignment (variable choice heuristic), the
way in which choices are made for the selected variable (value choice
heuristic), and whether all solutions or a single, optimal solution
should be found.  The options are divided into four groups.  One option
may be selected per group.  Also, the number of assumptions (choices)
made during the search can be collected.  Finally, a discrepancy limit
can be imposed.

     The following options control the order in which the next variable
     is selected for assignment.

    `leftmost'
          The leftmost variable is selected.  This is the default.

    `min'
          The leftmost variable with the smallest lower bound is
          selected.

    `max'
          The leftmost variable with the greatest upper bound is
          selected.

    `ff'
          The first-fail principle is used: the leftmost variable with
          the smallest domain is selected.

    `ffc'
          The most constrained heuristic is used: a variable with the
          smallest domain is selected, breaking ties by (a) selecting
          the variable that has the most constraints suspended on it
          and (b) selecting the leftmost one.

    `variable(SEL)'
          SEL is a predicate to select the next variable.  Given VARS,
          the variables that remain to label, it will be called as
          SEL(VARS,SELECTED,REST).

          SEL is expected to succeed determinately, unifying SELECTED
          and REST with the selected variable and the remaining list,
          respectively.

          SEL should be a callable term, optionally with a module
          prefix, and the arguments VARS,SELECTED,REST will be appended
          to it.  For example, if SEL is `mod:sel(Param)', it will be
          called as `mod:sel(Param,Vars,Selected,Rest)'.

     The following options control the way in which choices are made
     for the selected variable X:

    `step'
          Makes a binary choice between `X #= B' and `X #\= B', where B
          is the lower or upper bound of X.  This is the default.

    `enum'
          Makes a multiple choice for X corresponding to the values in
          its domain.

    `bisect'
          Makes a binary choice between `X #=< M' and `X #> M', where M
          is the midpoint of the domain of X.  This strategy is also
          known as domain splitting.

    `value(ENUM)'
          ENUM is a predicate that should prune the domain of X,
          possibly but not necessarily to a singleton.  It will be
          called as ENUM(X,REST,BB0,BB) where REST is the list of
          variables that need labeling except X, and BB0 and BB are
          parameters described below.

          ENUM is expected to succeed nondeterminately, pruning the
          domain of X, and to backtrack one or more times, providing
          alternative prunings.  To ensure that branch-and-bound search
          works correctly, it must call the auxiliary predicate
          `first_bound(BB0,BB)' in its first solution.  Similarly, it
          must call the auxiliary predicate `later_bound(BB0,BB)' in
          any alternative solution.

          ENUM should be a callable term, optionally with a module
          prefix, and the arguments X,REST,BB0,BB will be appended to
          it.  For example, if ENUM is `mod:enum(Param)', it will be
          called as `mod:enum(Param,X,Rest,BB0,BB)'.

     The following options control the order in which the choices are
     made for the selected variable X.  Not useful with the
     `value(ENUM)' option:

    `up'
          The domain is explored in ascending order.  This is the
          default.

    `down'
          The domain is explored in descending order.

     The following options control whether all solutions should be
     enumerated by backtracking or whether a single solution that
     minimizes (maximizes) X is returned, if one exists.

    `all'
          All solutions are enumerated.  This is the default.

    `minimize(X)'
    `maximize(X)'
          Uses a branch-and-bound algorithm to find an assignment that
          minimizes (maximizes) the domain variable X.  The labeling
          should constrain X to become assigned for all assignments of
          VARIABLES.  It is useful to combine this option with the
          `time_out/2' option (see below).

     The following option counts the number of assumptions (choices)
     made during the search:

    `assumptions(K)'
          When a solution is found, K is unified with the number of
          choices made.

     A limit on the discrepancy of the search can be imposed:

    `discrepancy(D)'
          On the path leading to the solution there are at most D
          choicepoints in which a non-leftmost branch was taken.

     Finally, a time limit on the search can be imposed:

    `time_out(TIME,FLAG)'
          This is equivalent to a goal
          `time_out(labeling(...),Time,Flag)' (*note lib-timeout::).
          Furthermore, if combined with the `minimize(V)' or
          `maximize(V)' option, and the time limit is reached, the
          values of VARIABLES and V will be those of the best solution
          found.

   For example, to enumerate solutions using a static variable
ordering, use:

     | ?- constraints(Variables),
          labeling([], Variables).
          %same as [leftmost,step,up,all]

   To minimize a cost function using branch-and-bound search, a dynamic
variable ordering using the first-fail principle, and domain splitting
exploring the upper part of domains first, use:

     | ?- constraints(Variables, Cost),
          labeling([ff,bisect,down,minimize(Cost)], Variables).

   The file `library('clpfd/examples/tsp.pl')' contains an example of
user-defined variable and value choice heuristics.


File: sicstus.info,  Node: Statistics Predicates,  Next: Answer Constraints,  Prev: Enumeration Predicates,  Up: lib-clpfd

10.34.5 Statistics Predicates
-----------------------------

The following predicates can be used to get execution statistics.

`fd_statistics(?KEY, ?VALUE)'
     This allows a program to access execution statistics specific to
     this solver.  General statistics about CPU time and memory
     consumption etc. is available from the built-in predicate
     `statistics/2'.

     For each of the possible keys KEY, VALUE is unified with the
     current value of a counter, which is simultaneously zeroed.  The
     following counters are maintained.  *Note The Constraint System::,
     for details of what they all mean:

    `resumptions'
          The number of times a constraint was resumed.

    `entailments'
          The number of times a (dis)entailment was detected by a
          constraint.

    `prunings'
          The number of times a domain was pruned.

    `backtracks'
          The number of times a contradiction was found by a domain
          being wiped out, or by a global constraint signalling
          failure.  Other causes of backtracking, such as failed Prolog
          tests, are not covered by this counter.

    `constraints'
          The number of constraints created.

`fd_statistics'
     Displays on the standard error stream a summary of the above
     statistics.  All counters are zeroed.


File: sicstus.info,  Node: Answer Constraints,  Next: The Constraint System,  Prev: Statistics Predicates,  Up: lib-clpfd

10.34.6 Answer Constraints
--------------------------

By default, the answer constraint only shows the projection of the store
onto the variables that occur in the query, but not any constraints
that may be attached to these variables, nor any domains or constraints
attached to other variables.  This is a conscious decision, as no
efficient algorithm for projecting answer constraints onto the query
variables is known for this constraint system.

   It is possible, however, to get a complete answer constraint
including all variables that took part in the computation and their
domains and attached constraints.  This is done by asserting a clause
for the following predicate:

`clpfd:full_answer  "hook"'
     If false (the default), the answer constraint, as well as
     constraints projected by `clpfd:project_attributes/2',
     `clpfd:attribute_goal/2' and their callers, only contain the
     domains of the query variables.  If true, those constraints
     contain the domains and any attached constraints of all variables.
     Initially defined as a dynamic predicate with no clauses.


File: sicstus.info,  Node: The Constraint System,  Next: Defining Global Constraints,  Prev: Answer Constraints,  Up: lib-clpfd

10.34.7 The Constraint System
-----------------------------

* Menu:

* Definitions:: Definitions
* Pitfalls of Interval Reasoning:: Pitfalls of Interval Reasoning


File: sicstus.info,  Node: Definitions,  Next: Pitfalls of Interval Reasoning,  Up: The Constraint System

10.34.7.1 Definitions
.....................

The constraint system is based on domain constraints and indexicals.  A
"domain constraint" is an expression `X::I', where X is a domain
variable and I is a nonempty set of integers.

   A set S of domain constraints is called a "store". D(X,S), the
"domain" of X in S, is defined as the intersection of all I such that
`X::I' belongs to S.  The store is "contradictory" if the domain of
some variable is empty; otherwise, it is "consistent".  A consistent
store S' is an "extension" of a store S iff, for all variables X,
D(X,S') is contained in D(X,S).

   The following definitions, adapted from [Van Hentenryck et al. 95],
define important notions of consistency and entailment of constraints
wrt. stores.

   A ground constraint is "true" if it holds and "false" otherwise.

   A constraint C is "arc-consistent wrt. S" iff, for each variable X_i
and value V_i in D(X_i,S), there exist values V_j in D(X_j,S), 1 \leq j
\leq n \land i \neq j, such that C(V_1,\ldots,V_n) is true.

   A constraint C is "arc-entailed by S" iff, for all values V_j in
D(X_j,S), 1 \leq j \leq n, C(V_1,\ldots,V_n) is true.

   Let D'(X,S) denote the interval [\min(D(X,S)),\max(D(X,S))].

   A constraint C is "bound-consistent wrt. S" iff, for each variable
X_i, there exist values V_j and W_j in D'(X_j,S), 1 \leq j \leq n, i
\neq j, such that C(V_1,\ldots,\min(D(X_i,S)),\ldots,V_n) and
C(W_1,\ldots,\max(D(X_i,S)),\ldots,W_n) are both true.

   A constraint C is "bound-entailed by S" iff, for all values V_j in
D'(X_j,S), 1 \leq j \leq n, C(V_1,\ldots,V_n) is true.

   Finally, a constraint is "arc-disentailed (bound-disentailed) by S"
iff its negation is arc-entailed (bound-entailed) by S.


File: sicstus.info,  Node: Pitfalls of Interval Reasoning,  Prev: Definitions,  Up: The Constraint System

10.34.7.2 Pitfalls of Interval Reasoning
........................................

In most circumstances, arithmetic constraints maintain
bound-consistency and detect bound-entailment and -disentailment.
There are cases where a bound-consistency maintaining constraint may
detect a contradiction when the constraint is not yet
bound-disentailed, as the following example illustrates.  Note that `X
#\= Y' maintains arc-consistency if both arguments are constants or
variables:

     | ?- X+Y #= Z, X=1, Z=6, Y in 1..10, Y #\= 5.
     no
     | ?- X+Y #= Z #<=> B, X=1, Z=6, Y in 1..10, Y #\= 5.
     X = 1,
     Z = 6,
     Y in(1..4)\/(6..10),
     B in 0..1

Since `1+5#=6' holds, `X+Y #= Z' is not bound-disentailed, although any
attempt to make it bound-consistent wrt. the store results in a
contradictory store.


File: sicstus.info,  Node: Defining Global Constraints,  Next: Defining Primitive Constraints,  Prev: The Constraint System,  Up: lib-clpfd

10.34.8 Defining Global Constraints
-----------------------------------

* Menu:

* The Global Constraint Programming Interface:: The Global Constraint Programming Interface
* Reflection Predicates:: Reflection Predicates
* FD Set Operations:: FD Set Operations
* A Global Constraint Example:: A Global Constraint Example


File: sicstus.info,  Node: The Global Constraint Programming Interface,  Next: Reflection Predicates,  Up: Defining Global Constraints

10.34.8.1 The Global Constraint Programming Interface
.....................................................

This section describes a programming interface by means of which new
constraints can be written.  The interface consists of a set of
predicates provided by this library module.  Constraints defined in
this way can take arbitrary arguments and may use any constraint
solving algorithm, provided it makes sense.  Reification cannot be
expressed in this interface; instead, reification may be achieved by
explicitly passing a 0/1-variable to the constraint in question.

   Global constraints have state, which may be updated each time the
constraint is resumed.  The state information may be used e.g. in
incremental constraint solving.

   The following two predicates are the principal entrypoints for
defining and posting new global constraints:

`clpfd:dispatch_global(+CONSTRAINT, +STATE0, -STATE, -ACTIONS)  "extendible"'
     Tells the solver how to solve constraints of the form CONSTRAINT.
     Defined as a multifile predicate.

     When defining a new constraint, a clause of this predicate must be
     added. Its body defines a constraint solving method and should
     always succeed determinately.  When a global constraint is called
     or resumed, the solver will call this predicate to deal with the
     constraint.

          *Please note*: the constraint is identified by its principal
          functor; there is no provision for having two constraints
          with the same name in different modules.  It is good practice
          to include a cut in every clause of `clpfd:dispatch_global/4'.

     STATE0 and STATE are the old and new state respectively.

     The constraint solving method must not invoke the constraint solver
     recursively e.g. by binding variables or posting new constraints;
     instead, ACTIONS should be unified with a list of requests to the
     solver.  Each request should be of the following form:

    `exit'
          The constraint has become entailed, and ceases to exist.

    `fail'
          The constraint has become disentailed, causing the solver to
          backtrack.

    `X = V'
          The solver binds X to V.

    `X in R'
          The solver constrains X to be a member of the CONSTANTRANGE R
          (*note Syntax of Indexicals::).

    `X in_set S'
          The solver constrains X to be a member of the FD set S (*note
          FD Set Operations::).

    `call(GOAL)'
          The solver calls the goal or constraint GOAL, which should be
          module prefixed unless it is a built-in predicate or an
          exported predicate of the `clpfd' module.

          GOAL is executed as any Prolog goal, but in a context where
          some constraints may already be enqueued for execution, in
          which case those constraints will run after the completion of
          the call request.


`fd_global(:CONSTRAINT, +STATE, +SUSP)'
`fd_global(:CONSTRAINT, +STATE, +SUSP, +OPTIONS)'
     where CONSTRAINT is a constraint goal, STATE is its initial state,
     and SUSP is a term encoding how the constraint should wake up in
     response to domain changes.  This predicate posts the constraint.

     SUSP is a list of F(VAR) terms where VAR is a variable to suspend
     on and F is a functor encoding when to wake up:

    `dom(X)'
          wake up when the domain of X has changed

    `min(X)'
          wake up when the lower bound of X has changed

    `max(X)'
          wake up when the upper bound of X has changed

    `minmax(X)'
          wake up when the lower or upper of X has changed

    `val(X)'
          wake up when X has become ground

     OPTIONS is a list of zero or more of the following:

    `source(TERM)'
          By default, the symbolic form computed by `copy_term/3', and
          shown in the answer constraint if `clpfd:full_answer' holds,
          equals CONSTRAINT, module name expanded.  With this option,
          the symbolic form will instead be TERM.  In particular, if
          TERM equals `true', the constraint will not appear in the BODY
          argument of `copy_term/3'.  This can be useful if you are
          posting some redundant (implied) constraint.

    `idempotent(BOOLEAN)'
          If `true' (the default), the constraint solving method is
          assumed to be idempotent.  That is, in the scope of
          `clpfd:dispatch_global/4', the solver will not check for the
          resumption conditions for the given constraint, while
          performing its ACTIONS.  If `false', an action may well cause
          the solver to resume the constraint that produced the action.

          If a variable occurs more than once in a global constraint
          that is being posted, or due to a variable-variable
          unification, the solver will no longer trust the constraint
          solving method to be idempotent.

   For an example of usage, *note A Global Constraint Example::.

   The following predicate controls operational aspects of the
constraint solver:

`fd_flag(+FLAGNAME, ?OLDVALUE, ?NEWVALUE)'
     OLDVALUE is the value of the FD flag FLAGNAME, and the new value
     of FLAGNAME is set to NEWVALUE.  The possible FD flag names and
     values are:

    `overflow'
          Determines the behavior on integer overflow conditions.
          Possible values:

         `error'
               Raises a representation error (the default).

         `fail'
               Silently fails.

    `debug'
          Controls the visibility of constraint propagation. Possible
          values are `on' and `off' (the default).  For iternal use by
          `library(fdbg)'.



File: sicstus.info,  Node: Reflection Predicates,  Next: FD Set Operations,  Prev: The Global Constraint Programming Interface,  Up: Defining Global Constraints

10.34.8.2 Reflection Predicates
...............................

The constraint solving method needs access to information about the
current domains of variables.  This is provided by the following
predicates, which are all constant time operations.

`fd_var(?X)'
     Checks that X is currently an unbound variable that is known to
     the CLPFD solver.

`fd_min(?X, ?MIN)'
     where X is a domain variable (or an integer).  MIN is unified with
     the smallest value in the current domain of X, i.e. an integer or
     the atom `inf' denoting minus infinity.

`fd_max(?X, ?MAX)'
     where X is a domain variable (or an integer).  MAX is unified with
     the upper bound of the current domain of X, i.e. an integer or the
     atom `sup' denoting infinity.

`fd_size(?X, ?SIZE)'
     where X is a domain variable (or an integer).  SIZE is unified
     with the size of the current domain of X, if the domain is
     bounded, or the atom `sup' otherwise.

`fd_set(?X, ?SET)'
     where X is a domain variable (or an integer).  SET is unified with
     an FD set term denoting the internal representation of the current
     domain of X; see below.

`fd_dom(?X, ?RANGE)'
     where X is a domain variable (or an integer).  RANGE is unified
     with a CONSTANTRANGE (*note Syntax of Indexicals::) denoting the
     the current domain of X.

`fd_degree(?X, ?DEGREE)'
     where X is a domain variable (or an integer).  DEGREE is unified
     with the number of constraints that are attached to X.

          *Please note*: this number may include some constraints that
          have been detected as entailed.  Also, DEGREE is not the
          number of neighbors of X in the constraint network.

   The following predicates can be used for computing the set of
variables that are (transitively) connected via constraints to some
given variable(s).

`fd_neighbors(+VAR, -NEIGHBORS)'
     Given a domain variable VAR, NEIGHBORS is the set of variables
     that can be reached from VAR via constraints posted so far.

`fd_closure(+VARS, -CLOSURE)'
     Given a list VARS of domain variables, CLOSURE is the set of
     variables (including VARS) that can be transitively reached via
     constraints posted so far.  Thus, `fd_closure/2' is the transitive
     closure of `fd_neighbors/2'.


File: sicstus.info,  Node: FD Set Operations,  Next: A Global Constraint Example,  Prev: Reflection Predicates,  Up: Defining Global Constraints

10.34.8.3 FD Set Operations
...........................

The domains of variables are internally represented compactly as "FD
set" terms.  The details of this representation are subject to change
and should not be relied on.  Therefore, a number of operations on FD
sets are provided, as such terms play an important role in the
interface.  The following operations are the primitive ones:

`is_fdset(+SET)'
     SET is a valid FD set.

`empty_fdset(?SET)'
     SET is the empty FD set.

`fdset_parts(?SET, ?MIN, ?MAX, ?REST)'
     SET is an FD set, which is a union of the non-empty interval
     [MIN,MAX] and the FD set REST, and all elements of REST are
     greater than MAX+1.  MIN and MAX are both integers or the atoms
     `inf' and `sup', denoting minus and plus infinity, respectively.
     Either SET or all the other arguments must be ground.

   The following operations can all be defined in terms of the primitive
ones, but in most cases, a more efficient implementation is used:

`empty_interval(+MIN, +MAX)'
     [MIN,MAX] is an empty interval.

`fdset_interval(?SET, ?MIN, ?MAX)'
     SET is an FD set, which is the non-empty interval [MIN,MAX].

`fdset_singleton(?SET, ?ELT)'
     SET is an FD set containing ELT only.  At least one of the
     arguments must be ground.

`fdset_min(+SET, -MIN)'
     MIN is the lower bound of SET.

`fdset_max(+SET, -MIN)'
     MAX is the upper bound of SET.  This operation is linear in the
     number of intervals of SET.

`fdset_size(+SET, -SIZE)'
     SIZE is the cardinality of SET, represented as `sup' if SET is
     infinite.  This operation is linear in the number of intervals of
     SET.

`list_to_fdset(+LIST, -SET)'
     SET is the FD set containing the elements of LIST.  Slightly more
     efficient if LIST is ordered.

`fdset_to_list(+SET, -LIST)'
     LIST is an ordered list of the elements of SET, which must be
     finite.

`range_to_fdset(+RANGE, -SET)'
     SET is the FD set containing the elements of the CONSTANTRANGE
     (*note Syntax of Indexicals::) RANGE.

`fdset_to_range(+SET, -RANGE)'
     RANGE is a constant interval, a singleton constant set, or a union
     of such, denoting the same set as SET.

`fdset_add_element(+SET1, +ELT -SET2)'
     SET2 is SET1 with ELT inserted in it.

`fdset_del_element(+SET1, +ELT, -SET2)'
     SET2 is like SET1 but with ELT removed.

`fdset_disjoint(+SET1, +SET2)'
     The two FD sets have no elements in common.

`fdset_intersect(+SET1, +SET2)'
     The two FD sets have at least one element in common.

`fdset_intersection(+SET1, +SET2, -INTERSECTION)'
     INTERSECTION is the intersection between SET1 and SET2.

`fdset_intersection(+SETS, -INTERSECTION)'
     INTERSECTION is the intersection of all the sets in SETS.

`fdset_member(?ELT, +SET)'
     is true when ELT is a member of SET.  If ELT is unbound, SET must
     be finite.

`fdset_eq(+SET1, +SET2)'
     Is true when the two arguments represent the same set i.e. they
     are identical.

`fdset_subset(+SET1, +SET2)'
     Every element of SET1 appears in SET2.

`fdset_subtract(+SET1, +SET2, -DIFFERENCE)'
     DIFFERENCE contains all and only the elements of SET1 that are not
     also in SET2.

`fdset_union(+SET1, +SET2, -UNION)'
     UNION is the union of SET1 and SET2.

`fdset_union(+SETS, -UNION)'
     UNION is the union of all the sets in SETS.

`fdset_complement(+SET, -COMPLEMENT)'
     COMPLEMENT is the complement of SET wrt. `inf..sup'.


File: sicstus.info,  Node: A Global Constraint Example,  Prev: FD Set Operations,  Up: Defining Global Constraints

10.34.8.4 A Global Constraint Example
.....................................

The following example defines a new global constraint `exactly(X,L,N)',
which is true if X occurs exactly N times in the list L of integers and
domain variables.  N must be an integer when the constraint is posted.
A version without this restriction and defined in terms of reified
equalities was presented earlier; *note Reified Constraints::.

   This example illustrates the use of state information.  The state has
two components: the list of variables that could still be X, and the
number of variables still required to be X.

   The constraint is defined to wake up on any domain change.

                                                         _% exactly.pl_
     /*
     An implementation of exactly(I, X[1]...X[m], N):

     Necessary condition: 0 =< N =< m.
     Rewrite rules:

     [1] |= X[i]=I  ==> exactly(I, X[1]...X[i-1],X[i+1]...X[m], N-1):
     [2] |= X[i]\=I ==> exactly(I, X[1]...X[i-1],X[i+1]...X[m], N):
     [3] |= N=0     ==> X[1]\=I ... X[m]\=I
     [4] |= N=m     ==> X[1]=I  ... X[m]=I
     */
     :- use_module(library(clpfd)).

     % the entrypoint
     exactly(I, Xs, N) :-
             dom_suspensions(Xs, Susp),
             fd_global(exactly(I,Xs,N), state(Xs,N), Susp).

     dom_suspensions([], []).
     dom_suspensions([X|Xs], [dom(X)|Susp]) :-
             dom_suspensions(Xs, Susp).

     % the solver method
     :- multifile clpfd:dispatch_global/4.
     clpfd:dispatch_global(exactly(I,_,_), state(Xs0,N0), state(Xs,N), Actions) :-
             exactly_solver(I, Xs0, Xs, N0, N, Actions).

     exactly_solver(I, Xs0, Xs, N0, N, Actions) :-
             ex_filter(Xs0, Xs, N0, N, I),
             length(Xs, M),
             (   N=:=0 -> Actions = [exit|Ps], ex_neq(Xs, I, Ps)
             ;   N=:=M -> Actions = [exit|Ps], ex_eq(Xs, I, Ps)
             ;   N>0, N<M -> Actions = []
             ;   Actions = [fail]
             ).

                                                         _% exactly.pl_
     % rules [1,2]: filter the X's, decrementing N
     ex_filter([], [], N, N, _).
     ex_filter([X|Xs], Ys, L, N, I) :- X==I, !,
             M is L-1,
             ex_filter(Xs, Ys, M, N, I).
     ex_filter([X|Xs], Ys0, L, N, I) :-
             fd_set(X, Set),
             fdset_member(I, Set), !,
             Ys0 = [X|Ys],
             ex_filter(Xs, Ys, L, N, I).
     ex_filter([_|Xs], Ys, L, N, I) :-
             ex_filter(Xs, Ys, L, N, I).

     % rule [3]: all must be neq I
     ex_neq(Xs, I, Ps) :-
             fdset_singleton(Set0, I),
             fdset_complement(Set0, Set),
             eq_all(Xs, Set, Ps).

     % rule [4]: all must be eq I
     ex_eq(Xs, I, Ps) :-
             fdset_singleton(Set, I),
             eq_all(Xs, Set, Ps).

     eq_all([], _, []).
     eq_all([X|Xs], Set, [X in_set Set|Ps]) :-
             eq_all(Xs, Set, Ps).

     end_of_file.

     % sample queries: | ?- exactly(5,[A,B,C],1), A=5.  A = 5, B
     in(inf..4)\/(6..sup), C in(inf..4)\/(6..sup)

     | ?- exactly(5,[A,B,C],1), A in 1..2, B in 3..4.
     C = 5,
     A in 1..2,
     B in 3..4


File: sicstus.info,  Node: Defining Primitive Constraints,  Next: Example Programs,  Prev: Defining Global Constraints,  Up: lib-clpfd

10.34.9 Defining Primitive Constraints
--------------------------------------

Indexicals are the principal means of defining constraints, but it is
usually not necessary to resort to this level of programming--most
commonly used constraints are available in a library and/or via
macro-expansion.  The key feature about indexicals is that they give the
programmer precise control over aspects of the operational semantics of
the constraints. Trade-offs can be made between the computational cost
of the constraints and their pruning power.  The indexical language
provides many degrees of freedom for the user to select the level of
consistency to be maintained depending on application-specific needs.

* Menu:

* Indexicals:: Indexicals
* Range Expressions:: Range Expressions
* Term Expressions:: Term Expressions
* Monotonicity of Indexicals:: Monotonicity of Indexicals
* FD Predicates:: FD Predicates
* Execution of Propagating Indexicals:: Execution of Propagating Indexicals
* Execution of Checking Indexicals:: Execution of Checking Indexicals
* Goal Expanded Constraints:: Goal Expanded Constraints


File: sicstus.info,  Node: Indexicals,  Next: Range Expressions,  Up: Defining Primitive Constraints

10.34.9.1 Indexicals
....................

An "indexical" is a reactive functional rule of the form `X in R',
where R is a set valued "range expression" (see below).  *Note Syntax
of Indexicals::, for a grammar defining indexicals and range
expressions.

   Indexicals can play one of two roles: "propagating indexicals" are
used for constraint solving, and "checking indexicals" are used for
entailment checking.  When a propagating indexical fires, R is
evaluated in the current store S, which is extended by adding the new
domain constraint `X::S(R)' to the store, where S(R) denotes the value
of R in S.  When a checking indexical fires, it checks if D(X,S) is
contained in S(R), and if so, the constraint corresponding to the
indexical is detected as entailed.


File: sicstus.info,  Node: Range Expressions,  Next: Term Expressions,  Prev: Indexicals,  Up: Defining Primitive Constraints

10.34.9.2 Range Expressions
...........................

A range expression has one of the following forms, where R_i denote
range expressions, T_i denote integer valued "term expressions", S(T_i)
denotes the integer value of T_i in S, X denotes a variable, I denotes
an integer, and S denotes the current store.

`dom(X)'
     evaluates to D(X,S)

`{T_1,\ldots,T_n}'
     evaluates to {S(T_1),\ldots,S(T_n)}.  Any T_i containing a
     variable that is not "quantified" by `unionof/3' will cause the
     indexical to suspend until this variable has been assigned.

`T_1..T_2'
     evaluates to the interval between S(T_1) and S(T_2).

`R_1/\R_2'
     evaluates to the intersection of S(R_1) and S(R_2)

`R_1\/R_2'
     evaluates to the union of S(R_1) and S(R_2)

`\R_2'
     evaluates to the complement of S(R_2)

`R_1+R_2'
`R_1+T_2'
     evaluates to S(R_2) or S(T_2) added pointwise to S(R_1)

`-R_2'
     evaluates to S(R_2) negated pointwise

`R_1-R_2'
`R_1-T_2'
`T_1-R_2'
     evaluates to S(R_2) or S(T_2) subtracted pointwise from S(R_1) or
     S(T_1)

`R_1 mod R_2'
`R_1 mod T_2'
     evaluates to S(R_1) pointwise modulo S(R_2) or S(T_2)

`R_1 ? R_2'
     evaluates to S(R_2) if S(R_1) is a non-empty set; otherwise,
     evaluates to the empty set.  This expression is commonly used in
     the context `(R_1 ? (inf..sup) \/ R_3)', which evaluates to S(R_3)
     if S(R_1) is an empty set; otherwise, evaluates to `inf..sup'.  As
     an optimization, R_3 is not evaluated while the value of R_1 is a
     non-empty set.

`unionof(X,R_1,R_2)'
     evaluates to the union of S(E_1),\ldots,S(E_N), where each E_I has
     been formed by substituting K for X in R_2, where K is the I:th
     element of S(R_1).  *Note N Queens::, for an example of usage.

          *Please note*: if S(R_1) is infinite, the evaluation of the
          indexical will be abandoned, and the indexical will simply
          suspend.

`switch(T,MAPLIST)'
     evaluates to S(E) if S(T_1) equals K and MAPLIST contains a pair
     `K-E'.  Otherwise, evaluates to the empty set.  If T contains a
     variable that is not "quantified" by `unionof/3', the indexical
     will suspend until this variable has been assigned.


File: sicstus.info,  Node: Term Expressions,  Next: Monotonicity of Indexicals,  Prev: Range Expressions,  Up: Defining Primitive Constraints

10.34.9.3 Term Expressions
..........................

A term expression has one of the following forms, where T_1 and T_2
denote term expressions, X denotes a variable, I denotes an integer,
and S denotes the current store.

`min(X)'
     evaluates to the minimum of D(X,S)

`max(X)'
     evaluates to the maximum of D(X,S)

`card(X)'
     evaluates to the size of D(X,S)

`X'
     evaluates to the integer value of X.  The indexical will suspend
     until X is assigned.

`I'
     an integer

`inf'
     minus infinity

`sup'
     plus infinity

`-T_1'
     evaluates to S(T_1) negated

`T_1+T_2'
     evaluates to the sum of S(T_1) and S(T_2)

`T_1-T_2'
     evaluates to the difference of S(T_1) and S(T_2)

`T_1*T_2'
     evaluates to the product of S(T_1) and S(T_2), where S(T_2) must
     not be negative

`T_1/>T_2'
     evaluates to the quotient of S(T_1) and S(T_2), rounded up, where
     S(T_2) must be positive

`T_1/<T_2'
     evaluates to the quotient of S(T_1) and S(T_2), rounded down,
     where S(T_2) must be positive

`T_1 mod T_2'
     evaluates to the modulo of S(T_1) and S(T_2)


File: sicstus.info,  Node: Monotonicity of Indexicals,  Next: FD Predicates,  Prev: Term Expressions,  Up: Defining Primitive Constraints

10.34.9.4 Monotonicity of Indexicals
....................................

A range R is "monotone in S" iff the value of R in S' is contained in
the value of R in S, for every extension S' of S.  A range R is
"anti-monotone in S" iff the value of R in S is contained in the value
of R in S', for every extension S' of S.  By abuse of notation, we will
say that `X in R' is (anti-)monotone iff R is (anti-)monotone.

   The consistency or entailment of a constraint C expressed as
indexicals `X in R' in a store S is checked by considering the
relationship between D(X,S) and S(R), together with the
(anti-)monotonicity of R in S.  The details are given in *Note
Execution of Propagating Indexicals:: and *Note Execution of Checking
Indexicals::.

   The solver checks (anti-)monotonicity by requiring that certain
variables occurring in the indexical be ground.  This sufficient
condition can sometimes be false for an (anti-)monotone indexical, but
such situations are rare in practice.


File: sicstus.info,  Node: FD Predicates,  Next: Execution of Propagating Indexicals,  Prev: Monotonicity of Indexicals,  Up: Defining Primitive Constraints

10.34.9.5 FD Predicates
.......................

The following example defines the constraint X+Y=T as an FD predicate
in terms of three indexicals.  Each indexical is a rule responsible for
removing values detected as incompatible from one particular constraint
argument.  Indexicals are _not_ Prolog goals; thus, the example does
not express a conjunction.  However, an indexical may make the store
contradictory, in which case backtracking is triggered:

     plus(X,Y,T) +:
             X in min(T) - max(Y) .. max(T) - min(Y),
             Y in min(T) - max(X) .. max(T) - min(X),
             T in min(X) + min(Y) .. max(X) + max(Y).

   The above definition contains a single clause used for constraint
solving.  The first indexical wakes up whenever the bounds of S(T) or
S(Y) are updated, and removes from D(X,S) any values that are not
compatible with the new bounds of T and Y.  Note that in the event of
"holes" in the domains of T or Y, D(X,S) may contain some values that
are incompatible with X+Y=T but go undetected.  Like most built-in
arithmetic constraints, the above definition maintains
bound-consistency, which is significantly cheaper to maintain than
arc-consistency and suffices in most cases.  The constraint could for
example be used as follows:

     | ?- X in 1..5, Y in 2..8, plus(X,Y,T).
     X in 1..5,
     Y in 2..8,
     T in 3..13

Thus, when an FD predicate is called, the `+:' clause is activated.

   The definition of a user constraint has to specify what domain
constraints should be added to the constraint store when the constraint
is posted.  Therefore the FD predicate contains a set of indexicals,
each representing a domain constraint to be added to the constraint
store.  The actual domain constraint depends on the constraint store
itself.  For example, the third indexical in the above FD predicate
prescribes the domain constraint `T :: 3..13' if the store contains `X
:: 1..5, Y :: 2..8'.  As the domain of some variables gets smaller, the
indexical may enforce a new, stricter constraint on some other
variables.  Therefore such an indexical (called a propagating
indexical) can be viewed as an agent reacting to the changes in the
store by enforcing further changes in the store.

   In general there are three stages in the lifetime of a propagating
indexical.  When it is posted it may not be evaluated immediately (e.g.
has to wait until some variables are ground before being able to modify
the store).  Until the preconditions for the evaluation are satisfied,
the agent does not enforce any constraints.  When the indexical becomes
evaluable the resulting domain constraint is added to the store.  The
agent then waits and reacts to changes in the domains of variables
occurring in the indexical by re-evaluating it and adding the new,
stricter constraint to the store.  Eventually the computation reaches a
phase when no further refinement of the store can result in a more
precise constraint (the indexical is entailed by the store), and then
the agent can cease to exist.

   A necessary condition for the FD predicate to be correctly defined
is the following: for any store mapping each variable to a singleton
domain the execution of the indexicals should succeed without
contradiction exactly when the predicate is intended to be true.

   There can be several alternative definitions for the same user
constraint with different strengths in propagation.  For example, the
definition of `plusd' below encodes the same `X+Y=T' constraint as the
`plus' predicate above, but maintaining arc-consistency:

     plusd(X,Y,T) +:
             X in dom(T) - dom(Y),
             Y in dom(T) - dom(X),
             T in dom(X) + dom(Y).

     | ?- X in {1}\/{3}, Y in {10}\/{20}, plusd(X, Y, T).
     X in{1}\/{3},
     Y in{10}\/{20},
     T in{11}\/{13}\/{21}\/{23}

   This costs more in terms of execution time, but gives more precise
results. For singleton domains `plus' and `plusd' behave in the same
way.

   In our design, general indexicals can only appear in the context of
FD predicate definitions.  The rationale for this restriction is the
need for general indexicals to be able to suspend and resume, and this
ability is only provided by the FD predicate mechanism.

   If the program merely posts a constraint, it suffices for the
definition to contain a single clause for solving the constraint.  If a
constraint is reified or occurs in a propositional formula, the
definition must contain four clauses for solving and checking
entailment of the constraint and its negation.  The role of each clause
is reflected in the "neck" operator.  The following table summarizes
the different forms of indexical clauses corresponding to a constraint
C.  In all cases, HEAD should be a compound term with all arguments
being distinct variables:

`HEAD +: INDEXICALS.'
     The clause consists of propagating indexicals for solving C.

`HEAD -: INDEXICALS.'
     The clause consists of propagating indexicals for solving the
     negation of C.

`HEAD +? INDEXICAL.'
     The clause consists of a single checking indexical for testing
     entailment of C.

`HEAD -? INDEXICAL.'
     The clause consists of a single checking indexical for testing
     entailment of the negation of C.

   When a constraint is reified, the solver spawns two reactive agents
corresponding to detecting entailment and disentailment.  Eventually,
one of them will succeed in this and consequently will bind B to 0 or
1.  A third agent is spawned, waiting for B to become assigned, at
which time the constraint (or its negation) is posted.  In the mean
time, the constraint may have been detected as (dis)entailed, in which
case the third agent is dismissed.  The waiting is implemented by means
of the coroutining facilities of SICStus Prolog.

   As an example of a constraint with all methods defined, consider the
following library constraint defining a disequation between two domain
variables:

     'x\\=y'(X,Y) +:
             X in \{Y},
             Y in \{X}.
     'x\\=y'(X,Y) -:
             X in dom(Y),
             Y in dom(X).
     'x\\=y'(X,Y) +?
             X in \dom(Y).
     'x\\=y'(X,Y) -?
             X in {Y}.

   The following sections provide more precise coding rules and
operational details for indexicals.  `X in R' denotes an indexical
corresponding to a constraint C.  S denotes the current store.


File: sicstus.info,  Node: Execution of Propagating Indexicals,  Next: Execution of Checking Indexicals,  Prev: FD Predicates,  Up: Defining Primitive Constraints

10.34.9.6 Execution of Propagating Indexicals
.............................................

Consider the definition of a constraint C containing a propagating
indexical `X in R'.  Let \TV(X,C,S) denote the set of values for X that
can make C true in some ground extension of the store S.  Then the
indexical should obey the following coding rules:

   * all arguments of C except X should occur in R

   * if R is ground in S, S(R) = \TV(X,C,S)

   If the coding rules are observed, S(R) can be proven to contain
\TV(X,C,S) for all stores in which R is monotone.  Hence it is natural
for the implementation to wait until R becomes monotone before
admitting the propagating indexical for execution.  The execution of `X
in R' thus involves the following:

   * If D(X,S) is disjoint from S(R), a contradiction is detected.

   * If D(X,S) is contained in S(R), D(X,S) does not contain any values
     known to be incompatible with C, and the indexical suspends,
     unless R is ground in S, in which case C is detected as entailed.

   * Otherwise, D(X,S) contains some values that are known to be
     incompatible with C.  Hence, `X::S(R)' is added to the store (X is
     "pruned"), and the indexical suspends, unless R is ground in S, in
     which case C is detected as entailed.

   A propagating indexical is scheduled for execution as follows:

   * it is evaluated initially as soon as it has become monotone

   * it is re-evaluated when one of the following conditions occurs:
       1. the domain of a variable Y that occurs as `dom(Y)'       or
          `card(Y)' in R has been updated

       2. the lower bound of a variable Y that occurs as `min(Y)'
          in R has been updated

       3. the upper bound of a variable Y that occurs as `max(Y)'
          in R has been updated


File: sicstus.info,  Node: Execution of Checking Indexicals,  Next: Goal Expanded Constraints,  Prev: Execution of Propagating Indexicals,  Up: Defining Primitive Constraints

10.34.9.7 Execution of Checking Indexicals
..........................................

Consider the definition of a constraint C containing a checking
indexical `X in R'.  Let \FV(X,C,S) denote the set of values for X that
can make C false in some ground extension of the store S.  Then the
indexical should obey the following coding rules:

   * all arguments of C except X should occur in R

   * if R is ground in S, S(R) = \TV(X,C,S)

   If the coding rules are observed, S(R) can be proven to exclude
\FV(X,C,S) for all stores in which R is anti-monotone.  Hence it is
natural for the implementation to wait until R becomes anti-monotone
before admitting the checking indexical for execution.  The execution
of `X in R' thus involves the following:

   * If D(X,S) is contained in S(R), none of the possible values for X
     can make C false, and so C is detected as entailed.

   * Otherwise, if D(X,S) is disjoint from S(R) and R is ground in S,
     all possible values for X will make C false, and so C is detected
     as disentailed.

   * Otherwise, D(X,S) contains some values that could make C true and
     some that could make C false, and the indexical suspends.

   A checking indexical is scheduled for execution as follows:

   * it is evaluated initially as soon as it has become anti-monotone

   * it is re-evaluated when one of the following conditions occurs:
       1. the domain of X has been pruned, or X has been assigned

       2. the domain of a variable Y that occurs as `dom(Y)'       or
          `card(Y)' in R has been pruned

       3. the lower bound of a variable Y that occurs as `min(Y)'
          in R has been increased

       4. the upper bound of a variable Y that occurs as `max(Y)'
          in R has been decreased


File: sicstus.info,  Node: Goal Expanded Constraints,  Prev: Execution of Checking Indexicals,  Up: Defining Primitive Constraints

10.34.9.8 Goal Expanded Constraints
...................................

The arithmetic, membership, and propositional constraints described
earlier are transformed at compile time to conjunctions of goals of
library constraints.

   Although space economic (linear in the size of the source code), the
expansion of a constraint to library goals can have an overhead
compared to expressing the constraint in terms of indexicals.
Temporary variables holding intermediate values may have to be
introduced, and the grain size of the constraint solver invocations can
be rather small.  The translation of constraints to library goals has
been greatly improved in the current version, so these problems have
virtually disappeared.  However, for backward compatibility, an
implementation by compilation to indexicals of the same constraints is
also provided.

   The following two constructions are semantically equivalent:

     HEAD +: LINEXPR RELOP LINEXPR.

     HEAD :- LINEXPR RELOP LINEXPR.

where HEAD only contains unique variables mentioned in the linear
arithmetic expressions LINEXPR (*note Syntax of Indexicals::).  The
alternative version of `sum/8' in *Note Send More Money:: illustrates
this technique.

   Similarly, the following two constructions are semantically
equivalent:

     PRED(X,Y) +: element(X, CLIST, Y).

     PRED(X,Y) :- element(X, CLIST, Y).

where CLIST is a ground list of integers.  This technique is used in
some demo programs in `library('clpfd/examples')'.  *Please note*: the
generated indexical will assume that the domains of X and Y do not
contain values incompatible with CLIST.

   Similarly, the following two constructions are semantically
equivalent:

     PRED(X1,...,XN) +: table(CTABLE).

     PRED(X1,...,XN) :- table([[X1,...XN]], CTABLE).

where CTABLE is an N-ary relation given by extension, as for the
constraint `table/[2,3]'.  *Please note*: the generated indexical will
assume that the domains of X1,...XN do not contain values incompatible
with CTABLE.

   In the body of an FD predicate, `element/3' and `table/1'
expressions expand to indexicals recursively built up from `switch/2'
and `unionof/3' expressions.  For example, the following constraint:

     p(X, Y) +: table([[1,1],[2,1..2],[3,1..3]]).

expands to:

     q(X, Y) +:
             X in unionof(B,dom(Y),switch(B,[1-{1,2,3},2-{2,3},3-{3}])),
             Y in unionof(B,dom(X),switch(B,[1-{1},2-{1,2},3-{1,2,3}])).


File: sicstus.info,  Node: Example Programs,  Next: Syntax Summary,  Prev: Defining Primitive Constraints,  Up: lib-clpfd

10.34.10 Example Programs
-------------------------

* Menu:

* Send More Money:: Send More Money
* N Queens:: N Queens
* Cumulative Scheduling:: Cumulative Scheduling

   This section contains a few example programs.  The first two
programs are included in a benchmark suite that comes with the
distribution.  The benchmark suite is run by typing:

     | ?- compile(library('clpfd/examples/bench')).
     | ?- bench.


File: sicstus.info,  Node: Send More Money,  Next: N Queens,  Up: Example Programs

10.34.10.1 Send More Money
..........................

Let us return briefly to the Send More Money problem (*note A
Constraint Satisfaction Problem::).  Its `sum/8' predicate will expand
to a space-efficient conjunction of library constraints.  A faster but
more memory consuming version is defined simply by changing the neck
symbol of `sum/8' from `:-' to `+:', thus turning it into an FD
predicate:

     sum(S, E, N, D, M, O, R, Y) +:
                       1000*S + 100*E + 10*N + D
          +            1000*M + 100*O + 10*R + E
          #= 10000*M + 1000*O + 100*N + 10*E + Y.


File: sicstus.info,  Node: N Queens,  Next: Cumulative Scheduling,  Prev: Send More Money,  Up: Example Programs

10.34.10.2 N Queens
...................

The problem is to place N queens on an NxN chess board so that no queen
is threatened by another queen.

   The variables of this problem are the N queens.  Each queen has a
designated row.  The problem is to select a column for it.

   The main constraint of this problem is that no queen threaten
another.  This is encoded by the `no_threat/3' constraint and holds
between all pairs `(X,Y)' of queens.   It could be defined as

     no_threat(X, Y, I) :-
             X   #\= Y,
             X+I #\= Y,
             X-I #\= Y.

However, this formulation introduces new temporary domain variables and
creates twelve fine-grained indexicals.  Worse, the disequalities only
maintain bound-consistency and so may miss some opportunities for
pruning elements in the middle of domains.

   A better idea is to formulate `no_threat/3' as an FD predicate with
two indexicals, as shown in the program below.  This constraint will
not fire until one of the queens has been assigned (the corresponding
indexical does not become monotone until then).  Hence, the constraint
is still not as strong as it could be.

   For example, if the domain of one queen is `2..3', it will threaten
any queen placed in column 2 or 3 on an adjacent row, no matter which
of the two open positions is chosen for the first queen.  The commented
out formulation of the constraint captures this reasoning, and
illustrates the use of the `unionof/3' operator.  This stronger version
of the constraint indeed gives less backtracking, but is
computationally more expensive and does not pay off in terms of
execution time, except possibly for very large chess boards.

   It is clear that `no_threat/3' cannot detect any incompatible values
for a queen with domain of size greater than three.  This observation is
exploited in the third version of the constraint.

   The first-fail principle is appropriate in the enumeration part of
this problem.

     :- use_module(library(clpfd)).

     queens(N, L, LabelingType) :-
          length(L, N),
          domain(L, 1, N),
          constrain_all(L),
          labeling(LabelingType, L).

     constrain_all([]).
     constrain_all([X|Xs]) :-
          constrain_between(X, Xs, 1),
          constrain_all(Xs).

     constrain_between(_X, [], _N).
     constrain_between(X, [Y|Ys], N) :-
          no_threat(X, Y, N),
          N1 is N+1,
          constrain_between(X, Ys, N1).


     % version 1: weak but efficient
     no_threat(X, Y, I) +:
          X in \({Y} \/ {Y+I} \/ {Y-I}),
          Y in \({X} \/ {X+I} \/ {X-I}).

     /*
     % version 2: strong but very inefficient version
     no_threat(X, Y, I) +:
         X in unionof(B,dom(Y),\({B} \/ {B+I} \/ {B-I})),
         Y in unionof(B,dom(X),\({B} \/ {B+I} \/ {B-I})).

     % version 3: strong but somewhat inefficient version
     no_threat(X, Y, I) +:
         X in (4..card(Y)) ? (inf..sup) \/
               unionof(B,dom(Y),\({B} \/ {B+I} \/ {B-I})),
         Y in (4..card(X)) ? (inf..sup) \/
               unionof(B,dom(X),\({B} \/ {B+I} \/ {B-I})).
     */

     | ?- queens(8, L, [ff]).
     L = [1,5,8,6,3,7,2,4]


File: sicstus.info,  Node: Cumulative Scheduling,  Prev: N Queens,  Up: Example Programs

10.34.10.3 Cumulative Scheduling
................................

This example is a very small scheduling problem.  We consider seven
tasks where each task has a fixed duration and a fixed amount of used
resource:

TASK     DURATION     RESOURCE
`t1'     16           2
`t2'     6            9
`t3'     13           3
`t4'     7            7
`t5'     5            10
`t6'     18           1
`t7'     4            11

   The goal is to find a schedule that minimizes the completion time
for the schedule while not exceeding the capacity 13 of the resource.
The resource constraint is succinctly captured by a `cumulative/2'
constraint.  Branch-and-bound search is used to find the minimal
completion time.

   This example was adapted from [Beldiceanu & Contejean 94].

     :- use_module(library(clpfd)).
     :- use_module(library(lists), [append/3]).

     schedule(Ss, End) :-
             length(Ss, 7),
             Ds = [16, 6,13, 7, 5,18, 4],
             Rs = [ 2, 9, 3, 7,10, 1,11],
             domain(Ss, 1, 30),
             domain([End], 1, 50),
             after(Ss, Ds, End),
             cumulative(Ss, Ds, Rs, 13),
             append(Ss, [End], Vars),
             labeling([minimize(End)], Vars). % label End last

     after([], [], _).
     after([S|Ss], [D|Ds], E) :- E #>= S+D, after(Ss, Ds, E).

     %% End of file

     | ?- schedule(Ss, End).
     Ss = [1,17,10,10,5,5,1],
     End = 23


File: sicstus.info,  Node: Syntax Summary,  Prev: Example Programs,  Up: lib-clpfd

10.34.11 Syntax Summary
-----------------------

* Menu:

* Syntax of Indexicals:: Syntax of Indexicals
* Syntax of Arithmetic Expressions:: Syntax of Arithmetic Expressions
* Operator Declarations:: Operator Declarations


File: sicstus.info,  Node: Syntax of Indexicals,  Next: Syntax of Arithmetic Expressions,  Up: Syntax Summary

10.34.11.1 Syntax of Indexicals
...............................

X              ::= "variable"                { domain variable }

CONSTANT       ::= "integer"                 
               | `inf'                       { minus infinity }
               | `sup'                       { plus infinity }

TERM           ::= CONSTANT                  
               | X                           { suspend until assigned }
               | `min(X)'                    { min. of domain of X }
               | `max(X)'                    { max. of domain of X }
               | `card(X)'                   { size of domain of X }
               | `-' TERM                    
               | TERM `+' TERM               
               | TERM `-' TERM               
               | TERM `*' TERM               
               | TERM `/>' TERM              { division rounded up }
               | TERM `/<' TERM              { division rounded down }
               | TERM `mod' TERM             

TERMSET        ::= `{TERM,...,TERM}'         

RANGE          ::= TERMSET                   
               | `dom(X)'                    { domain of X }
               | TERM `..' TERM              { interval }
               | RANGE `/\' RANGE            { intersection }
               | RANGE `\/' RANGE            { union }
               | `\' RANGE                   { complement }
               | `-' RANGE                   { pointwise negation }
               | RANGE `+' RANGE             { pointwise addition }
               | RANGE `-' RANGE             { pointwise subtraction }
               | RANGE `mod' RANGE           { pointwise modulo }
               | RANGE `+' TERM              { pointwise addition }
               | RANGE `-' TERM              { pointwise subtraction }
               | TERM `-' RANGE              { pointwise subtraction }
               | RANGE `mod' TERM            { pointwise modulo }
               | RANGE `?' RANGE             
               | `unionof(X,RANGE,RANGE)'    
               | `switch(TERM,MAPLIST)'      

CONSTANTSET    ::= `{INTEGER,...,INTEGER}'   

CONSTANTRANGE  ::= CONSTANTSET               
               | CONSTANT `..' CONSTANT      
               | CONSTANTRANGE `/\'          
               CONSTANTRANGE                 
               | CONSTANTRANGE `\/'          
               CONSTANTRANGE                 
               | `\' CONSTANTRANGE           

MAPLIST        ::= `[]'                      
               |                             
               `["integer"-CONSTANTRANGE|MAPLIST]'

CTABLE         ::= `[]'                      
               | `[CROW|CTABLE]'             

CROW           ::= `[]'                      
               | `["integer"|CROW]'          
               | `[CONSTANTRANGE|CROW]'      

CLIST          ::= `[]'                      
               | `["integer"|CLIST]'         

INDEXICAL      ::= X `in' RANGE              

INDEXICALS     ::= INDEXICAL                 
               | INDEXICAL `,' INDEXICALS    

CONSTRAINTBODY ::= INDEXICALS                
               | LINEXPR RELOP LINEXPR       
               | `element(X,CLIST,X)'        
               | `table(CTABLE)'             

HEAD           ::= "term"                    { a compound term with
                                             unique variable args }

TELLPOS        ::= HEAD `+:' CONSTRAINTBODY  
TELLNEG        ::= HEAD `-:' CONSTRAINTBODY  
ASKPOS         ::= HEAD `+?' INDEXICAL       
ASKNEG         ::= HEAD `-?' INDEXICAL       

CONSTRAINTDEF  ::= TELLPOS.                  
               ?(TELLNEG.)                   
               ?(ASKPOS.)                    
               ?(ASKNEG.)                    


File: sicstus.info,  Node: Syntax of Arithmetic Expressions,  Next: Operator Declarations,  Prev: Syntax of Indexicals,  Up: Syntax Summary

10.34.11.2 Syntax of Arithmetic Expressions
...........................................

X              ::= "variable"                { domain variable }

N              ::= "integer"                 

LINEXPR        ::= N                         { linear expression }
               | X                           
               | N `*' X                     
               | N `*' N                     
               | LINEXPR `+' LINEXPR         
               | LINEXPR `-' LINEXPR         

EXPR           ::= LINEXPR                   
               | EXPR `+' EXPR               
               | EXPR `-' EXPR               
               | EXPR `*' EXPR               
               | EXPR `/' EXPR               { integer division }
               | EXPR `mod' EXPR             
               | `min(EXPR,EXPR)'            
               | `max(EXPR,EXPR)'            
               | `abs(EXPR)'                 

RELOP          ::= `#=' | `#\=' | `#<' |     
               `#=<' | `#>' | `#>='          


File: sicstus.info,  Node: Operator Declarations,  Prev: Syntax of Arithmetic Expressions,  Up: Syntax Summary

10.34.11.3 Operator Declarations
................................

     :- op(1200, xfx, [+:,-:,+?,-?]).
     :- op(760, yfx, #<=>).
     :- op(750, xfy, #=>).
     :- op(750, yfx, #<=).
     :- op(740, yfx, #\/).
     :- op(730, yfx, #\).
     :- op(720, yfx, #/\).
     :- op(710, fy, #\).
     :- op(700, xfx, [in,in_set]).
     :- op(700, xfx, [#=,#\=,#<,#=<,#>,#>=]).
     :- op(550, xfx, ..).
     :- op(500, fy, \).
     :- op(490, yfx, ?).
     :- op(400, yfx, [/>,/<]).


File: sicstus.info,  Node: lib-clpqr,  Next: lib-fdbg,  Prev: lib-clpfd,  Up: The Prolog Library

10.35 Constraint Logic Programming over Rationals or Reals--`library([clpq,clpr])'
==================================================================================

* Menu:

* CLPQR Introduction:: Introduction
* CLPQR Interface:: Solver Interface
* CLPQR Linearity::                   Linearity and Nonlinear Residues
* CLPQR Numerical Precision::         Numerical Precision and Rationals
* CLPQR Projection::                  Projection and Redundancy Elimination
* CLPQR Why Disequations::            Why Disequations
* CLPQR Monash Examples::             Monash Examples
* CLPQR MIP::                         A Mixed Integer Linear Optimization Example
* CLPQR Implementation Architecture:: Implementation Architecture


File: sicstus.info,  Node: CLPQR Introduction,  Next: CLPQR Interface,  Up: lib-clpqr

10.35.1 Introduction
--------------------

The clp(Q,R) system described in this chapter is an instance of the
general Constraint Logic Programming scheme introduced by [Jaffar &
Michaylov 87].  It is a third-party product, bundled with SICStus
Prolog as two library packages.  It is not supported by SICS in any way.

   The implementation is at least as complete as other existing clp(R)
implementations: It solves linear equations over rational or real valued
variables, covers the lazy treatment of nonlinear equations, features a
decision algorithm for linear inequalities that detects implied
equations, removes redundancies, performs projections (quantifier
elimination), allows for linear dis-equations, and provides for linear
optimization.

* Menu:

* CLPQR Referencing:: Referencing this Software
* CLPQR Acknowledging:: Acknowledgments


File: sicstus.info,  Node: CLPQR Referencing,  Next: CLPQR Acknowledging,  Up: CLPQR Introduction

10.35.1.1 Referencing this Software
...................................

When referring to this implementation of clp(Q,R) in publications, you
should use the following reference:

     Holzbaur C., `OFAI clp(q,r) Manual', Edition 1.3.3, Austrian
     Research Institute for Artificial Intelligence, Vienna, TR-95-09,
     1995.


File: sicstus.info,  Node: CLPQR Acknowledging,  Prev: CLPQR Referencing,  Up: CLPQR Introduction

10.35.1.2 Acknowledgments
.........................

The development of this software was supported by the Austrian _Fonds
zur Foerderung der Wissenschaftlichen Forschung_ under grant P9426-PHY.
Financial support for the Austrian Research Institute for Artificial
Intelligence is provided by the Austrian Federal Ministry for Science
and Research.

   We include a collection of examples that has been distributed with
the Monash University version of clp(R) [Heintze et al. 87], and its
inclusion into this distribution was kindly permitted by Roland Yap.


File: sicstus.info,  Node: CLPQR Interface,  Next: CLPQR Linearity,  Prev: CLPQR Introduction,  Up: lib-clpqr

10.35.2 Solver Interface
------------------------

Until rational numbers become first class citizens in SICStus Prolog,
rational arithmetics has to be emulated. Because of the emulation it is
too expensive to support arithmetics with automatic coercion between
all sorts of numbers, like you find it in CommonLisp, for example.

   You must choose whether you want to operate in the field of Q
(Rationals) or R (Reals):

     | ?- use_module(library(clpq)).

     or

     | ?- use_module(library(clpr)).

   You can also load both modules, but the exported predicates listed
below will name clash (*note ref-mod-ncl::).  You can avoid the
interactive resolution dialog if the importation is skipped, e.g. via:
`use_module(library(clpq),[]),use_module(library(clpr),[])'.

* Menu:

* CLPQR Notational Conventions:: Notational Conventions
* CLPQR Solver Predicates:: Solver Predicates
* CLPQR Unification:: Unification
* CLPQR Feedback:: Feedback and Bindings


File: sicstus.info,  Node: CLPQR Notational Conventions,  Next: CLPQR Solver Predicates,  Up: CLPQR Interface

10.35.2.1 Notational Conventions
................................

Throughout this chapter, the prompts `clp(q) ?-' and `clp(r) ?-' are
used to differentiate between clp(Q) and clp(R) in exemplary
interactions.

   In general there are many ways to express the same linear
relationship. This degree of freedom is manifest in the fact that the
printed manual and an actual interaction with the current version of
clp(Q,R) may show syntactically different answer constraints, despite
the fact the same semantic relationship is being expressed.  There are
means to control the presentation; *note CLPQR Variable Ordering::.
The approximative nature of floating point numbers may also produce
numerical differences between the text in this manual and the actual
results of clp(R), for a given edition of the software.


File: sicstus.info,  Node: CLPQR Solver Predicates,  Next: CLPQR Unification,  Prev: CLPQR Notational Conventions,  Up: CLPQR Interface

10.35.2.2 Solver Predicates
...........................

The solver interface for both Q and R consists of the following
predicates, which are exported from `module(linear)'.

`{+CONSTRAINT}'
     CONSTRAINT is a term accepted by the the grammar below.  The
     corresponding constraint is added to the current constraint store
     and checked for satisfiability.  Use the module prefix to
     distinguish the solvers if both clp(Q) and clp(R) were loaded
          | ?- clpr:{Ar+Br=10}, Ar=Br, clpq:{Aq+Bq=10}, Aq=Bq.

          Aq = 5,
          Ar = 5.0,
          Bq = 5,
          Br = 5.0

     Although clp(Q) and clp(R) are independent modules, you are asking
     for trouble if you (accidently) share variables between them:
          | ?- clpr:{A+B=10}, clpq:{A=B}.
          ! Type error in argument 2 of clpq:=/2
          ! a rational number expected, but 5.0 found
          ! goal:  _118=5.0

     This is because both solvers eventually compute values for the
     variables and Reals are incompatible with Rationals.

     Here is the constraint grammar:
     CONSTRAINT::= C                
             | C `,' C            { conjunction }

     C       ::= EXPR `=:=' EXPR  { equation }
             | EXPR  `='  EXPR    { equation }
             | EXPR  `<'  EXPR    { strict inequation }
             | EXPR  `>'  EXPR    { strict inequation }
             | EXPR `=<'  EXPR    { nonstrict inequation }
             | EXPR `>='  EXPR    { nonstrict inequation }
             | EXPR `=\=' EXPR    { disequation }

     EXPR    ::= "variable"       { Prolog variable }
             | "number"           { floating point or
                                  integer }
             | `+' EXPR           { unary plus }
             | `-' EXPR           { unary minus }
             | EXPR `+' EXPR      { addition }
             | EXPR `-' EXPR      { subtraction }
             | EXPR `*' EXPR      { multiplication }
             | EXPR `/' EXPR      { division }
             | `abs(EXPR)'        { absolute value }
             | `sin(EXPR)'        { trigonometric sine }
             | `cos(EXPR)'        { trigonometric cosine }
             | `tan(EXPR)'        { trigonometric tangent }
             | `pow(EXPR,EXPR)'   { raise to the power }
             | `exp(EXPR,EXPR)'   { raise to the power }
             | `min(EXPR,EXPR)'   { minimum of the two
                                  arguments }
             | `max(EXPR,EXPR)'   { maximum of the two
                                  arguments }
             | `#(CONST)'         { symbolic numerical
                                  constants }
     Conjunctive constraints `{C,C}' have been made part of the syntax
     to control the granularity of constraint submission, which will be
     exploited by future versions of this software.  Symbolic numerical
     constants are provided for compatibility only; *note CLPQR Monash
     Examples::.

`entailed(+CONSTRAINT)'
     Succeeds iff the linear CONSTRAINT is entailed by the current
     constraint store. This predicate does not change the state of the
     constraint store.
          clp(q) ?- {A =< 4}, entailed(A=\=5).

          {A=<4}

          clp(q) ?- {A =< 4}, entailed(A=\=3).

          no

`inf(+EXPR, -INF)'
`inf(+EXPR, -INF, +VECTOR, -VERTEX)'
     Computes the infimum of the linear expression EXPR and unifies it
     with INF. If given, VECTOR should be a list of variables relevant
     to EXPR, and VERTEX will be unified a list of the same length as
     VECTOR containing the values for VECTOR, such that the infimum is
     produced when assigned.  Failure indicates unboundedness.

`sup(+EXPR, -SUP)'
`sup(+EXPR, -SUP, +VECTOR, -VERTEX)'
     Computes the supremum of the linear expression EXPR and unifies it
     with SUP. If given, VECTOR should be a list of variables relevant
     to EXPR, and VERTEX will be unified a list of the same length as
     VECTOR containing the values for VECTOR, such that the supremum is
     produced when assigned.  Failure indicates unboundedness.

          clp(q) ?- { 2*X+Y =< 16, X+2*Y =< 11,
                      X+3*Y =< 15, Z = 30*X+50*Y
                    }, sup(Z, Sup, [X,Y], Vertex).

          Sup = 310,
          Vertex = [7,2],
          {Z=30*X+50*Y},
          {X+1/2*Y=<8},
          {X+3*Y=<15},
          {X+2*Y=<11}

`minimize(+EXPR)'
     Computes the infimum of the linear expression EXPR and equates it
     with the expression, i.e. as if defined as:
          minimize(Expr) :- inf(Expr, Expr).

`maximize(+EXPR)'
     Computes the supremum of the linear expression EXPR and equates it
     with the expression.
          clp(q) ?- { 2*X+Y =< 16, X+2*Y =< 11,
                      X+3*Y =< 15, Z = 30*X+50*Y
                    }, maximize(Z).

          X = 7,
          Y = 2,
          Z = 310

`bb_inf(+INTS, +EXPR, -INF)'
     Computes the infimum of the linear expression EXPR under the
     additional constraint that all of variables in the list INTS
     assume integral values at the infimum. This allows for the
     solution of mixed integer linear optimization problems; *note
     CLPQR MIP::.
          clp(q) ?- {X >= Y+Z, Y > 1, Z > 1}, bb_inf([Y,Z],X,Inf).

          Inf = 4,
          {Y>1},
          {Z>1},
          {X-Y-Z>=0}

`bb_inf(+INTS, +EXPR, -INF, -VERTEX, +EPS)'
     Computes the infimum of the linear expression EXPR under the
     additional constraint that all of variables in the list INTS
     assume integral values at the infimum. EPS is a positive number
     between 0 and 0.5 that specifies how close a number X must be to
     the next integer to be considered integral: `abs(round(X)-X) <
     EPS'.  The predicate `bb_inf/3' uses `EPS = 0.001'.  With clp(Q),
     `EPS = 0' makes sense.  VERTEX is a list of the same length as
     INTS and contains the (integral) values for INTS, such that the
     infimum is produced when assigned. Note that this will only
     generate one particular solution, which is different from the
     situation with `minimize/1', where the general solution is
     exhibited.

     `bb_inf/5' works properly for non-strict inequalities only!
     Disequations (`=\=') and higher dimensional strict inequalities
     (`>',`<') are beyond its scope. Strict bounds on the decision
     variables are honored however:

          clp(q) ?- {X >= Y+Z, Y > 1, Z > 1}, bb_inf([Y,Z],X,Inf,Vertex,0).

          Inf = 4,
          Vertex = [2,2],
          {Y>1},
          {Z>1},
          {X-Y-Z>=0}

     The limitation(s) can be addressed by:

        * transforming the original problem statement so that only
          non-strict inequalities remain; for example, `{X + Y > 0}'
          becomes `{X + Y >= 1}' for integral `X' and `Y';

        * contemplating the use of clp(FD).

`ordering(+SPEC)'
     Provides a means to control one aspect of the presentation of the
     answer constraints; *note CLPQR Variable Ordering::.

`dump(+TARGET, -NEWVARS, -CODEDANSWER)'
     Reflects the constraints on the target variables into a term,
     where TARGET and NEWVARS are lists of variables of equal length
     and CODEDANSWER is the term representation of the projection of
     constraints onto the target variables where the target variables
     are replaced by the corresponding variables from NEWVARS (*note
     CLPQR Turning Answers into Terms::).
          clp(q) ?- {A+B =< 10, A>=4},
                    dump([A,B],Vs,Cs),
                    dump([B],Bp,Cb).

          Cb = [_A=<6],
          Bp = [_A],
          Cs = [_B>=4,_C+_B=<10],
          Vs = [_C,_B],
          {A>=4},
          {A+B=<10}
     The current version of `dump/3' is incomplete with respect to
     nonlinear constraints. It only reports nonlinear constraints that
     are connected to the target variables. The following example has no
     solution. From the top-level's report we have a chance to deduce
     this fact, but `dump/3' currently has no means to collect global
     constraints ...
          q(X) :-
                  {X>=10},
                  {sin(Z)>3}.

          clp(r) ?- q(X), dump([X],V,C).

          C = [_A>=10.0],
          V = [_A],
          clpr:{3.0-sin(_B)<0.0},
          {X>=10.0}

`projecting_assert/1(:CLAUSE)'
     If you use the database, the clauses you assert might have
     constraints associated with their variables.  Use this predicate
     instead of `assert/1' in order to ensure that only the relevant
     and projected constraints get stored in the database.  It will
     transform the clause into one with plain variables and extra body
     goals that set up the relevant constraint when called.



File: sicstus.info,  Node: CLPQR Unification,  Next: CLPQR Feedback,  Prev: CLPQR Solver Predicates,  Up: CLPQR Interface

10.35.2.3 Unification
.....................

Equality constraints are added to the store implicitly each time
variables that have been mentioned in explicit constraints are
bound--either to another such variable or to a number.
     clp(r) ?- {2*A+3*B=C/2}, C=10.0, A=B.

     A = 1.0,
     B = 1.0,
     C = 10.0
Is equivalent modulo rounding errors to
     clp(r) ?- {2*A+3*B=C/2, C=10, A=B}.

     A = 1.0,
     B = 0.9999999999999999,
     C = 10.0
The shortcut bypassing the use of `{}/1' is allowed and makes
sense because the interpretation of this equality in Prolog and clp(R)
coincides.  In general, equations involving interpreted functors, `+/2'
in this case, must be fed to the solver explicitly:
     clp(r) ?- X=3.0+1.0, X=4.0.

     no
Further, variables known by clp(R) may be bound directly to floats
only.  Likewise, variables known by clp(Q) may be bound directly to
rational numbers only; *note CLPQR Fragments and Bits::. Failing to do
so is rewarded with an exception:
     clp(q) ?- {2*A+3*B=C/2}, C=10.0, A=B.
     ! Type error in argument 2 of = /2
     ! 'a rational number' expected, but 10.0 found
     ! goal:  _254=10.0
This is because `10.0' is not a rational constant. To make clp(Q)
happy you have to say:
     clp(q) ?- {2*A+3*B=C/2}, C=rat(10,1), A=B.

     A = 1,
     B = 1,
     C = 10

   If you use `{}/1', you don't have to worry about such details.


File: sicstus.info,  Node: CLPQR Feedback,  Prev: CLPQR Unification,  Up: CLPQR Interface

10.35.2.4 Feedback and Bindings
...............................

What was covered so far was how the user populates the constraint
store. The other direction of the information flow consists of the
success and failure of the above predicates and the binding of
variables to numerical values. Example:
     clp(r) ?- {A-B+C=10, C=5+5}.

     {A = B},
     C = 10.0
The linear constraints imply `C=10.0' and the solver consequently
exports this binding to the Prolog world. The fact that `A=B' is
deduced and represented by the solver but not exported as a binding.
More about answer presentation in *Note CLPQR Projection::.


File: sicstus.info,  Node: CLPQR Linearity,  Next: CLPQR Numerical Precision,  Prev: CLPQR Interface,  Up: lib-clpqr

10.35.3 Linearity and Nonlinear Residues
----------------------------------------

The clp(Q,R) system is restricted to deal with linear constraints
because the decision algorithms for general nonlinear constraints are
prohibitively expensive to run. If you need this functionality badly,
you should look into symbolic algebra packages.  Although the clp(Q,R)
system cannot solve nonlinear constraints, it will collect them
faithfully in the hope that through the addition of further (linear)
constraints they might get simple enough to solve eventually.  If an
answer contains nonlinear constraints, you have to be aware of the fact
that success is qualified modulo the existence of a solution to the
system of residual (nonlinear) constraints:
     clp(r) ?- {sin(X) = cos(X)}.

     clpr:{sin(X)-cos(X)=0.0}
There are indeed infinitely many solutions to this constraint (`X
= 0.785398 + n*Pi'), but clp(Q,R) has no direct means to find and
represent them.

   The systems goes through some lengths to recognize linear expressions
as such. The method is based on a normal form for multivariate
polynomials. In addition, some simple isolation axioms, that can be
used in equality constraints, have been added.  The current major
limitation of the method is that full polynomial division has not been
implemented.  Examples:

This is an example where the isolation axioms are sufficient to
determine the value of X.
     clp(r) ?- {sin(cos(X)) = 1/2}.

     X = 1.0197267436954502

If we change the equation into an inequation, clp(Q,R) gives up:
     clp(r) ?- {sin(cos(X)) < 1/2}.

     clpr:{sin(cos(X))-0.5<0.0}

The following is easy again:
     clp(r) ?- {sin(X+2+2)/sin(4+X) = Y}.

     Y = 1.0

And so is this:
     clp(r) ?- {(X+Y)*(Y+X)/X = Y*Y/X+99}.

     {Y=49.5-0.5*X}

An ancient symbol manipulation benchmark consists in rising the
expression `X+Y+Z+1' to the 15th power:
     clp(q) ?- {exp(X+Y+Z+1,15)=0}.
     clpq:{Z^15+Z^14*15+Z^13*105+Z^12*455+Z^11*1365+Z^10*3003+...
            ... polynomial continues for a few pages ...
            =0}
Computing its roots is another story.

* Menu:

* CLPQR How Nonlinear Residues Are Made to Disappear:: How Nonlinear Residues Are Made to Disappear
* CLPQR Isolation Axioms:: Isolation Axioms


File: sicstus.info,  Node: CLPQR How Nonlinear Residues Are Made to Disappear,  Next: CLPQR Isolation Axioms,  Up: CLPQR Linearity

10.35.3.1 How Nonlinear Residues Are Made to Disappear
......................................................

Binding variables that appear in nonlinear residues will reduce the
complexity of the nonlinear expressions and eventually results in
linear expressions:
     clp(q) ?- {exp(X+Y+1,2) = 3*X*X+Y*Y}.

     clpq:{Y*2-X^2*2+Y*X*2+X*2+1=0}
Equating X and Y collapses the expression completely and even
determines the values of the two variables:
     clp(q) ?- {exp(X+Y+1,2) = 3*X*X+Y*Y}, X=Y.

     X = -1/4,
     Y = -1/4


File: sicstus.info,  Node: CLPQR Isolation Axioms,  Prev: CLPQR How Nonlinear Residues Are Made to Disappear,  Up: CLPQR Linearity

10.35.3.2 Isolation Axioms
..........................

These axioms are used to rewrite equations such that the variable to be
solved for is moved to the left hand side and the result of the
evaluation of the right hand side can be assigned to the variable. This
allows, for example, to use the exponentiation operator for the
computation of roots and logarithms, see below.
`A = B * C'
     Residuates unless B or C is ground or A and B or C are ground.

`A = B / C'
     Residuates unless C is ground or A and B are ground.

`X = min(Y,Z)'
     Residuates unless Y and Z are ground.

`X = max(Y,Z)'
     Residuates unless Y and Z are ground.

`X = abs(Y)'
     Residuates unless Y is ground.

`X = pow(Y,Z), X = exp(Y,Z)'
     Residuates unless any pair of two of the three variables is
     ground.  Example:

          clp(r) ?- { 12=pow(2,X) }.

          X = 3.5849625007211565

          clp(r) ?- { 12=pow(X,3.585) }.

          X = 1.9999854993443926

          clp(r) ?- { X=pow(2,3.585) }.

          X = 12.000311914286545

`X = sin(Y)'
     Residuates unless X or Y is ground. Example:

          clp(r) ?- { 1/2 = sin(X) }.

          X = 0.5235987755982989

`X = cos(Y)'
     Residuates unless X or Y is ground.

`X = tan(Y)'
     Residuates unless X or Y is ground.


File: sicstus.info,  Node: CLPQR Numerical Precision,  Next: CLPQR Projection,  Prev: CLPQR Linearity,  Up: lib-clpqr

10.35.4 Numerical Precision and Rationals
-----------------------------------------

The fact that you can switch between clp(R) and clp(Q) should solve most
of your numerical problems regarding precision.  Within clp(Q), floating
point constants will be coerced into rational numbers automatically.
Transcendental functions will be approximated with rationals.  The
precision of the approximation is limited by the floating point
precision.  These two provisions allow you to switch between clp(R) and
clp(Q) without having to change your programs.

   What is to be kept in mind however is the fact that it may take
quite big rationals to accommodate the required precision. High levels
of precision are for example required if your linear program is
ill-conditioned, i.e. in a full rank system the determinant of the
coefficient matrix is close to zero.  Another situation that may call
for elevated levels of precision is when a linear optimization problem
requires exceedingly many pivot steps before the optimum is reached.

   If your application approximates irrational numbers, you may be out
of space particularly soon.  The following program implements N steps
of Newton's approximation for the square root function at point 2.
                                     _% library('clpqr/examples/root')_
     root(N, R) :-
       root(N, 1, R).

     root(0, S, R) :- !, S=R.
     root(N, S, R) :-
       N1 is N-1,
       { S1 = S/2 + 1/S },
       root(N1, S1, R).
It is known that this approximation converges quadratically, which
means that the number of correct digits in the decimal expansion
roughly doubles with each iteration. Therefore the numerator and
denominator of the rational approximation have to grow likewise:
     clp(q) ?- [library('clpqr/examples/root')].
     clp(q) ?- root(3,R),print_decimal(R,70).
     1.4142156862 7450980392 1568627450 9803921568 6274509803 9215686274
     5098039215

     R = 577/408

     clp(q) ?- root(4,R),print_decimal(R,70).
     1.4142135623 7468991062 6295578890 1349101165 5962211574 4044584905
     0192000543

     R = 665857/470832

     clp(q) ?- root(5,R),print_decimal(R,70).
     1.4142135623 7309504880 1689623502 5302436149 8192577619 7428498289
     4986231958

     R = 886731088897/627013566048

     clp(q) ?- root(6,R),print_decimal(R,70).
     1.4142135623 7309504880 1688724209 6980785696 7187537723 4001561013
     1331132652

     R = 1572584048032918633353217/1111984844349868137938112

     clp(q) ?- root(7,R),print_decimal(R,70).
     1.4142135623 7309504880 1688724209 6980785696 7187537694 8073176679
     7379907324

     R = 4946041176255201878775086487573351061418968498177 /
         3497379255757941172020851852070562919437964212608
Iterating for 8 steps produces no further change in the first 70
decimal digits of `sqrt(2)'. After 15 steps the approximating rational
number has a numerator and a denominator with 12543 digits each, and
the next step runs out of memory.

   Another irrational number that is easily computed is E.  The
following program implements an alternating series for `1/e', where the
absolute value of last term is an upper bound on the error.
                                     _% library('clpqr/examples/root')_
     e(N, E) :-
       { Err =:= exp(10,-(N+2)), Half =:= 1/2 },
       inv_e_series(Half, Half, 3, Err, Inv_E),
       { E =:= 1/Inv_E }.

     inv_e_series(Term, S0, _, Err, Sum) :-
       { abs(Term) =< Err }, !,
       S0 = Sum.
     inv_e_series(Term, S0, N, Err, Sum) :-
       N1 is N+1,
       { Term1 =:= -Term/N, S1 =:= Term1+S0 },
       inv_e_series(Term1, S1, N1, Err, Sum).
The computation of the rational number E that approximates E up to
at least 1000 digits in its decimal expansion requires the evaluation
of 450 terms of the series, i.e. 450 calls of `inv_e_series/5'.
     clp(q) ?- e(1000,E).

     E = 7149056228932760213666809592072842334290744221392610955845565494
         3708750229467761730471738895197792271346693089326102132000338192
         0131874187833985420922688804220167840319199699494193852403223700
         5853832741544191628747052136402176941963825543565900589161585723
         4023097417605004829991929283045372355639145644588174733401360176
         9953973706537274133283614740902771561159913069917833820285608440
         3104966899999651928637634656418969027076699082888742481392304807
         9484725489080844360397606199771786024695620205344042765860581379
         3538290451208322129898069978107971226873160872046731879753034549
         3130492167474809196348846916421782850086985668680640425192038155
         4902863298351349469211627292865440876581064873866786120098602898
         8799130098877372097360065934827751120659213470528793143805903554
         7928682131082164366007016698761961066948371407368962539467994627
         1374858249110795976398595034606994740186040425117101588480000000
         0000000000000000000000000000000000000000000000000000000000000000
         00000000000000000000000000000000000000
         /
         2629990810403002651095959155503002285441272170673105334466808931
         6863103901346024240326549035084528682487048064823380723787110941
         6809235187356318780972302796570251102928552003708556939314795678
         1978390674393498540663747334079841518303636625888963910391440709
         0887345797303470959207883316838346973393937778363411195624313553
         8835644822353659840936818391050630360633734935381528275392050975
         7271468992840907541350345459011192466892177866882264242860412188
         0652112744642450404625763019639086944558899249788084559753723892
         1643188991444945360726899532023542969572584363761073528841147012
         2634218045463494055807073778490814692996517359952229262198396182
         1838930043528583109973872348193806830382584040536394640895148751
         0766256738740729894909630785260101721285704616818889741995949666
         6303289703199393801976334974240815397920213059799071915067856758
         6716458821062645562512745336709063396510021681900076680696945309
         3660590933279867736747926648678738515702777431353845466199680991
         73361873421152165477774911660108200059

   The decimal expansion itself looks like this:
     clp(q) ?- e(1000, E), print_decimal(E, 1000).
     2.
     7182818284 5904523536 0287471352 6624977572 4709369995 9574966967
     6277240766 3035354759 4571382178 5251664274 2746639193 2003059921
     8174135966 2904357290 0334295260 5956307381 3232862794 3490763233
     8298807531 9525101901 1573834187 9307021540 8914993488 4167509244
     7614606680 8226480016 8477411853 7423454424 3710753907 7744992069
     5517027618 3860626133 1384583000 7520449338 2656029760 6737113200
     7093287091 2744374704 7230696977 2093101416 9283681902 5515108657
     4637721112 5238978442 5056953696 7707854499 6996794686 4454905987
     9316368892 3009879312 7736178215 4249992295 7635148220 8269895193
     6680331825 2886939849 6465105820 9392398294 8879332036 2509443117
     3012381970 6841614039 7019837679 3206832823 7646480429 5311802328
     7825098194 5581530175 6717361332 0698112509 9618188159 3041690351
     5988885193 4580727386 6738589422 8792284998 9208680582 5749279610
     4841984443 6346324496 8487560233 6248270419 7862320900 2160990235
     3043699418 4914631409 3431738143 6405462531 5209618369 0888707016
     7683964243 7814059271 4563549061 3031072085 1038375051 0115747704
     1718986106 8739696552 1267154688 9570350354


File: sicstus.info,  Node: CLPQR Projection,  Next: CLPQR Why Disequations,  Prev: CLPQR Numerical Precision,  Up: lib-clpqr

10.35.5 Projection and Redundancy Elimination
---------------------------------------------

Once a derivation succeeds, the Prolog system presents the bindings for
the variables in the query. In a CLP system, the set of answer
constraints is presented in analogy. A complication in the CLP context
are variables and associated constraints that were not mentioned in the
query. A motivating example is the familiar `mortgage' relation:
                                       _% library('clpqr/examples/mg')_
     mg(P,T,I,B,MP):-
       {
          T = 1,
          B + MP = P * (1 + I)
       }.
     mg(P,T,I,B,MP):-
       {
          T > 1,
          P1 = P * (1 + I) - MP,
          T1 = T - 1
       },
       mg(P1, T1, I, B, MP).
A sample query yields:
     clp(r) ?- [library('clpqr/examples/mg')].
     clp(r) ?- mg(P,12,0.01,B,Mp).

     {B=1.1268250301319698*P-12.682503013196973*Mp}
Without projection of the answer constraints onto the query
variables we would observe the following interaction:
     clp(r) ?- mg(P,12,0.01,B,Mp).

     {B=12.682503013196973*_A-11.682503013196971*P},
     {Mp= -(_A)+1.01*P},
     {_B=2.01*_A-1.01*P},
     {_C=3.0301*_A-2.0301*P},
     {_D=4.060401000000001*_A-3.0604009999999997*P},
     {_E=5.101005010000001*_A-4.10100501*P},
     {_F=6.152015060100001*_A-5.152015060099999*P},
     {_G=7.213535210701001*_A-6.213535210700999*P},
     {_H=8.285670562808011*_A-7.285670562808009*P},
     {_I=9.368527268436091*_A-8.36852726843609*P},
     {_J=10.462212541120453*_A-9.46221254112045*P},
     {_K=11.566834666531657*_A-10.566834666531655*P}
The variables _A ... _K are not part of the query, they originate
from the mortgage program proper. Although the latter answer is
equivalent to the former in terms of linear algebra, most users would
prefer the former.

* Menu:

* CLPQR Variable Ordering:: Variable Ordering
* CLPQR Turning Answers into Terms:: Turning Answers into Terms
* CLPQR Projecting Inequalities:: Projecting Inequalities


File: sicstus.info,  Node: CLPQR Variable Ordering,  Next: CLPQR Turning Answers into Terms,  Up: CLPQR Projection

10.35.5.1 Variable Ordering
...........................

In general, there are many ways to express the same linear relationship
between variables. clp(Q,R) does not care to distinguish between them,
but the user might. The predicate `ordering(+SPEC)' gives you some
control over the variable ordering. Suppose that instead of B, you want
MP to be the defined variable:
     clp(r) ?- mg(P,12,0.01,B,Mp).

     {B=1.1268250301319698*P-12.682503013196973*Mp}
This is achieved with:
     clp(r) ?- mg(P,12,0.01,B,Mp), ordering([Mp]).

     {Mp= -0.0788487886783417*B+0.08884878867834171*P}
One could go one step further and require P to appear before (to
the left of) B in an addition:
     clp(r) ?- mg(P,12,0.01,B,Mp), ordering([Mp,P]).

     {Mp=0.08884878867834171*P-0.0788487886783417*B}

   SPEC in `ordering(+SPEC)' is either a list of variables with the
intended ordering, or of the form `A<B'.  The latter form means that A
goes to the left of B.  In fact, `ordering([A,B,C,D])' is shorthand for:
     ordering(A < B), ordering(A < C), ordering(A < D),
     ordering(B < C), ordering(B < D),
     ordering(C < D)

   The ordering specification only affects the final presentation of the
constraints. For all other operations of clp(Q,R), the ordering is
immaterial.  Note that `ordering/1' acts like a constraint: you can put
it anywhere in the computation, and you can submit multiple
specifications.
     clp(r) ?- ordering(B < Mp), mg(P,12,0.01,B,Mp).

     {B= -12.682503013196973*Mp+1.1268250301319698*P}

     clp(r) ?- ordering(B < Mp), mg(P,12,0.01,B,Mp), ordering(P < Mp).

     {P=0.8874492252651537*B+11.255077473484631*Mp}


File: sicstus.info,  Node: CLPQR Turning Answers into Terms,  Next: CLPQR Projecting Inequalities,  Prev: CLPQR Variable Ordering,  Up: CLPQR Projection

10.35.5.2 Turning Answers into Terms
....................................

In meta-programming applications one needs to get a grip on the results
computed by the clp(Q,R) solver. You can use the predicate `dump/3' for
that purpose:
     clp(r) ?- {2*A+B+C=10,C-D=E,A<10}, dump([A,B,C,D,E],[a,b,c,d,e],Constraints).

     Constraints = [e<10.0,a=10.0-c-d-2.0*e,b=c+d],
     {C=10.0-2.0*A-B},
     {E=10.0-2.0*A-B-D},
     {A<10.0}


File: sicstus.info,  Node: CLPQR Projecting Inequalities,  Prev: CLPQR Turning Answers into Terms,  Up: CLPQR Projection

10.35.5.3 Projecting Inequalities
.................................

As soon as linear inequations are involved, projection gets more
demanding complexity wise.  The current clp(Q,R) version uses a
Fourier-Motzkin algorithm for the projection of linear inequalities.
The choice of a suitable algorithm is somewhat dependent on the number
of variables to be eliminated, the total number of variables, and other
factors. It is quite easy to produce problems of moderate size where
the elimination step takes some time.  For example, when the dimension
of the projection is 1, you might be better off computing the supremum
and the infimum of the remaining variable instead of eliminating `n-1'
variables via implicit projection.

   In order to make answers as concise as possible, redundant
constraints are removed by the system as well. In the following set of
inequalities, half of them are redundant.
                                 _% library('clpqr/examples/eliminat')_
     example(2, [X0,X1,X2,X3,X4]) :-
       {
            +87*X0  +52*X1  +27*X2  -54*X3  +56*X4 =<  -93,
            +33*X0  -10*X1  +61*X2  -28*X3  -29*X4 =<   63,
            -68*X0   +8*X1  +35*X2  +68*X3  +35*X4 =<  -85,
            +90*X0  +60*X1  -76*X2  -53*X3  +24*X4 =<  -68,
            -95*X0  -10*X1  +64*X2  +76*X3  -24*X4 =<   33,
            +43*X0  -22*X1  +67*X2  -68*X3  -92*X4 =<  -97,
            +39*X0   +7*X1  +62*X2  +54*X3  -26*X4 =<  -27,
            +48*X0  -13*X1   +7*X2  -61*X3  -59*X4 =<   -2,
            +49*X0  -23*X1  -31*X2  -76*X3  +27*X4 =<    3,
            -50*X0  +58*X1   -1*X2  +57*X3  +20*X4 =<    6,
            -13*X0  -63*X1  +81*X2   -3*X3  +70*X4 =<   64,
            +20*X0  +67*X1  -23*X2  -41*X3  -66*X4 =<   52,
            -81*X0  -44*X1  +19*X2  -22*X3  -73*X4 =<  -17,
            -43*X0   -9*X1  +14*X2  +27*X3  +40*X4 =<   39,
            +16*X0  +83*X1  +89*X2  +25*X3  +55*X4 =<   36,
             +2*X0  +40*X1  +65*X2  +59*X3  -32*X4 =<   13,
            -65*X0  -11*X1  +10*X2  -13*X3  +91*X4 =<   49,
            +93*X0  -73*X1  +91*X2   -1*X3  +23*X4 =<  -87
       }.
Consequently, the answer consists of the system of nine
non-redundant inequalities only:
     clp(q) ?- [library('clpqr/examples/eliminat')].
     clp(q) ?- example(2, [X0,X1,X2,X3,X4]).

     {X0-2/17*X1-35/68*X2-X3-35/68*X4>=5/4},
     {X0-73/93*X1+91/93*X2-1/93*X3+23/93*X4=<-29/31},
     {X0-29/25*X1+1/50*X2-57/50*X3-2/5*X4>=-3/25},
     {X0+7/39*X1+62/39*X2+18/13*X3-2/3*X4=<-9/13},
     {X0+2/19*X1-64/95*X2-4/5*X3+24/95*X4>=-33/95},
     {X0+2/3*X1-38/45*X2-53/90*X3+4/15*X4=<-34/45},
     {X0-23/49*X1-31/49*X2-76/49*X3+27/49*X4=<3/49},
     {X0+44/81*X1-19/81*X2+22/81*X3+73/81*X4>=17/81},
     {X0+9/43*X1-14/43*X2-27/43*X3-40/43*X4>=-39/43}

   The projection (the shadow) of this polyhedral set into the `X0,X1'
space can be computed via the implicit elimination of non-query
variables:
     clp(q) ?- example(2, [X0,X1|_]).

     {X0+2619277/17854273*X1>=-851123/17854273},
     {X0+6429953/16575801*X1=<-12749681/16575801},
     {X0+19130/1213083*X1>=795400/404361},
     {X0-1251619/3956679*X1>=21101146/3956679},
     {X0+601502/4257189*X1>=220850/473021}

   Projection is quite a powerful concept that leads to surprisingly
terse executable specifications of nontrivial problems like the
computation of the convex hull from a set of points in an n-dimensional
space: Given the program
                              _% library('clpqr/examples/elimination')_
     conv_hull(Points, Xs) :-
       lin_comb(Points, Lambdas, Zero, Xs),
       zero(Zero),
       polytope(Lambdas).

     polytope(Xs) :-
       positive_sum(Xs, 1).

       positive_sum([], Z) :- {Z=0}.
       positive_sum([X|Xs], SumX) :-
         { X >= 0, SumX = X+Sum },
         positive_sum(Xs, Sum).

     zero([]).
     zero([Z|Zs]) :- {Z=0}, zero(Zs).

     lin_comb([],        [],     S1, S1).
     lin_comb([Ps|Rest], [K|Ks], S1, S3) :-
       lin_comb_r(Ps, K, S1, S2),
       lin_comb(Rest, Ks, S2, S3).

       lin_comb_r([],     _, [],     []).
       lin_comb_r([P|Ps], K, [S|Ss], [Kps|Ss1]) :-
         { Kps = K*P+S },
         lin_comb_r(Ps, K, Ss, Ss1).
we can post the following query:
     clp(q) ?- conv_hull([ [1,1], [2,0], [3,0], [1,2], [2,2] ], [X,Y]).

     {Y=<2},
     {X+1/2*Y=<3},
     {X>=1},
     {Y>=0},
     {X+Y>=2}
This answer is easily verified graphically:
            |
          2 -    *    *
            |
            |
          1 -    *
            |
            |
          0 -----|----*----*----
                 1    2    3
The convex hull program directly corresponds to the mathematical
definition of the convex hull.  What does the trick in operational terms
is the implicit elimination of the LAMBDAS from the program
formulation. Please note that this program does not limit the number of
points or the dimension of the space they are from. Please note further
that quantifier elimination is a computationally expensive operation
and therefore this program is only useful as a benchmark for the
projector and not so for the intended purpose.


File: sicstus.info,  Node: CLPQR Why Disequations,  Next: CLPQR Monash Examples,  Prev: CLPQR Projection,  Up: lib-clpqr

10.35.6 Why Disequations
------------------------

A beautiful example of disequations at work is due to [Colmerauer 90].
It addresses the task of tiling a rectangle with squares of
all-different, a priori unknown sizes. Here is a translation of the
original `Prolog-III' program to clp(Q,R):
                                  _% library('clpqr/examples/squares')_
     filled_rectangle(A, C) :-
       { A >= 1 },
       distinct_squares(C),
       filled_zone([-1,A,1], _, C, []).

     distinct_squares([]).
     distinct_squares([B|C]) :-
       { B > 0 },
       outof(C, B),
       distinct_squares(C).

     outof([],     _).
     outof([B1|C], B) :-
       { B =\= B1 },       % *** note disequation ***
       outof(C, B).

     filled_zone([V|L], [W|L], C0, C0) :-
       { V=W,V >= 0 }.
     filled_zone([V|L], L3, [B|C], C2) :-
       { V < 0 },
       placed_square(B, L, L1),
       filled_zone(L1, L2, C, C1),
       { Vb=V+B },
       filled_zone([Vb,B|L2], L3, C1, C2).

     placed_square(B, [H,H0,H1|L], L1) :-
       { B > H, H0=0, H2=H+H1 },
       placed_square(B, [H2|L], L1).
     placed_square(B, [B,V|L], [X|L]) :-
       { X=V-B }.
     placed_square(B, [H|L], [X,Y|L]) :-
       { B < H, X= -B, Y=H-B }.
There are no tilings with less than nine squares except the
trivial one where the rectangle equals the only square. There are eight
solutions for nine squares. Six further solutions are rotations of the
first two.
     clp(q) ?- [library('clpqr/examples/squares')].
     clp(q) ?- filled_rectangle(A, Squares).

     A = 1,
     Squares = [1] ? ;

     A = 33/32,
     Squares = [15/32,9/16,1/4,7/32,1/8,7/16,1/32,5/16,9/32] ? ;

     A = 69/61,
     Squares = [33/61,36/61,28/61,5/61,2/61,9/61,25/61,7/61,16/61] ? <RET>
Depending on your hardware, the above query may take a few
minutes.  Supplying the knowledge about the minimal number of squares
beforehand cuts the computation time by a factor of roughly four:
     clp(q) ?- length(Squares, 9), filled_rectangle(A, Squares).

     A = 33/32,
     Squares = [15/32,9/16,1/4,7/32,1/8,7/16,1/32,5/16,9/32] ? ;

     A = 69/61,
     Squares = [33/61,36/61,28/61,5/61,2/61,9/61,25/61,7/61,16/61] ? <RET>


File: sicstus.info,  Node: CLPQR Monash Examples,  Next: CLPQR MIP,  Prev: CLPQR Why Disequations,  Up: lib-clpqr

10.35.7 Monash Examples
-----------------------

This collection of examples has been distributed with the Monash
University Version of clp(R) [Heintze et al. 87], and its inclusion
into this distribution was kindly permitted by Roland Yap.

   Assuming you are using clp(R):
     clp(r) ?- [library('clpqr/examples/monash/rkf45')].

     clp(r) ?- go.
     Point    0.00000 :    0.75000    0.00000
     Point    0.50000 :    0.61969    0.47793
     Point    1.00000 :    0.29417    0.81233
     Point    1.50000 :   -0.10556    0.95809
     Point    2.00000 :   -0.49076    0.93977
     Point    2.50000 :   -0.81440    0.79929
     Point    3.00000 :   -1.05440    0.57522

     Iteration finished
     ------------------
      439  derivative evaluations


File: sicstus.info,  Node: CLPQR MIP,  Next: CLPQR Implementation Architecture,  Prev: CLPQR Monash Examples,  Up: lib-clpqr

10.35.8 A Mixed Integer Linear Optimization Example
---------------------------------------------------

The predicates `bb_inf/[3,5]' implement a simple Branch and Bound
search algorithm for Mixed Integer Linear (MIP) Optimization examples.
Serious MIP is not trivial. The implementation `library('clpqr/bb.pl')'
is to be understood as a starting point for more ambitious users who
need control over branching, or who want to add cutting planes, for
example.

   Anyway, here is a small problem from miplib, a collection of MIP
models, housed at Rice University:
     NAME:         flugpl
     ROWS:         18
     COLUMNS:      18
     INTEGER:      11
     NONZERO:      46
     BEST SOLN:    1201500 (opt)
     LP SOLN:      1167185.73
     SOURCE:       Harvey M. Wagner
                   John W. Gregory (Cray Research)
                   E. Andrew Boyd (Rice University)
     APPLICATION:  airline model
     COMMENTS:     no integer variables are binary

                                      _% library('clpqr/examples/mip')_
     example(flugpl, Obj, Vs, Ints, []) :-
       Vs = [ Anm1,Anm2,Anm3,Anm4,Anm5,Anm6,
              Stm1,Stm2,Stm3,Stm4,Stm5,Stm6,
              UE1,UE2,UE3,UE4,UE5,UE6],
       Ints = [Stm6, Stm5, Stm4, Stm3, Stm2,
               Anm6, Anm5, Anm4, Anm3, Anm2, Anm1],

       Obj =    2700*Stm1 + 1500*Anm1 + 30*UE1
              + 2700*Stm2 + 1500*Anm2 + 30*UE2
              + 2700*Stm3 + 1500*Anm3 + 30*UE3
              + 2700*Stm4 + 1500*Anm4 + 30*UE4
              + 2700*Stm5 + 1500*Anm5 + 30*UE5
              + 2700*Stm6 + 1500*Anm6 + 30*UE6,

       allpos(Vs),
       {  Stm1 = 60, 0.9*Stm1 +1*Anm1 -1*Stm2 = 0,
          0.9*Stm2 +1*Anm2 -1*Stm3 = 0, 0.9*Stm3 +1*Anm3 -1*Stm4 = 0,
          0.9*Stm4 +1*Anm4 -1*Stm5 = 0, 0.9*Stm5 +1*Anm5 -1*Stm6 = 0,
          150*Stm1 -100*Anm1 +1*UE1 >= 8000,
          150*Stm2 -100*Anm2 +1*UE2 >= 9000,
          150*Stm3 -100*Anm3 +1*UE3 >= 8000,
          150*Stm4 -100*Anm4 +1*UE4 >= 10000,
          150*Stm5 -100*Anm5 +1*UE5 >= 9000,
          150*Stm6 -100*Anm6 +1*UE6 >= 12000,
          -20*Stm1 +1*UE1 =< 0, -20*Stm2 +1*UE2 =< 0, -20*Stm3 +1*UE3 =< 0,
          -20*Stm4 +1*UE4 =< 0, -20*Stm5 +1*UE5 =< 0, -20*Stm6 +1*UE6 =< 0,
          Anm1 =< 18, 57 =< Stm2, Stm2 =< 75, Anm2 =< 18,
          57 =< Stm3, Stm3 =< 75, Anm3 =< 18, 57 =< Stm4,
          Stm4 =< 75, Anm4 =< 18, 57 =< Stm5, Stm5 =< 75,
          Anm5 =< 18, 57 =< Stm6, Stm6 =< 75, Anm6 =< 18
        }.

       allpos([]).
       allpos([X|Xs]) :- {X >= 0}, allpos(Xs).

   We can first check whether the relaxed problem has indeed the quoted
infimum:
     clp(r) ?- example(flugpl, Obj, _, _, _), inf(Obj, Inf).

     Inf = 1167185.7255923203

   Computing the infimum under the additional constraints that `Stm6',
`Stm5', `Stm4', `Stm3', `Stm2', `Anm6', `Anm5', `Anm4', `Anm3', `Anm2',
`Anm1' assume integer values at the infimum is computationally harder,
but the query does not change much:
     clp(r) ?- example(flugpl, Obj, _, Ints, _),
               bb_inf(Ints, Obj, Inf, Vertex, 0.001).

     Inf = 1201500.0000000005,
     Vertex = [75.0,70.0,70.0,60.0,60.0,0.0,12.0,7.0,16.0,6.0,6.0]


File: sicstus.info,  Node: CLPQR Implementation Architecture,  Prev: CLPQR MIP,  Up: lib-clpqr

10.35.9 Implementation Architecture
-----------------------------------

The system consists roughly of the following components:
   * A polynomial normal form expression simplification mechanism.

   * A solver for linear equations [Holzbaur 92a].

   * A simplex algorithm to decide linear inequalities [Holzbaur 94].

* Menu:

* CLPQR Fragments and Bits:: Fragments and Bits
* CLPQR Bugs:: Bugs


File: sicstus.info,  Node: CLPQR Fragments and Bits,  Next: CLPQR Bugs,  Up: CLPQR Implementation Architecture

10.35.9.1 Fragments and Bits
............................

_Rationals._ The internal data structure for rational numbers is
`rat(NUM,DEN)'.  DEN is always positive, i.e.  the sign of the rational
number is the sign of NUM. Further, NUM and DEN are relative prime.
Note that integer N looks like `rat(N,1)' in this representation.  You
can control printing of terms with `user:portray/1'.  

   _Partial Evaluation, Compilation._ Once one has a working solver, it
is obvious and attractive to run the constraints in a clause definition
at read time or compile time and proceed with the answer constraints in
place of the original constraints. This gets you constant folding and
in fact the full algebraic power of the solver applied to the avoidance
of computations at runtime.  The mechanism to realize this idea is to
use `dump/3' for the expansion of `{}/1', via the goal and term
expansion hook predicates.

   _Asserting with Constraints._ If you use the database, the clauses
you assert might have constraints associated with their variables. You
should use `projecting_assert/1' instead of `assert/1' in order to
ensure that only the relevant and projected constraints get stored in
the database.

     | ?- {A+B=<33}, projecting_assert(test(A,B)).

     {A+B=<33}

     | ?- listing(test).
     test(A, B) :-
             {A+B=<rat(33,1)}

     | ?- test(A,B).

     {A+B=<33}


File: sicstus.info,  Node: CLPQR Bugs,  Prev: CLPQR Fragments and Bits,  Up: CLPQR Implementation Architecture

10.35.9.2 Bugs
..............

   * The fuzzy comparison of floats is the source for all sorts of
     weirdness. If a result in R surprises you, try to run the program
     in Q before you send me a bug report.

   * The projector for floundered nonlinear relations keeps too many
     variables. Its output is rather unreadable.

   * Disequations are not projected properly.

   * This list is probably incomplete.


File: sicstus.info,  Node: lib-fdbg,  Next: lib-pillow,  Prev: lib-clpqr,  Up: The Prolog Library

10.36 Finite Domain Constraint Debugger--`library(fdbg)'
========================================================

* Menu:

* FDBG Introduction:: Introduction
* FDBG Concepts:: Concepts
* FDBG Basics:: Basics
* FDBG Advanced Usage:: Advanced Usage


File: sicstus.info,  Node: FDBG Introduction,  Next: FDBG Concepts,  Up: lib-fdbg

10.36.1 Introduction
--------------------

FDBG is a CLP(FD) debugger for SICStus Prolog.  Its main purpose is to
enable the CLP programmer to trace the changes of domains of variables.

   FDBG defines the following prefix operator:

     :- op(400, fy, #).

   The presence of FDBG affects the translation and execution, but not
the semantics, of subsequently loaded arithmetic constraints.


File: sicstus.info,  Node: FDBG Concepts,  Next: FDBG Basics,  Prev: FDBG Introduction,  Up: lib-fdbg

10.36.2 Concepts
----------------

In this section, several concepts and terms are defined.  These terms
will later be heavily used in the documentation; therefore, it is
important that you understand them well.

* Menu:

* FDBG Events:: Events
* FDBG Labeling Levels:: Labeling Levels
* FDBG Visualizers:: Visualizers
* FDBG Names of Terms:: Names of Terms
* FDBG Selectors:: Selectors
* FDBG Name Auto-Generation:: Name Auto-Generation
* FDBG Legend:: Legend
* FDBG The fdbg_output Stream:: The `fdbg_output' Stream


File: sicstus.info,  Node: FDBG Events,  Next: FDBG Labeling Levels,  Up: FDBG Concepts

10.36.2.1 Events
................

An FDBG event can (currently) belong to one of the two following major
classes:

"constraint event"
     A global constraint is woken.

"labeling event"
     Three events belong to this class, namely:

        * the labeling of an FD variable is started

        * an FD variable gets constrained

        * the labeling of an FD variable fails, i.e. all elements of its
          domain have been tried and caused failure

   These events are intercepted by the FDBG core.  When any of them
occurs, the appropriate visualizer (*note FDBG Visualizers::) gets
called with a representation of the event (a Prolog term) as extra
arguments.

   Note that it is _not possible_ to debug indexicals with FDBG. What's
more, any domain narrowings done by indexicals happen unnoticed, making
FDBG output harder to follow.  On the other hand, arithmetical
constraints (like `X #> 0') are translated to global constraints
instead of indexicals after consulting `library(fdbg)', and therefore
don't lead to any misunderstandings.  For this latter reason it is
advisable to load `library(fdbg)' _before_ any user programs.


File: sicstus.info,  Node: FDBG Labeling Levels,  Next: FDBG Visualizers,  Prev: FDBG Events,  Up: FDBG Concepts

10.36.2.2 Labeling Levels
.........................

In this subsection we give three definitions regarding the labeling
procedure.

"labeling session"
     This term denotes the whole labeling procedure that starts with
     the call of `labeling/2' or an equivalent predicate and finishes by
     exiting this predicate.  Normally, there is at most one labeling
     session per run.

"labeling attempt"
     One choicepoint of a labeling session.  Exactly one variable is
     associated with a labeling attempt, although this is not
     necessarily true vice versa.  For example in `enum' mode labeling,
     a single labeling attempt tries every possible value, but in
     `step' mode labeling, several binary choicepoints are created.

"labeling step"
     The event of somehow constraining the domain of a variable.  This
     usually means either setting the variable to a specific value or
     limiting it with a lower or an upper bound.

   As you can see there is a hierarchical relation among these
definitions: a labeling session consists of several labeling attempts,
which, in turn, might consist of several labeling steps.

   A "labeling event", on the other hand, can either be a labeling
step, or the start of a labeling attempt, or the failure of the same.
*Note FDBG Events::.


File: sicstus.info,  Node: FDBG Visualizers,  Next: FDBG Names of Terms,  Prev: FDBG Labeling Levels,  Up: FDBG Concepts

10.36.2.3 Visualizers
.....................

A visualizer is a Prolog predicate reacting to FDBG events (*note FDBG
Events::).  It is called directly by the FDBG core when any FDBG event
occurs.  It is called "visualizer", because usually it should present
the events to the user, but in general it can do any kind of
processing, like checking invariants, etc.

   For all major event classes, a different visualizer type is used.
The set of visualizers you would like to use for a session is specified
in the option list of `fdbg_on/1' (*note FDBG Options::), when FDBG is
switched on.

   A specific visualizer can have several arguments, some are supplied
by the FDBG core, the rest (if any) should be specified when FDBG is
switched on.  Note that the obligatory arguments will be appended to
the _end_ of the user defined argument list.

   The set of built-in visualizers installed by default (*note FDBG
Options::) is the following:

   * for global constraint awakenings: `fdbg_show'

   * for labeling events: `fdbg_label_show'

   For details on built-in visualizers, *note FDBG Built-In
Visualizers::.


File: sicstus.info,  Node: FDBG Names of Terms,  Next: FDBG Selectors,  Prev: FDBG Visualizers,  Up: FDBG Concepts

10.36.2.4 Names of Terms
........................

FDBG provides a service to assign names to Prolog terms for later
reference.  A name is an atom and it is usually associated with a
compound term containing constraint variables, or with a single
variable.  In the former case, each variable appearing in the compound
term is also assigned a name automatically by FDBG.  This auto-assigned
name is derived from the name of the term; *note FDBG Name
Auto-Generation::.

   Perhaps the most useful utilization of names is "annotation",
another service of FDBG.  Here, each variable appearing in a Prolog
term is replaced with a compound term describing it (i.e. containing
its name, the variable itself, and some data regarding its domain).
During annotation, unnamed constraint variables are also given a unique
"anonymous" name automatically, these names begin with a `fdvar'
prefix.  *Note FDBG Writing Visualizers::.

   The names will be used by the built-in visualizers when referring to
constraint variables, and they can also be used to retrieve the terms
assigned to them in user defined visualizers.  *Note FDBG Visualizers::.


File: sicstus.info,  Node: FDBG Selectors,  Next: FDBG Name Auto-Generation,  Prev: FDBG Names of Terms,  Up: FDBG Concepts

10.36.2.5 Selectors
...................

A "selector" is a Prolog term denoting a (path to a) subterm of a given
term T.  Let SUBTERM(T,S) denote the subterm of T wrt. a selector S,
and let N denote an integer.  A selector then takes one of the following
forms:

S            SUBTERM(T,S)
`[]'         T
`[...,N]'    Nth argument of the compound term SUBTERM(T,`[...]')
`[...,#N]'   Nth element of the list SUBTERM(T,`[...]')


File: sicstus.info,  Node: FDBG Name Auto-Generation,  Next: FDBG Legend,  Prev: FDBG Selectors,  Up: FDBG Concepts

10.36.2.6 Name Auto-Generation
..............................

There are two cases when a name is automatically generated.

  1. When a name is assigned to a compound term by the user, each
     variable appearing in it is assigned a so called "derived" name,
     which is created by appending a variant of the selector of the
     variable to the original name.  For example, the call:
          fdbg_assign_name(bar(A, [B, C], foobar(D, E)), foo)
     will create the following name/term entries:

     NAME        TERM/VARIABLE                    SELECTOR
     `foo'       `bar(A, [B, C], foobar(D, E))'   `[]'
     `foo_1'     `A'                              `[1]'
     `foo_2_1'   `B'                              `[2,#1]'
     `foo_2_2'   `C'                              `[2,#2]'
     `foo_3_1'   `D'                              `[3,1]'
     `foo_3_2'   `E'                              `[3,2]'

     *Note FDBG Naming Terms::.

  2. If, during the annotation of a term (*note FDBG Annotation::) an
     unnamed constraint variable is found, it is assigned a unique
     "anonymous" name.  This name consists of the prefix `fdvar', an
     underscore character, and an integer.  The integer is automatically
     incremented when necessary.



File: sicstus.info,  Node: FDBG Legend,  Next: FDBG The fdbg_output Stream,  Prev: FDBG Name Auto-Generation,  Up: FDBG Concepts

10.36.2.7 Legend
................

The "legend" is a list of variables and their domains, usually
appearing after a description of the current constraint.  This is
necessary because the usual visual representation of a constraint
contains only the _names_ of the variables in it (*note FDBG
Annotation::), and doesn't show anything about their domain.  The legend
links these names to the corresponding domains.  The legend also shows
the changes of the domains made by the constraint.  Finally, the legend
may contain some conclusions regarding the behavior of the constraint,
like failure or side-effects.

   The format of the legend is somewhat customizable by defining a hook
function; *note FDBG Customizing Output::.  The default format of the
legend is the following:

     list_2 = 0..3
     list_3 = 0..3
     list_4 = 0..3
     fdvar_2 = 0..3 -> 1..3

   Here, we see four variables, with initial domains 0..3, but the
domain of the (previously unnamed) variable `fdvar_2' is narrowed by
the constraint (not shown here) to 1..3.

   A legend is automatically printed by the built-in visualizer
`fdbg_show', but it can be easily printed from user defined visualizers
too.


File: sicstus.info,  Node: FDBG The fdbg_output Stream,  Prev: FDBG Legend,  Up: FDBG Concepts

10.36.2.8 The `fdbg_output' Stream
..................................

The `fdbg_output' is a stream alias created when FDBG is switched on
and removed when it is switched off.  All built-in visualizers write to
this stream, and the user defined visualizers should do the same.


File: sicstus.info,  Node: FDBG Basics,  Next: FDBG Advanced Usage,  Prev: FDBG Concepts,  Up: lib-fdbg

10.36.3 Basics
--------------

Here, we describe the set of FDBG services and commands necessary to do
a simple debugging session.  No major modification of your CLP(FD)
program is necessary to use FDBG this way.  Debugging more complicated
programs, on the other hand, might also require user written extensions
to FDBG, since the wallpaper trace produced by the built-in visualizer
`fdbg_show' could be too detailed and therefore hard to analyze.  *Note
FDBG Advanced Usage::.

* Menu:

* FDBG Options:: FDBG Options
* FDBG Naming Terms:: Naming Terms
* FDBG Built-In Visualizers:: Built-In Visualizers
* FDBG Debugger Commands:: New Debugger Commands
* FDBG Annotation:: Annotating Programs
* FDBG An Example Session:: An Example Session


File: sicstus.info,  Node: FDBG Options,  Next: FDBG Naming Terms,  Up: FDBG Basics

10.36.3.1 FDBG Options
......................

FDBG is switched on and off with the predicates:

`fdbg_on'
`fdbg_on(:OPTIONS)'
     Turns on FDBG by putting advice-points on several predicates of
     the CLP(FD) module.  OPTIONS is a single option or a list of
     options; *note FDBG Options::.  The empty list is the default
     value.

     `fdbg_on/[0,1]' can be called safely several times consecutively;
     only the first call will have an effect.

`fdbg_off'
     Turns the debugger off by removing the previously installed
     advice-points.

   `fdbg_on/1' accepts the following options:

`file(FILENAME, MODE)'
     Tells FDBG to attach the stream alias `fdbg_output' to the file
     called FILENAME opened in mode MODE.  MODE can either be `write'
     or `append'.  The file specified is opened on a call to
     `fdbg_on/1' and is closed on a call to `fdbg_off/0'.

`socket(HOST, PORT)'
     Tells FDBG to attach the stream alias `fdbg_output' to the socket
     connected to HOST on port PORT.  The specified socket is created
     on a call to `fdbg_on/1' and is closed on a call to `fdbg_off/0'.

`stream(STREAM)'
     Tells FDBG to attach the stream alias `fdbg_output' to the stream
     STREAM.  The specified stream remains open after calling
     `fdbg_off/0'.

     If none of the above three options is used, the stream alias
     `fdbg_output' is attached to the current output stream.
`constraint_hook(GOAL)'
     Tells FDBG to extend GOAL with two (further) arguments and call it
     on the exit port of the global constraint dispatcher
     (`dispatch_global_fast/4').

`no_constraint_hook'
     Tells FDBG not to use any constraint hook.

     If none of the above two options is used, the default is
     `constraint_hook(fdbg:fdbg_show)'.
`labeling_hook(GOAL)'
     Tells FDBG to extend GOAL with three (further) arguments and call
     it on any of the three labeling events.

`no_labeling_hook'
     Tells FDBG not to use any labeling hook.

     If none of the above two options is used, the default is
     `labeling_hook(fdbg:fdbg_label_show)'.


   For both `constraint_hook' and `labeling_hook', GOAL should be a
visualizer, either built-in (*note FDBG Built-In Visualizers::) or user
defined.  More of these two options may appear in the option list, in
which case they will be called in their order of occurrence.

   *Note FDBG Writing Visualizers::, for more details on these two
options.


File: sicstus.info,  Node: FDBG Naming Terms,  Next: FDBG Built-In Visualizers,  Prev: FDBG Options,  Up: FDBG Basics

10.36.3.2 Naming Terms
......................

Naming is a procedure of associating names with terms and variables;
*note FDBG Names of Terms::.  Three predicates are provided to assign
and retrieve names, these are the following:

`fdbg_assign_name(+TERM, ?NAME)'
     Assigns the atom NAME to TERM, and a derived name to each variable
     appearing in TERM.  If NAME is a variable, use a default
     (generated) name, and return it in NAME.  *Note FDBG Name
     Auto-Generation::.

`fdbg_current_name(?TERM, ?NAME)'
     Retrieves TERM associated with NAME, or enumerates all term-name
     pairs.

`fdbg_get_name(+TERM, -NAME)'
     Returns the name associated to TERM in NAME, if it exists.
     Otherwise, silently fails.


File: sicstus.info,  Node: FDBG Built-In Visualizers,  Next: FDBG Debugger Commands,  Prev: FDBG Naming Terms,  Up: FDBG Basics

10.36.3.3 Built-In Visualizers
..............................

The default visualizers are generic predicates to display FDBG events
(*note FDBG Events::) in a well readable form.  These visualizers
naturally don't exploit any problem specific information--to have more
"fancy" output, you have to write your own visualizers; *note FDBG
Writing Visualizers::.  To use these visualizers, pass them in the
appropriate argument to `fdbg_on/1'; *note FDBG Options::, or call them
directly from user defined visualizers.

`fdbg_show(+CONSTRAINT, +ACTIONS)'
     This visualizer produces a trace output of all woken global
     constraints, in which a line showing the constraint is followed by
     a legend (*note FDBG Legend::) of all the variables appearing in
     it, and finally an empty line to separate events from each other.
     The usual output will look like this:

          <fdvar_1>#=0
              fdvar_1 = {0}
              Constraint exited.

     Here, we can see an arithmetical constraint being woken.  It
     narrows `fdvar_1' to a domain consisting of the singleton value 0,
     and since this is the narrowest domain possible, the constraint
     doesn't have anything more to do: it exits.

     Note that when you pass `fdbg_show/2' as an option, you should omit
     the two arguments, like in

          fdbg_on([..., constraint_hook(fdbg_show), ...]).

`fdbg_label_show(+EVENT, +LABELID, +VARIABLE)'
     This visualizer produces a wallpaper trace output of all labeling
     events.  It is best used together with `fdbg_show/2'.  Each
     labeling event produces a single line of output, some of them are
     followed by an empty line, some others are always followed by
     another labeling action and therefore the empty line is omitted.
     Here is a sample output of `fdbg_label_show/3':

          Labeling [9, <list_1>]: starting in range 0..3.
          Labeling [9, <list_1>]: step: <list_1> = 0

     What we see here is the following:

        * The prefix `Labeling' identifies the event.

        * The number in the brackets (9) is a unique identification
          number belonging to a labeling attempt.  Only _one_ labeling
          step with this number can be in effect at a time.  This
          number in fact is the invocation number of the predicate
          doing the labeling for that variable.

        * The name in the brackets (`<list_1>') identifies the variable
          currently being labeled.  Note that several identification
          numbers might belong to the same variable, depending on the
          mode of labeling.

        * The text after the colon specifies the actual labeling event.
          This string can be:

             - "starting in range RANGE." meaning the starting of a
               labeling attempt in range RANGE

             - "MODE: NARROWING." meaning a labeling step in mode MODE.
               NARROWING is the actual narrowing done in the labeling
               step.  MODE is one of the following:

              `step'
                    meaning `step' mode labeling

              `indomain_up'
                    meaning `enum' mode labeling or a direct call to
                    `indomain/1'

              `indomain_down'
                    meaning `enum,down' mode labeling

              `bisect'
                    meaning `bisect' mode labeling

              `dual'
                    when the domain contains exactly two values and the
                    labeling attempt is nothing more than a selection
                    between them

             - "failed." meaning the labeling attempt failed.

     Note that when you pass `fdbg_label_show/3' as an option, you
     should omit the three arguments, like in

          fdbg_on([..., labeling_hook(fdbg_label_show), ...]).



File: sicstus.info,  Node: FDBG Debugger Commands,  Next: FDBG Annotation,  Prev: FDBG Built-In Visualizers,  Up: FDBG Basics

10.36.3.4 New Debugger Commands
...............................

The Prolog debugger is extended by FDBG.  The `&' debugger is modified,
and two new commands are added:

`&'
`& N'
     This debugger command is extended so that the annotated form of
     domain variables is also printed when listing the variables with
     blocked goals.

`A'
`A SELECTOR'
     Annotates and prints the current goal and a legend of the
     variables appearing in it.  If a selector is specified, the
     subterm specified by it is assumed to be an action list, and is
     taken into account when displaying the legend.  For example:

          23  2 Exit: clpfd:dispatch_global_fast(no_threat(2,_1001,1),0,0,
                      [exit,_1001 in_set[[3|3]]]) ? A [2,4]

          clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
                                     [exit,<board_2> in_set[[3|3]]])
              board_2 = 1..4 -> {3}
              Constraint exited.

`W NAME=SELECTOR'
     Assigns the atom NAME to the variable specified by the SELECTOR.
     For example:

          7      15 Call: bar(4, [_101,_102,_103]) ? W foo=[2,#2]

     This would assign the name `foo' to `_102', being the second
     element of the second argument of the current goal.


File: sicstus.info,  Node: FDBG Annotation,  Next: FDBG An Example Session,  Prev: FDBG Debugger Commands,  Up: FDBG Basics

10.36.3.5 Annotating Programs
.............................

In order to use FDBG efficiently, you have to make some changes to your
CLP(FD) program.  Fortunately the calls you have to add are not
numerous, and when FDBG is turned off they don't decrease efficiency
significantly or modify the behavior of your program.  On the other
hand, they are necessary to make FDBG output easier to understand.

   Assign names to the more important and more frequently occurring
variables by inserting `fdbg_assign_name/2' calls at the beginning of
your program.  It is advisable to assign names to variables in larger
batches (i.e. as lists or compound terms) with a single call.

   Use pre-defined labeling predicates if possible.  If you define your
own labeling predicates and you want to use them even in the debugging
session, you should follow these guidelines:

  1. Add a call to `clpfd:fdbg_start_labeling(+VAR)' at the beginning
     of the predicate doing a labeling attempt, and pass the currently
     labeled variable as an argument to the call.  

  2. Call `clpfd:fdbg_labeling_step(+VAR, +STEP)' before each labeling
     step.  STEP should be a compound term describing the labeling
     step, this will be

       a. printed "as is" by the built-in visualizer as the mode of the
          labeling step (*note FDBG Built-In Visualizers::)--you can use
          `portray/1' to determine how it should be printed;

       b. passed as `step(STEP)' to the user defined labeling
          visualizers in their EVENT argument; *note FDBG Writing
          Visualizers::.

   This way FDBG can inform you about the labeling events created by
your labeling predicates exactly like it would do in the case of
internal labeling.  If you ignore these rules FDBG won't be able to
distinguish labeling events from other FDBG events any more.


File: sicstus.info,  Node: FDBG An Example Session,  Prev: FDBG Annotation,  Up: FDBG Basics

10.36.3.6 An Example Session
............................

The problem of magic sequences is a well known constraint problem. A
magic sequence is a list, where the I-th item of the list is equal to
the number of occurrences of the number I in the list, starting from
zero.  For example, the following is a magic sequence:

     [1,2,1,0]

   The CLP(FD) solution can be found in
`library('clpfd/examples/magicseq')', which provides a couple of
different solutions, one of which uses the `global_cardinality/2'
constraint.  We'll use this solution to demonstrate a simple session
with FDBG.

   First, the debugger is imported into the user module:

     | ?- use_module(fdbg).
     % loading /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/fdbg.po...
     % module fdbg imported into user

     [...]

     % loaded /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/fdbg.po in module fdbg, 220 msec 453936 bytes

   Then, the magic sequence solver is loaded:

     | ?- consult(library('clpfd/examples/magicseq')).
     % consulting /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/clpfd/examples/magicseq.pl...
     %  module magic imported into user
     %  module clpfd imported into magic
     % consulted /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/clpfd/examples/magicseq.pl in module magic, 30 msec 9440 bytes

   Now we turn on the debugger, telling it to save the trace in
`fdbg.log'.

     | ?- fdbg_on([file('fdbg.log',write)]).
     % The clp(fd) debugger is switched on

   To produce a well readable trace output, a name has to be assigned to
the list representing the magic sequence.  To avoid any modifications
to the source code, the name is assigned by a separate call before
calling the magic sequence finder predicate:

     | ?- length(L,4), fdbg_assign_name(L,list), magic_gcc(4,L,[enum]).
     L = [1,2,1,0] ? ;
     L = [2,0,2,0] ? ;

     no

     *Please note*: the call to `length/2' is necessary; otherwise, `L'
     would be a single variable instead of a list of four variables
     when the name is assigned.

   Finally we turn the debugger off:

     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   The output of the sample run can be found in `fdbg.log'.  Here, we
show selected parts of the trace.  In each block, the woken constraint
appears on the first line, followed by the corresponding legend.

   In the first displayed block, `scalar_product/4' removes infeasible
domain values from `list_3' and `list_4', thus adjusting their upper
bounds.  The legend shows the domains before and after pruning.  Note
also that the constraint is rewritten to a more readable form:

     <list_2>+2*<list_3>+3*<list_4>#=4
         list_2 = 0..3
         list_3 = 0..3 -> 0..2
         list_4 = 0..3 -> 0..1

   The following block shows the initial labeling events, trying the
value 0 for `list_1':

     Labeling [22, <list_1>]: starting in range 0..3.
     Labeling [22, <list_1>]: indomain_up: <list_1> = 0

   This immediately leads to a dead end:

     global_cardinality([0,<list_2>,<list_3>,<list_4>],
                        [0-0,1-<list_2>,2-<list_3>,3-<list_4>])
         list_2 = 0..3
         list_3 = 0..2
         list_4 = 0..1
         Constraint failed.

   We backtrack on `list_1', trying instead the value 1.  This leads to
the following propagation steps:

     Labeling [22, <list_1>]: indomain_up: <list_1> = 1

     global_cardinality([1,<list_2>,<list_3>,<list_4>],
                        [0-1,1-<list_2>,2-<list_3>,3-<list_4>])
         list_2 = 0..3 -> 1..3
         list_3 = 0..2
         list_4 = 0..1

     <list_2>+2*<list_3>+3*<list_4>#=4
         list_2 = 1..3
         list_3 = 0..2 -> 0..1
         list_4 = 0..1

   However, we do not yet have a solution, so we try the first feasible
value for `list_2', which is 2.  This is in fact enough to solve the
goal.  In the last two propagation steps, the constraint exits, which
means that it holds no matter what value any remaining variable takes
(in this example, there are none):

     Labeling [29, <list_2>]: indomain_up: <list_2> = 2

     global_cardinality([1,2,<list_3>,<list_4>],[0-1,1-2,2-<list_3>,3-<list_4>])
         list_3 = 0..1 -> {1}
         list_4 = 0..1 -> {0}

     global_cardinality([1,2,1,0],[0-1,1-2,2-1,3-0])
         Constraint exited.

     0#=0
         Constraint exited.


File: sicstus.info,  Node: FDBG Advanced Usage,  Prev: FDBG Basics,  Up: lib-fdbg

10.36.4 Advanced Usage
----------------------

Sometimes the output of the built-in visualizer is inadequate.  There
might be cases when only minor changes are necessary to produce a more
readable output; in other cases, the trace output should be completely
reorganized.  FDBG provides two ways of changing the appearance of the
output by defining hook predicates.  In this section, these predicates
will be described in detail.

* Menu:

* FDBG Customizing Output:: Customizing Output
* FDBG Writing Visualizers:: Writing Visualizers
* FDBG Writing Legend Printers:: Writing Legend Printers
* FDBG Showing Selected Constraints (simple version):: Showing Selected Constraints (simple version)
* FDBG Showing Selected Constraints (advanced version):: Showing Selected Constraints (advanced version)
* FDBG Debugging Global Constraints:: Debugging Global Constraints
* FDBG Code of the Built-In Visualizers:: Code of the Built-In Visualizers


File: sicstus.info,  Node: FDBG Customizing Output,  Next: FDBG Writing Visualizers,  Up: FDBG Advanced Usage

10.36.4.1 Customizing Output
............................

The printing of variable names is customized by defining the following
hook predicate.

`fdbg:fdvar_portray(NAME, VAR, FDSET)   "hook"'
     This hook predicate is called whenever an annotated constraint
     variable (*note FDBG Annotation::) is printed.  NAME is the
     assigned name of the variable VAR, whose domain _will be_ FDSET as
     soon as the narrowings of the current constraint take effect.  The
     _current_ domain is not stored in this compoun, but it can be
     easily determined with a call to `fd_set/2'.  (Although these two
     sets may be the same if the constraint didn't narrow it.)

     If `fdbg:fdvar_portray/3' is undefined or fails the default
     representation is printed, which is NAME between angle brackets.

   The printing of legend lines is customized by defining the following
hook predicate.

`fdbg:legend_portray(NAME, VAR, FDSET)   "hook"'
     This hook is called for each line of the legend by the built-in
     legend printer.  The arguments are the same as in the case of
     `fdbg:fdvar_portray/3'.  Note that a prefix of four spaces and a
     closing newline character is always printed by FDBG.

     If `fdbg:fdvar_portray/3' is undefined or fails the default
     representation is printed, which is

          NAME = RANGENOW [ -> RANGEAFTER ]

     The arrow and RANGEAFTER are only printed if the constraint
     narrowed the domain of VAR.

   The following example will print a list of all possible values
instead of the range for each variable in the legend:

     :- multifile fdbg:legend_portray/3.
     fdbg:legend_portray(Name, Var, Set) :-
             fd_set(Var, Set0),
             fdset_to_list(Set0, L0),
             fdset_to_list(Set, L),
             (   L0 == L
             ->  format('~p = ~p', [Name, L])
             ;   format('~p = ~p -> ~p', [Name, L0, L])
             ).


File: sicstus.info,  Node: FDBG Writing Visualizers,  Next: FDBG Writing Legend Printers,  Prev: FDBG Customizing Output,  Up: FDBG Advanced Usage

10.36.4.2 Writing Visualizers
.............................

For more complicated problems you might want to change the output more
drastically.  In this case you have to write and use your own
visualizers, which could naturally be problem specific, not like
`fdbg_show/2' and `fdbg_label_show/3'.  As we described earlier,
currently there are two types of visualizers:

"constraint visualizer"
          MYGLOBALVISUALIZER([+ARG1, +ARG2, ...] +CONSTRAINT, +ACTIONS)

     This visualizer is passed in the `constraint_hook' option.  It must
     have at least two arguments, these are the following:

    CONSTRAINT
          the constraint that was handled by the dispatcher

    ACTIONS
          the action list returned by the dispatcher

     Other arguments can be used for any purpose, for example to select
     the verbosity level of the visualizer.  This way you don't have to
     modify your code if you would like to see less or more information.
     Note however, that the two obligatory arguments must appear at the
     _end_ of the argument list.

     When passing as an option to `fdbg_on/1', only the optional
     arguments have to be specified; the two mandatory arguments should
     be omitted.  *Note FDBG Debugging Global Constraints::, for an
     example.

"labeling visualizer"
          MYLABELINGVISUALIZER([+ARG1, +ARG2, ...] +EVENT, +ID, +VAR)

     This visualizer is passed in the `labeling_hook' option.  It must
     have at least three arguments, these are the following:

    EVENT
          a term representing the labeling event, can be one of the
          following:

         start
               labeling has just started for a variable

         fail
               labeling has just failed for a variable

         step(STEP)
               variable has been constrained in a labeling step
               described by the compound term STEP, which is either
               created by `library(clpfd)''s labeling predicates (in
               this case, simply print it--FDBG will know how to handle
               it) or by you; *note FDBG Annotation::.

    ID
          identifies the labeling session, i.e. binds step and fail
          events to the corresponding start event

    VAR
          the variable being the subject of labeling


   The failure of a visualizer is ignored and multiple choices are cut
by FDBG.  Exceptions, on the other hand, are not caught.

   FDBG provides several predicates to ease the work of the visualizer
writers.  These predicates are the following:

`fdbg_annotate(+TERM0, -TERM, -VARIABLES)'

`fdbg_annotate(+TERM0, +ACTIONS, -TERM, -VARIABLES)'
     Replaces each constraint variable in TERM0 by a compound term
     describing it and returns the result in TERM.  Also, collects
     these compound terms into the list VARIABLES.  These compound
     terms have the following form:

          fdvar(NAME, VAR, FDSET)

    NAME
          is the name of the variable (auto-generated, if necessary;
          *note FDBG Name Auto-Generation::)

    VAR
          is the variable itself

    FDSET
          is the domain of the variable _after_ narrowing with ACTIONS,
          if specified; otherwise, it is the _current_ domain of the
          variable

`fdbg_legend(+VARS)'
     Prints a legend of VARS, which is a list of `fdvar/3' compound
     terms returned by `fdbg_annotate/[3,4]'.

`fdbg_legend(+VARS, +ACTIONS)'
     Prints a legend of VARS followed by some conclusions regarding the
     constraint (exiting, failing, etc.) based on ACTIONS.


File: sicstus.info,  Node: FDBG Writing Legend Printers,  Next: FDBG Showing Selected Constraints (simple version),  Prev: FDBG Writing Visualizers,  Up: FDBG Advanced Usage

10.36.4.3 Writing Legend Printers
.................................

When you write your own visualizers, you might not be satisfied with the
default format of the legend.  Therefore you might want to write your
own legend printer, replacing `fdbg_legend/[1,2]'.  This should be
quite straightforward based on the variable list returned by
`fdbg_annotate/[3,4]'.  Processing the rest of the action list and
writing conclusions about the constraint behavior is not that easy
though.  To help your work, FDBG provides a predicate to transform the
raw action list to a more readable form:

`fdbg_transform_actions(+ACTIONS, +VARS, -TRANSFORMEDACTIONS)'
     This will do the following transformations to ACTIONS, returning
     the result in TRANSFORMEDACTIONS:

       1. remove all actions concerning variables in VARS (the list
          returned by `fdbg_annotate/[3,4]');

       2. remove multiple `exit' and/or `fail' commands;

       3. remove all ground actions, translating those that will cause
          failure into `fail(ACTION)';

       4. substitute all other narrowings with an `fdvar/3' compound
          term per variable.

     The transformed action list may contain the following terms:

    `exit'
          the constraint exits

    `fail'
          the constraint fails due to a `fail' action

    `fail(ACTION)'
          the constraint fails because of ACTION

    `call(GOAL)'
          ACTIONS originally contained this action.  FDBG can't do
          anything with that but to inform the user about it.

    `fdvar(NAME, VAR, FDSET)'
          ACTIONS also narrowed some variables that didn't appear in
          the VARS list, this is one of them.  The meaning of the
          arguments is the usual, described in *Note FDBG Writing
          Visualizers::.  This should normally not happen.

    `ANYTHINGELSE'
          ACTIONS contained unrecognized actions too, these are copied
          unmodified.  This shouldn't happen!



File: sicstus.info,  Node: FDBG Showing Selected Constraints (simple version),  Next: FDBG Showing Selected Constraints (advanced version),  Prev: FDBG Writing Legend Printers,  Up: FDBG Advanced Usage

10.36.4.4 Showing Selected Constraints (simple version)
.......................................................

Sometimes the programmer is not interested in every global constraint,
only some selected ones.  Such a filter can be easily implemented with a
user-defined visualizer.  Suppose that you are interested in the
constraints `all_different/1' and `all_distinct/1' only:

     %% spec_filter(+Constraint, +Actions):  Call fdbg_show for all constraints
     %%   for which intresting_event(Constraint) succeeds.
     %%
     %%   Use this filter by giving the constraint_hook(spec_filter) option to
     %%   fdbg_on.
     spec_filter(Constraint, Actions) :-
             interesting_event(Constraint),
             fdbg_show(Constraint, Actions).

     interesting_event(all_different(_)).
     interesting_event(all_distinct(_)).

   Here is a session using the visualizer.  Note that the initialization
part (`domain/3' events), are filtered out, leaving only the
`all_different/1' constraints:

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on(constraint_hook(spec_filter)).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, P).
     all_different([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>,
                    4,<fdvar_4>,<fdvar_5>,<fdvar_6>])
         fdvar_1 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_2 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_3 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_4 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_5 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_6 = 1..9 -> (2..3)\/(5..7)\/{9}

     [...]

     all_different([7,6,2,5,8,4,1,3,9])
         Constraint exited.

     P = [...] ;
     no
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   Note that the failure of `spec_filter/2' doesn't cause any unwanted
output.


File: sicstus.info,  Node: FDBG Showing Selected Constraints (advanced version),  Next: FDBG Debugging Global Constraints,  Prev: FDBG Showing Selected Constraints (simple version),  Up: FDBG Advanced Usage

10.36.4.5 Showing Selected Constraints (advanced version)
.........................................................

Suppose that you want to give the constraints that you are interested in
as an argument to the visualizer, instead of defining them in a table.
The following visualizer implements this.

     :- use_module(library(lists), [append/3]).

     %% filter_events(+CtrSpecs, +Constraint, +Actions):  This predicate will
     %%   only show constraint events if they match an element in the list CtrSpecs,
     %%   or if CtrSpecs is wrapped in -/1, all the non-matching events will
     %%   be shown.
     %%   CtrSpecs can contain the following types of elements:
     %%     ctr_name             - matches all constraints of the given name
     %%     ctr_name/arity       - matches constraints with the given name and arity
     %%     ctr_name(...args...) - matches constraints unifyable with the given term
     %%
     %%   For the selected events fdbg_show(Constraint, Actions) is called.
     %%   This visualizer can be specified when turning fdbg on, e.g.:
     %%     fdbg_on([constraint_hook(filter_events([count/4]))]), or
     %%     fdbg_on([constraint_hook(filter_events(-[in_set]))]).
     filter_events(CtrSpecs, Constraint, Actions) :-
             filter_events(CtrSpecs, fdbg_show, Constraint, Actions).

     %% filter_events(+CtrSpecs, +Visualizer, +Constraint, +Actions):  Same as
     %%   the above predicate, but the extra argument Visualizer specifies the
     %%   predicate to be called for the selected events (in the same form as
     %%   in the constraint_hook option, i.e. without the last two arguments). E.g.
     %%     fdbg_on([constraint_hook(filter_events([count/4],my_show))]).
     filter_events(-CtrSpecs, Visualizer, Constraint, Actions) :- !,
             \+ show_constraint(CtrSpecs, Constraint),
             add_args(Visualizer, [Constraint, Actions], Goal),
             call(Goal).
     filter_events(CtrSpecs, Visualizer, Constraint, Actions) :-
             show_constraint(CtrSpecs, Constraint),
             add_args(Visualizer, [Constraint, Actions], Goal),
             call(Goal).

     show_constraint([C|_], Constraint) :-
             matches(C, Constraint), !.
     show_constraint([_|Cs], Constraint) :-
             show_constraint(Cs, Constraint).

     matches(Name/Arity, Constraint) :- !,
             functor(Constraint, Name, Arity).
     matches(Name, Constraint) :-
             atom(Name), !,
             functor(Constraint, Name, _).
     matches(C, Constraint) :-
             C = Constraint.

     add_args(Goal0, NewArgs, Goal) :-
             Goal0 =.. [F|Args0],
             append(Args0, NewArgs, Args),
             Goal =.. [F|Args].

   Here is a session using the visualizer, filtering out everything but
`all_different/1' constraints:

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on(constraint_hook(filter_events([all_different/1]))).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, P).
     all_different([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>,
                    4,<fdvar_4>,<fdvar_5>,<fdvar_6>])
         fdvar_1 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_2 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_3 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_4 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_5 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_6 = 1..9 -> (2..3)\/(5..7)\/{9}

     [...]

     all_different([7,6,2,5,8,4,1,3,9])
         Constraint exited.

     P = [...] ;
     no
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   In the next session, all constraints named `all_different' are
ignored, irrespective of arity.  Also, we explicitly specified the
visualizer to be called for the events that are kept (here, we have
written the default, `fdbg_show', so the actual behavior is not
changed).

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on(constraint_hook(filter_events(-[all_different],fdbg_show))).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, P).
     domain([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>,
             4,<fdvar_4>,<fdvar_5>,<fdvar_6>],1,9)
         fdvar_1 = inf..sup -> 1..9
         fdvar_2 = inf..sup -> 1..9
         fdvar_3 = inf..sup -> 1..9
         fdvar_4 = inf..sup -> 1..9
         fdvar_5 = inf..sup -> 1..9
         fdvar_6 = inf..sup -> 1..9
         Constraint exited.
         Constraint exited.

     [...]

     domain([2,<fdvar_46>,5,<fdvar_47>,<fdvar_48>,
            <fdvar_49>,<fdvar_50>,<fdvar_51>,9],1,9)
         fdvar_46 = inf..sup -> 1..9
         fdvar_47 = inf..sup -> 1..9
         fdvar_48 = inf..sup -> 1..9
         fdvar_49 = inf..sup -> 1..9
         fdvar_50 = inf..sup -> 1..9
         fdvar_51 = inf..sup -> 1..9
         Constraint exited.

     P = [...] ;
     no
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   In the last session, we specify a list of constraints to ignore,
using a pattern to select the appropriate constraints.  Since all
constraints in the example match one of the items in the given list, no
events are printed.

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on(constraint_hook(filter_events(-[domain(_,1,9),all_different(_)]))).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, P).
     P = [...] ;
     no
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off


File: sicstus.info,  Node: FDBG Debugging Global Constraints,  Next: FDBG Code of the Built-In Visualizers,  Prev: FDBG Showing Selected Constraints (advanced version),  Up: FDBG Advanced Usage

10.36.4.6 Debugging Global Constraints
......................................

Missing pruning and excessive pruning are the two major classes of bugs
in the implementation of global constraints.  Since CLP(FD) is an
incomplete constraint solver, missing pruning is mainly an efficiency
concern (but _ground_ instances for which the constraint does not hold
should be rejected).  Excessive pruning, however, means that some valid
combinations of values are pruned away, leading to missing solutions.
The following exported predicate helps spotting excessive pruning in
user-defined global constraints:

`fdbg_guard(:GOAL, +CONSTRAINT, +ACTIONS)'
     A constraint visualizer that does no output, but notifies the user
     by calling GOAL if a solution is lost through domain narrowings.
     Naturally you have to inform `fdbg_guard/3' about the solution in
     question--stating which variables should have which values.  To
     use `fdbg_guard/3', first:

       1. Set it up as a visualizer by calling:

               fdbg_on([..., constraint_hook(fdbg_guard(GOAL)), ...])

          As usual, the two other arguments will be supplied by the FDBG
          core when calling `fdbg_guard/3'.

       2. At the beginning of your program, form a pair of lists
          `XS-VS' where XS is the list of variables and VS is the list
          of values in question.  This pair should then be assigned the
          name `fdbg_guard' using:
               | ?- fdbg_assign_name(XS-VS, fdbg_guard).

     When these steps have been taken, `fdbg_guard/3' will watch the
     domain changes of XS done by each global constraint C.  Whenever
     VS is in the domains of XS at entry to C, but not at exit from C,
     GOAL is called with three more arguments:

    VARIABLE LIST
          a list of `VARIABLE-VALUE' terms for which VALUE was removed
          from the domain of VARIABLE

    CONSTRAINT
          the constraint that was handled by the dispatcher

    ACTIONS
          the action list returned by the dispatcher

   We will now show an example using `fdbg_guard/3'.  First, we will
need a few extra lines of code:

     %% print_and_trace(MissValues, Constraint, Actions):  To be used as a Goal for
     %%   fdbg_guard to call when the given solution was removed from the domains
     %%   of the variables.
     %%
     %%   MissValues is a list of Var-Value pairs, where Value is the value that
     %%   should appear in the domain of Var, but has been removed.  Constraint is
     %%   the current constraint and Actions is the list of actions returned by it.
     %%
     %%   This predicate prints MissValues in a textual form, then shows the current
     %%   (culprit) constraint (as done by fdbg_show/2), then turns on the Prolog
     %%   tracer.
     print_and_trace(MissValues, Constraint, Actions) :-
             print(fdbg_output, '\nFDBG Guard:\n'),
             display_missing_values(MissValues),
             print(fdbg_output, '\nCulprit constraint:\n\n'),
             fdbg_show(Constraint, Actions),
             trace.

     display_missing_values([]).
     display_missing_values([Var-Val|MissVals]) :-
             fdbg_annotate(Var,AVar,_),
             format(fdbg_output, '  ~d was removed from ~p~n', [Val,AVar]),
             display_missing_values(MissVals).

   Suppose that we have written the following N Queens program, using a
global constraint `no_threat/3' with a bug in it:

     :- use_module(library(clpfd)).
     :- use_module(library(fdbg)).

     queens(L, N) :-
             length(L, N),
             domain(L, 1, N),
             constrain_all(L),
             labeling([ff,enum], L).

     constrain_all([]).
     constrain_all([X|Xs]):-
             constrain_between(X,Xs,1),
             constrain_all(Xs).

     constrain_between(_X,[],_N).
     constrain_between(X,[Y|Ys],N) :-
             no_threat(X,Y,N),
             N1 is N+1,
             constrain_between(X,Ys,N1).

     no_threat(X,Y,I) :-
             fd_global(no_threat(X,Y,I), 0, [val(X),val(Y)]).

     :- multifile clpfd:dispatch_global/4.
     clpfd:dispatch_global(no_threat(X,Y,I), S, S, Actions) :-
             ground(X), !,
             remove_threat(Y, X, I, NewYSet),
             Actions = [exit, Y in_set NewYSet].
     clpfd:dispatch_global(no_threat(X,Y,I), S, S, Actions) :-
             ground(Y), !,
             remove_threat(X, Y, I, NewXSet),
             Actions = [exit, X in_set NewXSet].
     clpfd:dispatch_global(no_threat(_,_,_), S, S, []).

     remove_threat(X, V, I, Set) :-
             Vp is V+I+1,   % Bug introduced here
     %       Vp is V+I,     % Good code
             Vn is V-I,
             fd_set(X, Set0),
             list_to_fdset([Vn, V, Vp], VSet),
             fdset_subtract(Set0, VSet, Set).

     missing(L, Tuple) :-
          length(Tuple, N),
          length(L, N),
          fdbg_assign_name(L-Tuple, fdbg_guard),
          fdbg_assign_name(L, board),
          fdbg_on(constraint_hook(fdbg_guard(print_and_trace))),
          queens(L, N).

   We will now use `print_and_trace/3' as an argument to the
`fdbg_guard' visualizer to handle the case when a solution has been
removed by a constraint.  The bug shown above causes three invalid
solutions to be found instead of the two correct solutions.  FDBG is
told to watch for the disappearance of the first correct solution,
`[2,4,1,3]'.  First, we get two incorrect solutions before FDBG wakes
up, because in these cases the given good solution was made impossible
by a labeling event.  The second branch of labeling does not by itself
remove the solution, but at some point on that branch the bad
constraint does remove it, so `fdbg_guard/3' calls the given predicate.
This prints the cause of waking (the value that should not have been
removed by the constraint), prints the constraint itself, then switches
the Prolog debugger to trace mode.  At this point, we use the `A'
debugger command (*note FDBG Debugger Commands::) to print the
annotated form of the goal containing the culprit constraint.

   For clarity, the labeling events were not turned off in the session
below.

   This information can be used to track down why the buggy
`no_threat/3' performed the invalid pruning.

     | ?- missing(L, [2,4,1,3]).
     % The clp(fd) debugger is switched on
     Labeling [8, <board_1>]: starting in range 1..4.
     Labeling [8, <board_1>]: indomain_up: <board_1> = 1

     Labeling [13, <board_2>]: starting in range {2}\/{4}.
     Labeling [13, <board_2>]: dual: <board_2> = 2

     L = [1,2,3,4] ? ;
     Labeling [13, <board_2>]: dual: <board_2> = 4

     L = [1,4,2,3] ? ;
     Labeling [13, <board_2>]: failed.

     Labeling [8, <board_1>]: indomain_up: <board_1> = 2


     FDBG Guard:
       4 was removed from <board_2>

     Culprit constraint:

     no_threat(2,<board_2>,1)
         board_2 = 1..4 -> {3}
         Constraint exited.

     % The debugger will first creep -- showing everything (trace)
     23  2 Exit: clpfd:dispatch_global_fast(no_threat(2,_1001,1),0,0,
                 [exit,_1001 in_set[[3|3]]]) ? A

     clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
                                [exit,<board_2> in_set[[3|3]]])
         board_2 = 1..4

     23  2 Exit: clpfd:dispatch_global_fast(no_threat(2,_1001,1),0,0,
                 [exit,_1001 in_set[[3|3]]]) ? A [2,4]

     clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
                                [exit,<board_2> in_set[[3|3]]])
         board_2 = 1..4 -> {3}
         Constraint exited.

     23  2 Exit: clpfd:dispatch_global_fast(no_threat(2,_1001,1),0,0,
                 [exit,_1001 in_set[[3|3]]]) ? a
     % Execution aborted
     % advice,source_info
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off


File: sicstus.info,  Node: FDBG Code of the Built-In Visualizers,  Prev: FDBG Debugging Global Constraints,  Up: FDBG Advanced Usage

10.36.4.7 Code of the Built-In Visualizers
..........................................

Now that you know everything about writing visualizers, it might be
worth having a look at the code of the built-in visualizers,
`fdbg_show/2' and `fdbg_label_show/3'.

     fdbg_show(Constraint, Actions) :-
             fdbg_annotate(Constraint, Actions, AnnotC, CVars),
             print(fdbg_output, AnnotC),
             nl(fdbg_output),
             fdbg_legend(CVars, Actions),
             nl(fdbg_output).

     fdbg_label_show(start, I, Var) :-
             fdbg_annotate(Var, AVar, _),
             (   AVar = fdvar(Name, _, Set)
             ->  fdset_to_range(Set, Range),
                 format(fdbg_output,
                        'Labeling [~p, <~p>]: starting in range ~p.~n',
                        [I,Name,Range])
             ;   format(fdbg_output,
                        'Labeling [~p, <>]: starting.~n',
                        [I])
             ).
     fdbg_label_show(fail, I, Var) :-
             (   var(Var)
             ->  lookup_or_set_name(Var, Name),
                 format(fdbg_output,
                        'Labeling [~p, <~p>]: failed.~n~n',
                        [I,Name])
             ;   format(fdbg_output,
                        'Labeling [~p, <>]: failed.~n~n',
                        [I])
             ).
     fdbg_label_show(step(Step), I, Var) :-
             (   var(Var)
             ->  lookup_or_set_name(Var, Name),
                 format(fdbg_output,
                        'Labeling [~p, <~p>]: ~p~n~n',
                        [I,Name,Step])
             ;   format(fdbg_output,
                        'Labeling [~p, <>]: ~p~n~n',
                        [I,Step])
             ).

     lookup_or_set_name(Term, Name) :-
             fdbg_get_name(Term, Name), !.
     lookup_or_set_name(Term, Name) :-
             fdbg_assign_name(Term, Name).

   As you can see, they are quite simple, thanks to the extensive set of
support predicates also available to the user.


File: sicstus.info,  Node: lib-pillow,  Next: lib-tcltk,  Prev: lib-fdbg,  Up: The Prolog Library

10.37 The PiLLoW Web Programming Library--`library(pillow)'
===========================================================

The PiLLoW library ("Programming in Logic Languages on the Web") is a
free Internet/WWW programming library for Logic Programming Systems that
simplifies the process of writing applications for such environment.
The library provides facilities for generating HTML or XML structured
documents by handling them as Prolog terms, producing HTML forms,
writing form handlers, processing HTML templates, accessing and parsing
WWW documents (either HTML or XML), accessing code posted at HTTP
addresses, etc.

   PiLLoW is documented in its own reference manual, located in
`http://www.clip.dia.fi.upm.es/Software/pillow/pillow_doc_html/pillow_doc_toc.html'
(HTML) or `http://www.clip.dia.fi.upm.es/Software/pillow/pillow_doc.ps'
(Postscript). The following points are worth noting wrt. the PiLLoW
reference manual:

   * PiLLoW is automatically installed with the SICStus Prolog
     distribution.  No extra action needs to be taken.

   * PilloW comes as a single library module, `library(pillow)'.

     This subsumes the various `load_package/1' and `use_module/1'
     queries mentioned in the PiLLoW reference manual.

   Further information can be found at the PiLLoW home page,
`http://clip.dia.fi.upm.es/Software/pillow/pillow.html'.


File: sicstus.info,  Node: lib-tcltk,  Next: lib-gauge,  Prev: lib-pillow,  Up: The Prolog Library

10.38 Tcl/Tk Interface--`library(tcltk)'
========================================

* Menu:

* Introduction (Tcl):: Introduction
* Tcl:: Tcl
* Tk:: Tk
* The Tcl/Tk Prolog Library:: The Tcl/Tk Prolog Library
* Putting It All Together:: Putting It All Together
* Quick Reference:: Quick Reference
* Resources:: Resources


File: sicstus.info,  Node: Introduction (Tcl),  Next: Tcl,  Up: lib-tcltk

10.38.1 Introduction
--------------------

This is a basic tutorial for those SICStus Prolog users who would like
to add Tcl/Tk user interfaces to their Prolog applications.  The
tutorial assumes no prior knowledge of Tcl/Tk but, of course, does
assume the reader is proficient in Prolog.

   Aware that the reader may not have heard of Tcl/Tk, we will start by
answering three questions: what is Tcl/Tk? what is it good for? what
relationship does it have to Prolog?

* Menu:

* What Is Tcl/Tk?:: What Is Tcl/Tk?
* What Is Tcl/Tk Good For?:: What Is Tcl/Tk Good For?
* What Is Tcl/Tks Relationship to SICStus Prolog?:: What Is Tcl/Tks Relationship to SICStus Prolog?
* A Quick Example of Tcl/Tk in Action:: A Quick Example of Tcl/Tk in Action
* Outline of This Tutorial:: Outline of This Tutorial


File: sicstus.info,  Node: What Is Tcl/Tk?,  Next: What Is Tcl/Tk Good For?,  Up: Introduction (Tcl)

10.38.1.1 What Is Tcl/Tk?
.........................

Tcl/Tk, as its title suggests, is actually two software packages: Tcl
and Tk.  Tcl, pronounced _tickle_, stands for _tool command language_
and is a scripting language that provides a programming environment and
programming facilities such as variables, loops, and procedures. It is
designed to be easily extensible.

   Tk, pronounced _tee-kay_, is just such an extension to Tcl, which is
a "toolkit" for windowing systems. In other words, Tk adds facilities to
Tcl for creating and manipulating user interfaces based on windows and
widgets within those windows.


File: sicstus.info,  Node: What Is Tcl/Tk Good For?,  Next: What Is Tcl/Tks Relationship to SICStus Prolog?,  Prev: What Is Tcl/Tk?,  Up: Introduction (Tcl)

10.38.1.2 What Is Tcl/Tk Good For?
..................................

In combination the Tcl and Tk packages (we will call the combination
simply Tcl/Tk) are useful for creating graphical user interfaces (GUIs)
to applications. The GUI is described in terms of instances of Tk
widgets, created through calls in Tcl, and Tcl scripts that form the
glue that binds together the GUI and the application.  (If you are a
little lost at this point, all will be clear in a moment with  a simple
example.)

   There are lots of systems out there for adding GUIs to applications
so why choose Tcl/Tk? Tcl/Tk has several advantages that make it
attractive for this kind of work.  Firstly, it is good for rapid
prototyping of GUIs. Tcl is an interpreted scripting language. The
scripts can be modified and executed quickly, with no compilation
phase, so speeding up the development loop.

   Secondly, it is easier to use a system based on a scripting language,
such as Tcl/Tk, than many of the conventional packages available.  For
example, getting to grips with the X windows suite of C libraries is not
an easy task. Tcl/Tk can produce the same thing using simple scripting
with much less to learn.  The penalty for this is that programs written
in an interpreted scripting language will execute more slowly than
those written using compiled C library calls, but for many interfaces
that do not need great speed Tcl/Tk is fast enough and its ease of use
more than outweighs the loss of speed.  In any case, Tcl/Tk can easily
handle hundreds of events per mouse movement without the user noticing.

   Thirdly, Tcl/Tk is good for making cross-platform GUIs.  The Tk
toolkit has been ported to native look-and-feel widgets on Mac, PC
(Windows), and UNIX (X windows) platforms. You can write your scripts
once and they will execute on any of these platforms.

   Lastly, the software is distributed under a free software license
and so is available in both binary and source formats free of charge.


File: sicstus.info,  Node: What Is Tcl/Tks Relationship to SICStus Prolog?,  Next: A Quick Example of Tcl/Tk in Action,  Prev: What Is Tcl/Tk Good For?,  Up: Introduction (Tcl)

10.38.1.3 What Is Tcl/Tks Relationship to SICStus Prolog?
.........................................................

SICStus Prolog comes with a Prolog library for interfacing to Tcl/Tk.
The purpose of the library is to enable Prolog application developers to
add GUIs to their applications rapidly and easily.


File: sicstus.info,  Node: A Quick Example of Tcl/Tk in Action,  Next: Outline of This Tutorial,  Prev: What Is Tcl/Tks Relationship to SICStus Prolog?,  Up: Introduction (Tcl)

10.38.1.4 A Quick Example of Tcl/Tk in Action
.............................................

As a taster, we will show you two simple examples programs that use
SICStus Prolog with the Tcl/Tk extensions: the ubiquitous "hello world"
example; and a very simple telephone book look up example.

   You are not expected to understand how these examples work at this
stage.  They are something for you to quickly type in to see how easy it
is to add GUIs to Prolog programs through Tcl/Tk.  After reading
through the rest of this tutorial you will fully understand these
examples and be able to write your own GUIs.

   Here is the "Hello World" program; also in
`library('tcltk/examples/ex1.pl')':

     :- use_module(library(tcltk)).

     go :-
         tk_new([name('Example 1')], Interp),
         tcl_eval(Interp, 'button .fred -text "hello world"
                           -command { puts "hello world"}', _),
         tcl_eval(Interp, 'pack .fred', _),
         tk_main_loop.


 [image src="images/tcltkex1.png" text="" ]                   SICStus+Tcl/Tk hello world program.

To run it just start up SICStus (under Windows use `sicstus', not
`spwin'), load the program, and evaluate the Prolog goal `go'. The
first line of the `go' clause calls `tk_new/2', which creates a Tcl/Tk
interpreter and returns a handle `Interp' through which Prolog will
interact with the interpreter.  Next a call to `tcl_eval/3' is made,
which creates a button displaying the `hello world' text. Next a call
is made to `tcl_eval/3' that causes the button to be displayed in the
main application window. Finally, a call is make to `tk_main_loop/0'
that passes control to Tcl/Tk, making sure that window events are
serviced.

   See how simple it is with just a three line Prolog program to create
an application window and display a button in it.  Click on the button
and see what it does.

   The reason you should use `sicstus' under Windows instead of `spwin'
is that the latter does not have the C standard streams
(`stdin',`stdout',`stderr') and the Tcl command `puts' will give an
error if there is no `stdout'.

   The previous example showed us how to create a button and display
some text in it. It was basically pure Tcl/Tk generated from within
Prolog but did not have any interaction with Prolog.  The following
example demonstrates a simple callback mechanism. A name is typed into
a text entry box, a button is pressed, which looks up the telephone
number corresponding to the name in a Prolog database, and the telephone
number is then displayed.

   Here is the code; also in `library('tcltk/examples/ex2.pl')':

     :- use_module(library(tcltk)).

     telephone(fred, '123-456').
     telephone(wilbert, '222-2222').
     telephone(taxi, '200-0000').
     telephone(mary, '00-36-1-666-6666').

     go :-
          tk_new([name('Example 2')], T),
          tcl_eval(T, 'entry .name -textvariable name',_),
          tcl_eval(T, 'button .search -text search -command {
                           prolog telephone($name,X);
                           set result $prolog_variables(X) }', _),
          tcl_eval(T, 'label .result -relief raised -textvariable result', _),
          tcl_eval(T, 'pack .name .search .result -side top -fill x', _),
          tk_main_loop.


 [image src="images/tcltkex2.png" text="" ]                 SICStus+Tcl/Tk telephone number lookup

Again, to run the example, start up SICStus Prolog, load the code, and
run the goal `go'.

   You will notice that three widgets will appear in a window: one is
for entering the name of the person or thing that you want to find the
telephone number for, the button is for initiating the search, and the
text box at the bottom is for displaying the result.

   Type `fred' into the entry box, hit the search button and you should
see the phone number displayed. You can then try the same thing but
with `wilbert', `taxi' or `mary' typed into the text entry box.

   What is happening is that when the button is pressed, the value in
the entry box is retrieved, then the `telephone/2' predicate is called
in Prolog with the entry box value as first argument, then the second
argument of telephone is retrieved (by this time bound to the number)
and is displayed below the button.

   This is a very crude example of what can be done with the Tcl/Tk
module in Prolog. For example, this program does not handle cases where
there is no corresponding phone number or where there is more than one
corresponding phone number.  The example is just supposed to wet your
appetite, but all these problems can be handled by Prolog + Tcl/Tk,
although with a more sophisticated program. You will learn how to do
this in the subsequent chapters.


File: sicstus.info,  Node: Outline of This Tutorial,  Prev: A Quick Example of Tcl/Tk in Action,  Up: Introduction (Tcl)

10.38.1.5 Outline of This Tutorial
..................................

Now we have motivated using Tcl/Tk as a means of creating GUIs for
Prolog programs, this document goes into the details of using Tcl/Tk as
a means of building GUIs for SICStus Prolog applications.

   Firstly, Tcl is introduced and its syntax and core commands
described.  Then the Tk extensions to Tcl are introduced. We show how
with Tcl and Tk together the user can build sophisticated GUIs easily
and quickly.  At the end of this Tcl/Tk part of the tutorial an example
of a pure Tcl/Tk program will be presented together with some tips on
how to design and code Tcl/Tk GUIs.

   The second phase of this document describes the SICStus Prolog
`tcltk' library. It provides extensions to Prolog that allow Prolog
applications to interact with Tcl/Tk: Prolog can make calls to Tcl/Tk
code and vice versa.

   Having reached this point in the tutorial the user will know how to
write a Tcl/Tk GUI interface and how to get a Prolog program to
interact with it, but arranging which process (the Prolog process or the
Tcl/Tk process) is the dominant partner is non-trivial and so is
described in a separate chapter on event handling. This will help the
user choose the most appropriate method of cooperation between Tcl/Tk
and Prolog to suit their particular application.

   This section, the Tcl/Tk+Prolog section, will be rounded off with
the presentation of some example applications that make use of Tcl/Tk
and Prolog.

   Then there is a short discussion section on how to use other Tcl
extension packages with Tcl/Tk and Prolog. Many such extension packages
have been written and when added to Prolog enhanced with Tcl/Tk can
offer further functionality to a Prolog application.

   The appendices provide a full listing with description of the
predicates available in the `tcltk' SICStus Prolog library, and the
extensions made to Tcl/Tk for interacting with Prolog.

   Lastly, a section on resources gives pointers to where the reader can
find more information on Tcl/Tk.


File: sicstus.info,  Node: Tcl,  Next: Tk,  Prev: Introduction (Tcl),  Up: lib-tcltk

10.38.2 Tcl
-----------

Tcl is an interpreted scripting language. In this chapter, first the
syntax of Tcl is described and then the core commands are described.
It is not intended to give a comprehensive description of the Tcl
language here but an overview of the core commands, enough to get the
user motivated to start writing their own scripts.

   For pointers to more information on Tcl; *note Resources::.

* Menu:

* Syntax (Tcl):: Syntax
* Variables (Tcl):: Variables
* Commands:: Commands
* What We Have Left Out (Tcl):: What We Have Left Out


File: sicstus.info,  Node: Syntax (Tcl),  Next: Variables (Tcl),  Up: Tcl

10.38.2.1 Syntax
................

A Tcl script consists of a series of strings separated from each other
by a newline character. Each string contains a command or series of
semi-colon separated commands.  A command is a series of words separated
by spaces. The first word in a command is the name of the command and
subsequent words are its arguments.

   An example is:

     set a 1
     set b 2

which is a Tcl script of two commands: the first command sets the value
of variable `a' to `1', and the second command sets the value of
variable `b' to `2'.

   An example of two commands on the same line separated by a semi-colon
is:

     set a 1; set b 2

which is equivalent to the previous example but written entirely on one
line.

   A command is executed in two phases.  In the first phase, the
command is broken down into its constituent words and various textual
substitutions are performed on those words.  In the second phase, the
procedure to call is identified from the first word in the command, and
the procedure is called with the remaining words as arguments.

   There are special syntactic characters that control how the first
phase, the substitution phase, is carried out. The three major
substitution types are variable substitution, command substitution, and
backslash substitution.

   _Variable substitution_ happens when a `$' prefixed word is found in
a command.  There are three types of variable substitution:

   - `$NAME'
        - where NAME is a scalar variable. NAME is simply substituted
          in the word for its value. NAME can contain only letters,
          digits, or underscores.

   - `$NAME(INDEX)'
        - where NAME is the name of an array variable and INDEX is the
          index into it. This is substituted by the value of the array
          element.  NAME must contain only letters, digits, or
          underscores.  INDEX has variable, command, and backslash
          substitution performed on it too.

   - `${NAME}'
        - where NAME can have any characters in it except closing curly
          bracket.  This is more or less the same as `$NAME'
          substitution except it is used to get around the restrictions
          in the characters that can form NAME.

   An example of variable substitution is:

     set a 1
     set b $a

which sets the value of variable `a' to `1', and then sets the value of
variable `b' to the value of variable `a'.

   _Command substitution_ happens when a word contains an open square
bracket, `['. The string between the open bracket and matching closing
bracket are treated as a Tcl script. The script is evaluated and its
result is substituted in place of the original command substitution
word.

   A simple example of command substitution is:

     set a 1
     set b [set a]

which does the same as the previous example but using command
substitution.  The result of a `set a' command is to return the value
of `a', which is then passed as an argument to `set b' and so variable
`b' acquires the value of variable `a'.

   _Backslash substitution_ is performed whenever the interpreter comes
across a backslash.  The backslash is an escape character and when it is
encountered is causes the interpreter to handle the next characters
specially.  Commonly escaped characters are `\a' for audible bell, `\b'
for backspace, `\f' for form feed, `\n' for newline, `\r' for carriage
return, `\t' for horizontal tab, and `\v' for vertical tab.
Double-backslash, `\\', is substituted with a single backslash.  Other
special backslash substitutions have the following forms:

   * `\ooo'
        - the digits `ooo' give the octal value of the escaped character

   * `\xHH'
        - the `x' denotes that the following hexadecimal digits are the
          value of the escaped character

   Any other character that is backslash escaped is simply substituted
by the character itself. For example, `\W' is replaced by `W'.

   A further syntactic construction is used to _delay substitution_.
When the beginning of a word starts with a curly bracket, `{', it does
not do any of the above substitutions between the opening curly bracket
and its matching closing curly bracket.  The word ends with the
matching closing curly bracket.  This construct is used to make the
bodies of procedures in which substitutions happen when the procedure is
called, not when it is constructed.  Or it is used anywhere when the
programmer does not want the normal substitutions to happen. For
example:

     puts {I have $20}

will print the string `I have $20' and will not try variable
substitution on the `$20' part.

   A word delineated by curly brackets is replaced with the characters
within the brackets without performing the usual substitutions.

   A word can begin with a _double-quote_ and end with the matching
closing double-quote. Substitutions as detailed above are done on the
characters between the quotes, and the result is then substituted for
the original word. Typically double-quotes are used to group sequences
of characters that contain spaces into a single command word.

   For example:

     set name "Fred the Great"
     puts "Hello my name is $name"

outputs `Hello my name is Fred the Great'. The first command sets the
value of variable `name' to the following double-quoted string `"Fred
the Great"'. The the next command prints its argument, a single
argument because it is a word delineated by double-quotes, that has had
variable substitution performed on it.

   Here is the same example but using curly brackets instead of
double-quotes:

     set name {Fred the Great}
     puts {Hello my name is $name}

gives the output `Hello my name is $name' because substitutions are
suppressed by the curly bracket notation.

   And again the same example but without either curly brackets or
double-quotes:

     set name Fred the Great
     puts Hello my name is $name

simply fails because both `set' and `puts' expect a single argument but
without the word grouping effects of double-quotes or curly brackets
they find that they have more than one argument and throw an exception.

   Being a simple scripting language, Tcl does not have any real idea of
data types. The interpreter simply manipulates strings.  The Tcl
interpreter is not concerned with whether those strings contain
representations of numbers or names or lists.  It is up to the commands
themselves to interpret the strings that are passed to them as
arguments in any manner those choose.


File: sicstus.info,  Node: Variables (Tcl),  Next: Commands,  Prev: Syntax (Tcl),  Up: Tcl

10.38.2.2 Variables
...................

This has been dealt with implicitly above.  A variable has a name and a
value.  A name can be any string whatsoever, as can its value.

   For example,

     set "Old King Cole" "merry soul"

sets the value of the variable named `Old King Cole' to the value
`merry soul'. Variable names can also be numbers:

     set 123 "one two three"

sets the variable with name `123' to the value `one two three'.  In
general, it is better to use the usual conventions -- start with a
letter then follow with a combination of letters, digits, and
underscores -- when giving variables names to avoid confusion.

   Array variables are also available in Tcl. These are denoted by an
array name followed by an array index enclosed in round brackets.  As
an example:

     set fred(one) 1
     set fred(two) 2

will set the variable `fred(one)' to the value `1' and `fred(two)' to
the value `2'.

   Tcl arrays are associative arrays in that both the array name and the
array index can be arbitrary strings. This also makes multidimensional
arrays possible if the index contains a comma:

     set fred(one,two) 12

   It is cheating in that the array is not stored as a multidimensional
array with a pair of indices, but as a linear array with a single index
that happens to contain a comma.


File: sicstus.info,  Node: Commands,  Next: What We Have Left Out (Tcl),  Prev: Variables (Tcl),  Up: Tcl

10.38.2.3 Commands
..................

Now that the Tcl syntax and variables have been been dealt with, we
will now look at some of the commands that are available.

   Each command when executed returns a value. The return value will be
described along with the command.

   A quick word about the _notation_ used to describe Tcl commands.  In
general, a description of a command is the name of the command followed
by its arguments separated by spaces.  An example is:

     set VARNAME ?VALUE?

which is a description of the Tcl set command, which takes a variable
name VARNAME and an optional argument, a VALUE.

   Optional arguments are enclosed in question mark, ?, pairs, as in
the example.

   A series of three dots ... represents repeated arguments. An example
is a description of the `unset' command:

     unset VARNAME ?VARNAME VARNAME ...?

which shows that the `unset' command has at least one compulsory
argument VARNAME but has any number of subsequent optional arguments.

   The most used _command over variables_ is the `set' command.  It has
the form

     set VARNAME ?VALUE?

   The value of VALUE is determined, the variable VARNAME is set to it,
and the value is returned. If there is no VALUE argument, the value of
the variable is simply returned. It is thus used to set and/or get the
value of a variable.

   The `unset' command is used to remove variables completely from the
system:

     unset VARNAME ?VARNAME VARNAME ...?

which given a series of variable names deletes them.  The empty string
is always returned.

   There is a special command for incrementing the value of a variable:

     incr VARNAME ?INCREMENT?

which, given the name of a variable thats value is an integer string,
increments it by the amount INCREMENT. If the INCREMENT part is left
out, it defaults to `1'. The return value is the new value of the
variable.

   _Expressions_ are constructed from operands and operators and can
then be evaluated.  The most general expression evaluator in Tcl is the
`expr' command:

     expr ARG ?ARG ARG ... ARG?

which evaluates its arguments as an expression and returns the value of
the evaluation.

   A simple example expression is

     expr 2 * 2

which when executed returns the value `4'.

   There are different classes of operators: arithmetic, relational,
logical, bitwise, and choice.  Here are some example expressions
involving various operators:

arithmetic     `$x * 2'
relational     `$x > 2'
logical        `($x == $y) || ($x == $z)'
bitwise        `8 & 2'
choice         `($a == 1) ? $x : $y'

   Basically the operators follow the syntax and meaning of their ANSI
C counterparts.

   Expressions to the `expr' command can be contained in curly brackets
in which case the usual substitutions are not done before the `expr'
command is evaluated, but the command does its own round of
substitutions. So evaluating a script such as:

     set a 1
     expr { ($a==1) : "yes" ? "no" }

will evaluate to `yes'.

   Tcl also has a whole host of math functions that can be used in
expressions.  Their evaluation is again the same as that for their ANSI
C counterparts.  For example:

     expr { 2*log($x) }

will return 2 times the natural log of the value of variable `x'.

   Tcl has a notion of _lists_, but as with everything it is implemented
through strings. A list is a string that contains words.

   A simple list is just a space separated series of strings:

     set a {one two three four five}

will set the variable `a' to the list containing the five strings
shown. The empty list is denoted by an open and close curly bracket
pair with nothing in between: `{}'.

   For the Prolog programmer, there is much confusion between a Prolog
implementation of lists and the Tcl implementation of lists.  In Prolog
we have a definite notion of the printed representation of a list: a
list is a sequence of terms enclosed in square brackets (we ignore dot
notation for now); a nested list is just another term.

   In Tcl, however, a list is really just a string that conforms to a
certain syntax: a string of space separated words.  But in Tcl there is
more than one way of generating such a string.  For example,

     set fred {a b c d}

sets `fred' to

     "a b c d"

as does

     set fred "a b c d"

because `{a b c d}' evaluates to the string `a b c d', which has the
correct syntax for a list.  But what about nested lists?  Those are
represented in the final list-string as being contained in curly
brackets.  For example:

     set fred {a b c {1 2 3} e f}

results in `fred' having the value

     "a b c {1 2 3} e f"

   The outer curly brackets from the `set' command have disappeared,
which causes confusion. The curly brackets within a list denote a nested
list, but there are no curly brackets at the top-level of the list.  (We
can't help thinking that life would have been easier if the creators of
Tcl would have chosen a consistent representation for lists, as Prolog
and LISP do.)

   So remember: a list is really a string with a certain syntax, space
separated items or words; a nested list is surrounded by curly brackets.

   There are a dozen commands that operate on lists.

     concat ?LIST LIST ...?

   This makes a list out of a series of lists by concatenating its
argument lists together. The return result is the list resulting from
the concatenation.

     lindex LIST INDEX

returns the INDEX-th element of the LIST.  The first element of a list
has an index of 0.

     linsert LIST INDEX VALUE ?VALUE ...?

returns a new list in which the VALUE arguments have been inserted in
turn before the INDEX-th element of LIST.

     list ?VALUE VALUE ...?

returns a list where each element is one of the VALUE arguments.

     llength LIST

returns the number of elements in list LIST.

     lrange LIST FIRST LAST

returns a slice of a list consisting of the elements of the list LIST
from index FIRST until index LAST.

     lreplace LIST FIRST LAST ?VALUE ... VALUE?

returns a copy of list LIST but with the elements between indices FIRST
and LAST replaced with a list formed from the VALUE arguments.

     lsearch ?-exact? ?-glob? ?-regexp? LIST PATTERN

returns the index of the first element in the list that matches the
given pattern. The type of matching done depends on which of the switch
is present `-exact', `-glob', `-regexp', is present. Default is `-glob'.

     lsort ?-ascii? ?-integer? ?-real? ?-command COMMAND? ?-increasing? ?-decreasing{? LIST

returns a list, which is the original list LIST sorted by the chosen
technique. If none of the switches supplies the intended sorting
technique, the user can provide one through the `-command COMMAND'
switch.

   There are also two useful commands for converting between lists and
strings:

     join LIST ?JOINSTRING?

which concatenates the elements of the list together, with the separator
JOINSTRING between them, and returns the resulting string.  This can be
used to construct filenames; for example:

     set a {{} usr local bin}
     set filename [join $a /]

results in the variable `filename' having the value `/usr/local/bin'.

   The reverse of the `join' command is the `split' command:

     split STRING ?SPLITCHARS?

which takes the string STRING and splits it into string on SPLITCHARS
boundaries and returns a list with the strings as elements.  An example
is splitting a filename into its constituent parts:

     set a [split /usr/local/src /]

gives `a' the value `{{} usr local src}', a list.

   Tcl has the four usual classes of _control flow_ found in most other
programming languages:

     if...elseif...else, while, for, foreach, switch, and eval.

   We go through each in turn.

   The general form of an `if' command is the following:

     if TEST1 BODY1 ?ELSEIF TEST2 BODY2 ELSEIF ...? ?ELSE BODYN?

which when evaluated, evaluates expression TEST1, which if true causes
BODY1 to be evaluated, but if false, causes TEST2 to be evaluated, and
so on.  If there is a final `else' clause, its BODYN part is evaluated
if all of the preceding tests failed.  The return result of an `if'
statement is the result of the last BODY command evaluated, or the
empty list if none of the bodies are evaluated.

   Conditional looping is done through the `while' command:

     while TEST BODY

which evaluates expression TEST, which if true then evaluates BODY.  It
continues to do that until TEST evaluates to 0, and returns the empty
string.

   A simple example is:

     set a 10
     while {$a > 0} { puts $a; incr a -1 }

which initializes variable `a' with value ten and then loops printing
out the value of `a' and decrementing it until its value is 0, when the
loop terminates.

   The `for' loop has the following form:

     for INIT TEST REINIT BODY

which initializes the loop by executing INIT, then each time around the
loop the expression TEST is evaluated, which if true causes BODY to be
executed and then executes REINIT. The loop spins around until TEST
evaluates to 0.  The return result of a `for' loop is the empty string.

   An example of a `for' loop:

     for {set a 10} ($a>0) {incr a -1} {puts $a}

which initializes the variable `a' with value `10', then goes around
the loop printing the value of `a' and decrementing it as long as its
value is greater than `0'.  Once it reaches `0' the loop terminates.

   The `foreach' command has the following form:

     foreach VARNAME LIST BODY

where VARNAME is the name of a variable, LIST is an instance of a list,
and BODY is a series of commands to evaluate.  A `foreach' then
iterates over the elements of a list, setting the variable VARNAME to
the current element, and executes BODY.  The result of a `foreach' loop
is always the empty string.

   An example of a `foreach' loop:

     foreach friend {joe mary john wilbert} {puts "I like $friend"}

will produce the output:

     I like joe
     I like mary
     I like john
     I like wilbert

   There are also a couple of commands for controlling the flow of
loops: `continue' and `break'.

   `continue' stops the current evaluation of the body of a loop and
goes on to the next one.

   `break' terminates the loop altogether.

   Tcl has a general switch statement, which has two forms:

     switch ?OPTIONS? STRING PATTERN BODY ?PATTERN BODY ... ?
     switch ?OPTIONS? STRING { PATTERN BODY ?PATTERN BODY ...? }

   When executed, the switch command matches its STRING argument
against each of the PATTERN arguments, and the BODY of the first
matching pattern is evaluated.  The matching algorithm depends on the
options chosen, which can be one of

`-exact'      use exact matching
`-glob'       use glob-style matching
`-regexp'     use regular expression matchinig

   An example is:

     set a rob
     switch -glob $a {
         a*z { puts "A to Z"}
         r*b { puts "rob or rab"}
     }

which will produce the output:

     rob or rab

   There are two forms of the `switch' command. The second form has the
command arguments surrounded in curly brackets. This is primarily so
that multi-line switch commands can be formed, but it also means that
the arguments in brackets are not evaluated (curly brackets suppress
evaluation), whereas in the first type of switch statement the
arguments are first evaluated before the switch is evaluated.  These
effects should be borne in mind when choosing which kind of switch
statement to use.

   The final form of control statement is `eval':

     eval ARG ?ARG ...?

which takes one or more arguments, concatenates them into a string, and
executes the string as a command. The return result is the normal
return result of the execution of the string as a command.

   An example is

     set a b
     set b 0
     eval set $a 10

which results in the variable `b' being set to `10'.  In this case, the
return result of the `eval' is `10', the result of executing the string
`"set b 10"' as a command.

   Tcl has several _commands over strings_. There are commands for
searching for patterns in strings, formatting and parsing strings (much
the same as `printf' and `scanf' in the C language), and general string
manipulation commands.

   Firstly we will deal with formatting and parsing of strings.  The
commands for this are `format' and `scan' respectively.

     format FORMATSTRING ?VALUE VALUE ...?

which works in a similar to C's `printf'; given a format string with
placeholders for values and a series of values, return the appropriate
string.

   Here is an example of printing out a table for base 10 logarithms
for the numbers 1 to 10:

     for {set n 1} {$n <= 10} {incr n} {
         puts [format "log10(%d) = %.4f" $n [expr log10($n)]]
     }

which produces the output

     ln(1) = 0.0000
     ln(2) = 0.3010
     ln(3) = 0.4771
     ln(4) = 0.6021
     ln(5) = 0.6990
     ln(6) = 0.7782
     ln(7) = 0.8451
     ln(8) = 0.9031
     ln(9) = 0.9542
     ln(10) = 1.0000

   The reverse function of `format' is `scan':

     scan STRING FORMATSTRING VARNAME ?VARNAME ...?

which parses the string according to the format string and assigns the
appropriate values to the variables.  it returns the number of fields
successfully parsed.

   An example,

     scan "qty 10, unit cost 1.5, total 15.0" \
          "qty %d, unit cost %f, total %f"    \
          quantity cost_per_unit total

would assign the value 10 to the variable `quantity', 1.5 to the
variable `cost_per_unit' and the value 15.0 to the variable `total'.

   There are commands for performing two kinds of pattern matching on
strings: one for matching using regular expressions, and one for
matching using UNIX-style wildcard pattern matching (globbing).

   The command for regular expressions matching is as follows:

     regexp ?-indices? ?-nocase? EXP STRING ?MATCHVAR? ?SUBVAR SUBVAR ...?

where EXP is the regular expression and STRING is the string on which
the matching is performed. The regexp command returns 1 if the
expression matches the string, 0 otherwise.  The optional `-nocase'
switch does matching without regard to the case of letters in the
string.  The optional MATCHVAR and SUBVAR variables, if present, are
set to the values of string matches. In the regular expression, a match
that is to be saved into a variable is enclosed in round braces.  An
example is

     regexp {([0-9]+)} "I have 3 oranges" a

will assign the value 3 to the variable `a'.

   If the optional switch `-indices' is present, instead of storing the
matching substrings in the variables, the indices of the substrings are
stored; that is a list with a pair of numbers denoting the start and
end position of the substring in the string.  Using the same example:

     regexp -indices {([0-9]+)} "I have 3 oranges" a

will assign the value `"7 7"', because the matched numeral `3' is in
the eighth position in the string, and indices count from 0.

   String matching using the UNIX-style wildcard pattern matching
technique is done through the `string match' command:

     string match PATTERN STRING

where PATTERN is a wildcard pattern and STRING is the string to match.
If the match succeeds, the command returns 1; otherwise, it returns 0.
An example is

     string match {[a-z]*[0-9]} {a_$%^_3}

which matches because the command says match any string that starts
with a lower case letter and ends with a number, regardless of anything
in between.

   There is a command for performing string substitutions using regular
expressions:

     regsub ?-all? ?-nocase? EXP STRING SUBSPEC VARNAME

where EXP is the regular expression and STRING is the input string on
which the substitution is made, SUBSPEC is the string that is
substituted for the part of the string matched by the regular
expression, and VARNAME is the variable on which the resulting string
is copied into.  With the `-nocase' switch, the matching is done
without regard to the case of letters in the input string.  The `-all'
switch causes repeated matching and substitution to happen on the input
string.  The result of a `regsub' command is the number of
substitutions made.

   An example of string substitution is:

     regsub {#name#} {My name is #name#} Rob result

which sets the variable `result' to the value "My name is Rob".  An
example of using the `-all' switch:

     regsub -all {#name#} {#name#'s name is #name#} Rob result

sets the variable `result' to the value "Rob's name is Rob" and it
returns the value 2 because two substitutions were made.

   The are a host of other ways to manipulate strings through variants
of the `string' command. Here we will go through them.

   To select a character from a string given the character position,
use the `string index' command. An example is:

     string index "Hello world" 6

which returns `w', the 7th character of the string.  (Strings are
indexed from 0).

   To select a substring of a string, given a range of indices use the
`string range' command. An example is:

     string range "Hello world" 3 7

which returns the string "lo wo".  There is a special index marker
named `end', which is used to denote the the end of a string, so the
code

     string range "Hello world" 6 end

will return the string "world".

   There are two ways to do simple search for a substring on a string,
using the `string first' and `string last' commands.  An example of
`string first' is:

     string first "dog" "My dog is a big dog"

find the first position in string "My dog is a big dog" that matches
"dog".  It will return the position in the string in which the
substring was found, in this case 3. If the substring cannot be found,
the value -1 is returned.

   Similarly,

     string last "dog" "My dog is a big dog"

will return the value 16 because it returns the index of the last place
in the string that the substring matches.  Again, if there is no match,
-1 is returned.

   To find the length of a string use `string length', which given a
string simply returns its length.

     string length "123456"

returns the value 6.

   To convert a string completely to upper case use `string toupper':

     string toupper "this is in upper case"

returns the string "THIS IS IN UPPER CASE".

   Similarly,

     string tolower "THIS IS IN LOWER CASE"

returns the string "this is in lower case".

   There are commands for removing characters from strings: `string
trim', `string trimright', and `string trimleft'.

     string trim STRING ?CHARS?

which removes the characters in the string CHARS from the string STRING
and returns the trimmed string.  If CHARS is not present, whitespace
characters are removed.  An example is:

     string string "The dog ate the exercise book" "doe"

which would return the string "Th g at th xrcis bk".

   `string trimleft' is the same as `string trim' except only leading
characters are removed. Similarly `string trimright' removes only
trailing characters.  For example:

     string trimright $my_input

would return a copy of the string contained in `$my_input' but with all
the trailing whitespace characters removed.

   There is a comprehensive set of commands for _file manipulation_.
We will cover only the some of the more important ones here.

   To open a file the `open' command is used:

     open NAME ?ACCESS?

where NAME is a string containing the filename, and the option ACCESS
parameter contains a string of access flags, in the UNIX style.  The
return result is a handle to the open file.

   If ACCESS is not present, the access permissions default to `"r"',
which means open for reading only.  The command returns a file handle
that can be used with other commands.  An example of the use of the
`open' command is

     set fid [open "myfile" "r+"]

which means open the file `myfile' for both reading and writing and set
the variable `fid' to the file handle returned.

   To close a file simply use

     close FILEID

   For example,

     close $fid

will close the file that has the file handle stored in the variable
`fid'.

   To read from a file, the `read' command is used:

     read FILEID NUMBYTES

which reads NUMBYTES bytes from the file attached to file handle
FILEID, and returns the bytes actually read.

   To read a single line from a file use `gets':

     gets FILEID ?VARNAME?

which reads a line from the file attached to file handle FILEID but
chops off the trailing newline. If variable VARNAME is specified, the
string read in is stored there and the number of bytes is returned by
the command. If the variable is not specified, the command returns the
string only.

   To write to a file, use `puts':

     puts ?-nonewline? ?FILEID? STRING

which outputs the string STRING. If the file handle FILEID is present,
the string is output to that file; otherwise, it is printed on
`stdout'.  If the switch `-nonewline' is present, a trailing newline is
not output.

   To check if the end of a file has been reached, use `eof':

     eof FILEID

which, given a file handle FILEID returns 1 if the end has been reached,
and 0 otherwise.

   The are a host of other commands over files and processes, which we
will not go into here.

   (For extra information on file I/O commands, refer to the Tcl manual
pages.)

   Tcl provides a way of _creating new commands_, called procedures,
that can be executed in scripts. The arguments of a procedure can be
call-by-value or call-by-reference, and there is also a facility for
creating new user defined control structures using procedures.

   A procedure is declared using the `proc' command:

     proc NAME ARGLIST BODY

where the name of the procedure is NAME, the arguments are contained in
ARGLIST and the body of the procedure is the script BODY.  An example
of a procedure is:

     proc namePrint { first family } {
         puts "My first name is $first"
         puts "My family name is $family"
     }

which can be called with

     namePrint Tony Blair

to produce the output:

     My first name is Tony
     My family name is Blair

   A procedure with no arguments is specified with an empty argument
list.  An example is a procedure that just prints out a string:

     proc stringThing {} {
         puts "I just print this string"
     }

   Arguments can be given defaults by pairing them with a value in a
list.  An example here is a counter procedure:

     proc counter { value { inc 1 } } {
         eval $value + $inc
     }

which can be called with two arguments like this

     set v 10
     set v [counter $v 5]

which will set variable `v' to the value 15; or it can be called with
one argument:

     set v 10
     set v [counter $v]

in which case `v' will have the value 11, because the default of the
argument `inc' inside the procedure is the value 1.

   There is a special argument for handling procedures with variable
number of arguments, the `args' argument.  An example is a procedure
that sums a list of numbers:

     proc sum { args } {
         set result 0;

         foreach n $args {
          set result [expr $result + $n ]
         }

         return $result;
     }

which can be called like this:

     sum 1 2 3 4 5

which returns the value 15.

   The restriction on using defaulted arguments is that all the
arguments that come after the defaulted ones must also be defaulted.
If `args' are used, it must be the last argument in the argument list.

   A procedure can return a value through the `return' command:

     return ?OPTIONS? ?VALUE?

which terminates the procedure returning value VALUE, if specified, or
just causes the procedure to return, if no value specified.  (The
?OPTIONS? part has to do with raising exceptions, which we will will
not cover here.)

   The return result of a user defined procedure is the return result
of the last command executed by it.

   So far we have seen the arguments of a procedure are passed using
the call-by-value mechanism.  They can be passed call by reference using
the `upvar' command:

     upvar ?LEVEL? OTHERVAR1 MYVAR1 ?OTHERVAR2 MYVAR2 ...?

which makes accessible variables somewhere in a calling context with the
current context. The optional argument LEVEL describes how many calling
levels up to look for the variable.  This is best shown with an example:

     set a 10
     set b 20

     proc add { first second } {
         upvar $first f $second s
         expr $f+$s
     }

which when called with

     add a b

will produce the result 30.  If you use call-by-value instead:

     add $a $b

the program will fail because when executing the procedure `add' it
will take the first argument 10 as the level argument, a bad level.
(Also variable `20' doesn't exist at any level.)

   New control structures can be generated using the `uplevel' command:

     uplevel ?LEVEL? ARG ?ARG ARG ...?

which is like `eval', but it evaluates its arguments in a context
higher up the calling stack. How far up the stack to go is given by the
optional LEVEL argument.

     proc do { loop condition } {
         set nostop 1

         while { $nostop } {
             uplevel $loop
             if {[uplevel "expr $condition"] == 0} {
                 set nostop 0
              }
         }
     }

which when called with this

     set x 5
     do { puts $x; incr x -1 } { $x > 0 }

will print

     5
     4
     3
     2
     1

   (*Please note*: this doesn't quite work for all kinds of calls
because of `break', `continue', and `return'. It is possible to get
around these problem, but that is outside the scope of this tutorial.)

   A word about the _scope of variables_. Variables used within
procedures are normally created only for the duration of that procedure
and have local scope.

   It is possible to declare a variable as having global scope, through
the `global' command:

     global NAME1 ? NAME2 ...?

where NAME1, NAME2, ..., are the names of global variables.  Any
references to those names will be taken to denote global variables for
the duration of the procedure call.

   Global variables are those variables declared at the topmost calling
context. It is possible to run a `global' command at anytime in a
procedure call. After such a command, the variable name will refer to a
global variable until the procedure exits.

   An example:

     set x 10

     proc fred { } {
         set y 20
         global x
         puts [expr $x + $y]
     }

     fred

will print the result `30' where 20 comes from the local variable `y'
and 10 comes from the global variable `x'.

   Without the `global x' line, the call to `fred' will fail with an
error because there is no variable `x' defined locally in the procedure
for the `expr' to evaluate over.

   In common with other scripting languages, there is a command for
_evaluating the contents of a file_ in the Tcl interpreter:

     source FILENAME

where FILENAME is the filename of the file containing the Tcl source to
be evaluated. Control returns to the Tcl interpreter once the file has
been evaluated.


File: sicstus.info,  Node: What We Have Left Out (Tcl),  Prev: Commands,  Up: Tcl

10.38.2.4 What We Have Left Out
...............................

We have left out a number of Tcl commands as they are outside of the
scope of this tutorial. We list some of them here to show some of what
Tcl can do. Please refer to the Tcl manual for more information.

"http"
     implements the HTTP protocol for retrieving web pages

"namespaces"
     a modules systems for Tcl

"trace"
     commands can be attached to variables that are triggered when the
     variable changes value (amongst other things)

"processes"
     start, stop, and manage processes

"sockets"
     UNIX and Internet style socket management

"exception handling"

"3rd party extension packages"
     load extension packages into Tcl and use their facilities as
     native Tcl commands


File: sicstus.info,  Node: Tk,  Next: The Tcl/Tk Prolog Library,  Prev: Tcl,  Up: lib-tcltk

10.38.3 Tk
----------

Tk is an extension to Tcl. It provides Tcl with commands for easily
creating and managing graphical objects, or widgets, so providing a way
to add graphical user interfaces (GUIs) to Tcl applications.

   In this section we will describe the main Tk widgets, the Tcl
commands used to manipulate them, how to give them behaviors, and
generally how to arrange them into groups to create a GUI.

* Menu:

* Widgets:: Widgets
* Types of Widget:: Types of Widget
* Widgets Hierarchies:: Widgets Hierarchies
* Widget Creation:: Widget Creation
* Geometry Managers:: Geometry Managers
* Event Handling:: Event Handling
* Miscellaneous:: Miscellaneous
* What We Have Left Out (Tk):: What We Have Left Out
* Queens Display:: Example pure Tcl/Tk program


File: sicstus.info,  Node: Widgets,  Next: Types of Widget,  Up: Tk

10.38.3.1 Widgets
.................

A widget is a "window object". It is something that is displayed that
has at least two parts: a state and a behavior.  An example of a widget
is a button.  Its state is things like what color is it, what text is
written it in, and how big it is.  Its behavior is things like what it
does when you click on it, or what happens when the cursor is moved
over or away from it.

   In Tcl/Tk there are three parts to creating a useful widget.  The
first is creating an instance of the widget with its initial state.
The second is giving it a behavior by defining how the widget behaves
when certain events happen -- event handling.  The third is actually
displaying the widget possibly in a group of widgets or inside another
widget -- geometry management.  In fact, after creating all the widgets
for a GUI, they are not displayed until handled by a geometry manager,
which has rules about how to calculate the size of the widgets and how
they will appear in relation to each other.


File: sicstus.info,  Node: Types of Widget,  Next: Widgets Hierarchies,  Prev: Widgets,  Up: Tk

10.38.3.2 Types of Widget
.........................

In Tcl/Tk there are currently 15 types of widget.  In alphabetical
order they are (see also `library('tcltk/examples/widgets.tcl')'):

`button'
     a simple press button

`canvas'
     is a container for displaying "drawn" objects such as lines,
     circles, and polygons.

`checkbutton'
     a button that hold a state of either on or off

`entry'
     a text entry field

`frame'
     a widget that is a container for other widgets

`label'
     a simple label

`listbox'
     a box containing a list of options

`menu'
     a widget for creating menu bars

`menubutton'
     a button, which when pressed offers a selection of choices

`message'
     a multi-line text display widget

`radiobutton'
     a button used to form groups of mutually interacting buttons (When
     one button is pressed down, the others pop up.)

`scale'
     is like a slider on a music console. It consists of a trough scale
     and a slider. Moving the slider to a position on the scale sets
     the overall value of the widget to that value.

`scollbar'
     used to add scrollbars to windows or canvases. The scrollbar has a
     slider, which when moved changes the value of the slider widget.

`text'
     a sophisticated multi-line text widget that can also display other
     widgets such as buttons

`toplevel'
     for creating new standalone toplevel windows. (These windows are
     containers for other widgets. They are not terminal windows.)


 [image src="images/tcltkwidgets.png" text="" ]                        Meet The Main Tk Widgets


File: sicstus.info,  Node: Widgets Hierarchies,  Next: Widget Creation,  Prev: Types of Widget,  Up: Tk

10.38.3.3 Widgets Hierarchies
.............................

Before going further it is necessary to understand how instances of
widgets are named.  Widgets are arranged in a hierarchy. The names of
widget instances are formed from dot separated words.  The root window
is simply `.' on its own.  So for, example, a button widget that is
displayed in the root window might have the name `.b1'.  A button that
is displayed inside a frame that is displayed inside the root window
may have the name `.frame1.b1'.  The frame would have the name
`.frame1'.

   Following this notation, it is clear that widgets are both formed in
hierarchies, with the dot notation giving the path to a widget, and in
groups, all widgets with the same leading path are notionaly in the
same group.

   (It is a similar to the way file systems are organized.   A file has
a path that shows where to find it in the hierarchical  file system.
But also files with the same leading path are in the same
directory/folder and so are notionaly grouped together.)

   An instance of a widget is created through the a Tcl command for that
widget.  The widget command my have optional arguments set for
specifying various attributes of the widget that it will have when it is
created.  The result of a successful widget command is the name of the
new widget.

   For example, a command to create a button widget named `.mybutton'
that displays the text "I am a button" would look like this:

     button .mybutton -text "I am a button"

and this will return the name `.mybutton'.

   A widget will only be created if all the windows/widgets in the
leading path of the new widget also exist, and also that the name of
the new widget does not already exist.

   For example, the following

     button .mybutton -text "I am a button"
     button .mybutton -text "and so am I"

will fail at the second command because there is also a widget named
`.mybutton' from the first command.

   The following will also fail

     button .frame.mybutton -text "I am a button"

if there is no existing widget with the name `.frame' to be the parent
of `.mybutton'.

   All this begs the question: why are widgets named and arranged in a
hierarchy? Isn't a GUI just a bunch of widgets displayed in a window?

   This is not generally how GUIs are arranged.  For example, they
often have a menubar over the top of each window.  The menubar contains
pulldown menus. The pulldown menus may have cascading menu items that
may cascade down several levels.  Under the menu bar is the main part
of the window that may also be split into several "frames". A left hand
frame my have a set of buttons in it, for example. And so on.  From
this you can see that the widgets in GUIs are naturally arranged in a
hierarchy. To achieve this in Tcl/Tk instances of widgets are placed in
a hierarchy, which is reflected in their names.

   Now we will go through each of the widget commands in turn.  Each
widget command has many options most of which will not be described
here. Just enough will be touched on for the reader to understand the
basic operation of each widget.  For a complete description of each
widget and its many options refer to the Tk manual.


File: sicstus.info,  Node: Widget Creation,  Next: Geometry Managers,  Prev: Widgets Hierarchies,  Up: Tk

10.38.3.4 Widget Creation
.........................

As has already been said, a widget is a window object that has state and
behavior. In terms of Tcl/Tk a widget is created by calling a widget
creation command. There is a specific widget creation for each type of
widget.

   The widget creation command is supplied with arguments.  The first
argument is always the name you want to give to the resulting widget;
the other arguments set the initial state of the widget.

   The immediate result of calling a widget creation command is that it
returns the name of the new widget. A side-effect is that the instance
of the widget is created and its name is defined as in the Tcl
interpreter as a procedure through which the widget state can be
accessed and manipulated.

   This needs an example. We will use the widget creator command
`button' to make a button widget:

     button .fred -text 'Fred' -background red

which creates an instance of a button widget named `.fred' that will
display the text `Fred' on the button and will have a red background
color. Evaluating this command returns the string `.fred', the name of
the newly created widget.

   As a side-effect, a Tcl procedure named `.fred' is created.  A call
to a widget instance has the following form:

     WIDGETNAME METHOD METHODARGS

where WIDGETNAME is the name of the widget to be manipulated, METHOD is
the action to be performed on the widget, and METHODARGS are the
arguments passed to the method that is performed on the widget.

   The two standard methods for widgets are `configure' and `cget'.
`configure' - is used to change the state of a widget; for example:

     .fred configure -background green -text 'Sid'

will change the background color of the widget `.fred' to green and the
text displayed to `Sid'.

   `cget' is used to get part of the state of a widget; for example:

     .fred cget -text

will return `Sid' if the text on the button `.fred' is `Sid'.

   In addition to these general methods, there are special methods for
each widget type. For example, with button widgets you have the `flash'
and `invoke' methods.

   For example,

     .fred invoke

can be called somewhere in the Tcl code to invoke button `.fred' as
though it had been clicked on.

     .fred flash

can be called somewhere in the Tcl code to cause the button to flash.

   We will come across some of these special method when we discuss the
widgets in detail. For a comprehensive list of widget methods, refer to
entry for the appropriate widget creation command in the Tcl/Tk manual.

   We now discuss the widget creation command for each widget type.

   A _label_ is a simple widget for displaying a single line of text.
An example of creating an instance of a label is

     label .l -text "Hello world!"

which simply creates the label named `.l' with the text `Hello world!'
displayed in it.  Most widgets that display text can have a variable
associated with them through the option `-textvariable'. When the value
of the variable is changed the text changes in the associated label.
For example,

     label .l -text "Hello world!" -textvariable mytext

creates a text label called `.l' displaying the initial text `Hello
world!'  and associated text variable `mytext'; `mytext' will start
with the value `Hello world!'.  However, if the following script is
executed:

     set mytext "Goodbye moon!"

the text in the label will magically change to `Goodbye moon!'.

   A _message widget_ is similar to a label widget but for multi-line
text.  As its name suggests it is mostly used for creating popup message
information boxes.

   An example of a message widget is

     message .msg -text "Your data is incorrect.\n\n \
                   Please correct it and try again." \
         -justify center

which will create a message widget displaying the text shown, center
justified.  The width of the message box can be given through the
`-width' switch.  Any lines that exceed the width of the box are
wrapped at word boundaries.

   Calling the `button' command creates an instance of a _button
widget_.  An example is:

     button .mybutton -text "hello" -command {puts "howdie!"}

which creates a button with name `.mybutton' that will display the text
"hello" and will execute the Tcl script `puts "howdie!"' (that is print
`howdie!' to the terminal) when clicked on.

   _Checkbuttons_ are buttons that have a fixed state that is either on
or off. Clicking on the button toggles the state.  To store the state,
a checkbutton is associated with a variable.  When the state of the
checkbutton changes, so does that of the variable.  An example is:

     checkbutton .on_or_off -text "I like ice cream" -variable ice

which will create a checkbutton with name `.on_or_off' displaying the
text `I like ice cream' and associated with the variable `ice'.  If the
checkbutton is checked, `ice' will have the value 1; if not checked, it
will have the value 0.  The state of the checkbutton can also be
changed by changing the state of the variable. For example, executing

     set ice 0

will set the state of `.on_or_off' to not checked.

   _Radiobuttons_ are buttons that are grouped together to select one
value among many. Each button has a value, but only one in the button
group is active at any one time.  In Tcl/Tk this is achieved by
creating a series of radiobutton that share an associated variable.
Each button has a value. When a radiobutton is clicked on, the variable
has that value and all the other buttons in the group are put into the
off state.  Similarly, setting the value of the variable is reflected
in the state of the button group.  An example is:

     radiobutton .first -value one -text one -variable count
     radiobutton .second -value two -text two -variable count
     radiobutton .third -value three -text three -variable count

which creates three radiobuttons that are linked through the variable
`count'. If button `.second' is active, for example, the other two
buttons are in the inactive state and `count' has the value `two'.  The
following code sets the button group to make the button `.third' active
and the rest inactive regardless of the current state:

     set count three

   If the value of `count' does not match any of the values of the
radiobuttons, they will all be off. For example executing the script

     set count four

will turn all the radiobuttons off.

   An _entry widget_ allows input of a one line string.  An example of
an entry widget:

     label .l -text "Enter your name"
     entry .e -width 40 -textvariable your_name

would display a label widget named `.l' showing the string `Enter your
name' and an entry widget named `.e' of width 40 characters.  The value
of variable `your_name' will reflect the string in the entry widget: as
the entry widget string is updated, so is the value of the variable.
Similarly, changing the value of `your_name' in a Tcl script will
change the string displayed in the entry field.

   A _scale widget_ is for displaying an adjustable slider.  As the
slider is moved its value, which is displayed next to the slider,
changes.  To specify a scale, it must have `-from' and `-to' attributes,
which is the range of the scale. It can have a `-command' option, which
is set to a script to evaluate when the value of the slider changes.

   An example of a scale widget is:

     scale .s -from 0 -to 100

which creates a scale widget with name `.s' that will slide over a
range of integers from 0 to 100.

   There are several other options that scales can have.  For example
it is possible to display tick marks along the length of the scale
through the `-tickinterval' attribute, and it is possible to specify
both vertically and horizontally displayed scales through the `-orient'
attribute.

   A _listbox_ is a widget that displays a list of single line strings.
One or more of the strings may be selected through using the mouse.
Initializing and manipulating the contents of a listbox is done through
invoking methods on the instance of the listbox.  As examples, the
`insert' method is used to insert a string into a listbox, `delete' to
delete one, and `get' to retrieve a particular entry. Also the
currently selected list items can be retrieved through the `selection'
command.

   Here is an example of a listbox that is filled with entries of the
form `entry N':

     listbox .l
     for { set i 0 } { $i<10 } { incr i } {
         .l insert end "entry $i"
     }

   A listbox may be given a height and/or width attribute, in which
case it is likely that not all of the strings in the list are visible
at the same time. There are a number of methods for affecting the
display of such a listbox.

   The `see' method causes the listbox display to change so that a
particular list element is in view.  For example,

     .l see 5

will make sure that the sixth list item is visible. (List elements are
counted from element 0.)

   A _scrollbar_ widget is intended to be used with any widget that is
likely to be able to display only part of its contents at one time.
Examples are listboxes, canvases, text widgets, and frames, amongst
others.

   A scrollbar widget is displayed as a movable slider between two
arrows.  Clicking on either arrow moves the slider in the direction of
the arrow.  The slider can be moved by dragging it with the cursor.

   The scollbar and the widget it scrolls are connected through Tcl
script calls. A scrollable widgets will have a `scrollcommand'
attribute that is set to a Tcl script to call when the widget changes
its view. When the view changes the command is called, and the command
is usually set to change the state of its associated scrollbar.

   Similarly, the scrollbar will have a `command' attribute that is
another script that is called when an action is performed on the
scrollbar, like moving the slider or clicking on one of its arrows.
That action will be to update the display of the associated scrollable
widget (which redraws itself and then invokes its `scrollcommand',
which causes the scrollbar to be redrawn).

   How this is all done is best shown through an example:

     listbox .l -yscrollcommand ".s set" -height 10
     scrollbar .s -command ".l yview"
     for { set i 0 } { $i < 50 } { incr i } {
         .l insert end "entry $i"
     }

creates a listbox named `.l' and a scrollbar named `.s'. Fifty strings
of the form `entry N' are inserted into the listbox.  The clever part
is the way the scrollbar and listbox are linked.  The listbox has its
`-yscrollcommand' attribute set to the script `".s set"'. What happens
is that if the view of `.l' is changed, this script is called with 4
arguments attached: the number of entries in the listbox, the size of
the listbox window, the index of the first entry currently visible, and
the index of the last entry currently visible. This is exactly enough
information for the scrollbar to work out how to redisplay itself.  For
example, changing the display of the above listbox could result in the
following `-yscrollcommand' script being called:

     .s set 50 10 5 15

which says that the listbox contains 50 elements, it can display 10 at
one time, the first element displayed has index 5 and the last one on
display has index 15. This call invokes the `set' method of the
scrollbar widget `.s', which causes it to redraw itself appropriately.

   If, instead, the user interacts with the scrollbar, the scrollbar
will invoke its `-command' script, which in this example is `".l
yview"'. Before invoking the script, the scrollbar widget calculates
which element should the first displayed in its associated widget and
appends its index to the call.  For example, if element with index 20
should be the first to be displayed, the following call will be made:

     .l yview 20

which invokes the `yview' method of the listbox `.l'. This causes `.l'
to be updated (which then causes its `-yscrollcommand' to be called,
which updates the scrollbar).

   A _frame_ widget does not do anything by itself except reserve an
area of the display.  Although this does not seem to have much purpose,
it is a very important widget.  It is a container widget; that is, it
is used to group together collections of other widgets into logical
groups. For example, a row of buttons may be grouped into a frame, then
as the frame is manipulated so will the widgets displayed inside it.  A
frame widget can also be used to create large areas of color inside
another container widget (such as another frame widget or a toplevel
widget).

   An example of the use of a frame widget as a container:

     canvas .c -background red
     frame .f
     button .b1 -text button1
     button .b2 -text button2
     button .b3 -text button3
     button .b4 -text button4
     button .b5 -text button5
     pack .b1 .b2 .b3 .b4 .b5 -in .f -side left
     pack .c -side top -fill both -expand 1
     pack .f -side bottom

which specifies that there are two main widgets a canvas named `.c' and
a frame named `.f'. There are also 5 buttons, `.b1' through `.b5'.  The
buttons are displayed inside the frame. Then the canvas is displayed at
the top of the main window and the frame is displayed at the bottom. As
the frame is displayed at the bottom, then so will the buttons because
they are displayed inside the frame.

   (The `pack' command causes the widgets to be handled for display by
the packer geometry manager.  The `-fill' and `-expand 1' options to
pack for `.c' tell the display manager that if the window is resized,
the canvas is to expand to fill most of the window. You will learn
about geometry managers later in the Geometry Managers section.)

   A _toplevel_ widget is a new toplevel window.  It is a container
widget inside which other widgets are displayed.  The root toplevel
widget has path `.' -- i.e. dot on its own.  Subsequent toplevel widgets
must have a name that is lower down the path tree just like any other
widget.

   An example of creating a toplevel widget is:

     toplevel .t

   All the widgets displayed inside `.t' must also have `.t' as the
root of their path.  For example, to create a button widget for display
inside the `.t' toplevel the following would work:

     button .t.b -text "Inside 't'"

   (Attributes, such as size and title, of toplevel widgets can be
changed through the `wm' command, which we will not cover in this
tutorial. The reader is referred to the Tk manual.)

   Yet another kind of container is a _menu widget_.  It contains a
list of widgets to display inside itself, as a pulldown menu.  A simple
entry in a menu widget is a `command' widget, displayed as an option in
the menu widget, which if chosen executes a Tcl command.  Other types of
widgets allowed inside a menu widget are radiobuttons and checkboxes.  A
special kind of menu item is a `separator' that is used to group
together menu items within a menu.  (It should be noted that the widgets
inside a menu widget are special to that menu widget and do not have an
independent existence, and so do not have their own Tk name.)

   A menu widget is built by first creating an instance of a menu
widget (the container) and then invoking the `add' method to make
entries into the menu.  An example of a menu widget is as follows:

     menu .m
     .m add command -label "Open file" -command "open_file"
     .m add command -label "Open directory" -command "open_directory"
     .m add command -label "Save buffer" -command "save_buffer"
     .m add command -label "Save buffer as..." -command "save_buffer_as"
     .m add separator
     .m add command -label "Make new frame" -command "new_frame"
     .m add command -label "Open new display" -command "new_display"
     .m add command -label "Delete frame" -command "delete_frame"

which creates a menu widget called `.m', which contains eight menu
items, the first four of which are commands, then comes a separator
widget, then the final three command entries.  (Some of you will notice
that this menu is a small part of the `Files' menu from the menubar of
the Emacs text editor.)

   An example of a checkbox and some radiobutton widget entries:

     .m add checkbox -label "Inverse video" -variable inv_vid
     .m add radiobutton -label "black" -variable color
     .m add radiobutton -label "blue" -variable color
     .m add radiobutton -label "red" -variable color

which gives a checkbox displaying `Inverse video', keeping its state in
the variable `inv_vid', and three radiobuttons linked through the
variable `color'.

   Another menu item variant is the `cascade' variant, which is used to
make cascadable menus, i.e. menus that have submenus.  An example of a
cascade entry is the following:

     .m add cascade -label "I cascade" -menu .m.c

which adds a cascade entry to the menu `.m' that displays the text `I
cascade'.  If the `I cascade' option is chosen from the `.m' menu then
the menu `.m.c' will be displayed.

   The cascade option is also used to make menubars at the top of an
application window.  A menu bar is simply a menu each element of which
is a cascade entry, (for example). The menubar menu is attached to the
application window through a special configuration option for toplevel
widgets, the `-menu' option.  Then a menu is defined for each of the
cascade entry in the menubar menu.

   There are a large number of other variants to menu widgets: menu
items can display bitmaps instead of text; menus can be specified as
tear-off menus; accelerator keys can be defined for menu items; and so
on.

   A _menubutton widget_ displays like a button, but when activated a
menu pops up. The menu of the menubutton is defined through the `menu'
command and is attached to the menubutton.  An example of a menu button:

     menubutton .mb -menu .mb.m -text "mymenu"
     menu .mb.m
     .mb.m add command -label hello
     .mb.m add command -label goodbye

which crates a menubutton widget named `.mb' with attached menu `.mb.m'
and displays the text `mymenu'.  Menu `.mb.m' is defined as two command
options, one labelled `hello' and the other labelled `goodbye'.  When
the menubutton `.mb' is clicked on, the menu `.mb.m' will popup and its
options can be chosen.

   A _canvas widget_ is a container widget that is used to manage the
drawing of complex shapes; for example, squares, circles, ovals, and
polygons.  (It can also handle bitmaps, text and most of the Tk widgets
too.)  The shapes may have borders, filled in, be clicked on, moved
around, and manipulated.

   We will not cover the working of the canvas widget here.  It is
enough to know that there is a powerful widget in the Tk toolkit that
can handle all manner of graphical objects.  The interested reader is
referred to the Tk manual.

   A _text widget_ is another powerful container widget that handles
multi-line texts. The textwidget can display texts with varying font
styles, sizes, and colors in the same text, and can also handle other
Tk widgets embedded in the text.

   The text widget is a rich and complicated widget and will not be
covered here.  The interested reader is referred to the Tk manual.


File: sicstus.info,  Node: Geometry Managers,  Next: Event Handling,  Prev: Widget Creation,  Up: Tk

10.38.3.5 Geometry Managers
...........................

So far we have described each of the Tk widgets but have not mentioned
how they are arranged to be displayed.  Tk separates the creating of
widgets from the way they are arranged for display. The "geometry" of
the display is handled by a "geometry manager".  A geometry manager is
handed the set of widgets to display with instructions on their layout.
The layout instructions are particular to each geometry manager.

   Tk comes with three distinct geometry managers: `grid', `place', and
`pack'.  As might be expected the `grid' geometry manager is useful for
creating tables of widgets, for example, a table of buttons.

   The `place' geometry manager simply gives each widget an X and Y
coordinate and places them at that coordinate in their particular parent
window.

   The `pack' geometry manager places widgets according to constraints,
like "these three button widgets should be packed together from the
left in their parent widget, and should resize with the parent".

   (In practice the `grid' and `pack' geometry managers are the most
useful because they can easily handle events such as resizing of the
toplevel window, automatically adjusting the display in a sensible
manner.  `place' is not so useful for this.)

   Each container widget (the master) has a geometry manager associated
with it, which tells the container how to display its sub-widgets
(slaves) inside it. A single master has one and only one kind of
geometry manager associated with it, but each master can have a
different kind.  For example, a frame widget can use the packer to pack
other frames inside it. One of the slave frames could use the grid
manager to display buttons inside it itself, while another slave frame
could use the packer to pack labels inside it itself.

   The problem is how to display widgets. For example, there is an empty
frame widget inside which a bunch of other widgets will be displayed.
The `pack' geometry manager's solution to this problem is to
successively pack widgets into the empty space left in the container
widget.  The container widget is the master widget, and the widgets
packed into it are its slaves.  The slaves are packed in a sequence: the
packing order.

   What the packer does is to take the next slave to be packed.  It
allocates an area for the slave to be packed into from the remaining
space in the master. Which part of the space is allocated depends on
instructions to the packer. When the size of the space has been
determined, this is sliced off the free space, and allocated to the
widget that is displayed in it.  Then the remaining space is available
to subsequent slaves.

   At any one time the space left for packing is a rectangle.  If the
widget is too small to use up a whole slice from the length or breadth
of the free rectangle, still a whole slice is allocated so that the
free space is always rectangular.

   It can be tricky to get the packing instructions right to get the
desired finished effect, but a large number of arrangements of widgets
is possible using the packer.

   Let us take a simple example: three buttons packed into the root
window.  First we create the buttons; see also
`library('tcltk/examples/ex3.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3

then we can pack them thus:

     pack .b1 .b2 .b3

which produces a display of the three buttons, one on top of the other,
button `.b1' on the top, and button `.b3' on the bottom.


 [image src="images/tcltkex3.png" text="" ]                           Three Plain Buttons

If we change the size of the text in button `.b2' through the command:

     .b2 config -text "hello world"

then we see that the window grows to fit the middle button, but the
other two buttons stay their original size.


 [image src="images/tcltkex4.png" text="" ]                          Middle Button Widens

The packer defaults to packing widgets in from the top of the master.
Other directions can be specified.  For example, the command:

     pack .b1 .b2 .b3 -side left

will pack starting at the left hand side of the window.  The result of
this is that the buttons are formed in a horizontal row with the wider
button, `.b2', in the middle.


 [image src="images/tcltkex5.png" text="" ]                          Packing From The Left

It is possible to leave space between widgets through the _padding_
options to the packer: `-padx' and `-pady'.  What these do is to
allocate space to the slave that is padded with the padding distances.
An example would be:

     pack .b1 .b2 .b3 -side left -padx 10


 [image src="images/tcltkex6.png" text="" ]                            External Padding

which adds 10 pixels of space to either side of the button widgets.
This has the effect of leaving 10 pixels at the left side of button
`.b1', 20 pixels between buttons `.b1' and `.b2', 20 pixels between
buttons `.b2' and `.b3', and finally 10 pixels on the right side of
button `.b3'.

   That was external padding for spacing widgets.  There is also
internal padding for increasing the size of widgets in the X and Y
directions by a certain amount, through `-ipadx' and `-ipady' options;
i.e. internal padding.  For example:

     pack .b1 .b2 .b3 -side left -ipadx 10 -ipady 10


 [image src="images/tcltkex7.png" text="" ]                            Internal Padding

instead of spacing out the widgets, will increase their dimensions by
10 pixels in each direction.

   Remember that space is allocated to a widget from the currently
available space left in the master widget by cutting off a complete
slice from that space. It is often the case that the slice is bigger
that the widget to be displayed in it.

   There are further options for allowing a widget to fill the whole
slice allocated to it.  This is done through the `-fill' option, which
can have one of four values: `none' for no filling (default), `x' to
fill horizontally only, `y' to fill vertically only, and `both' to fill
both horizontally and vertically at the same time.

   Filling is useful, for example, for creating buttons that are the
same size even though they display texts of differing lengths.  To take
our button example again, the following code produces three buttons,
one on top of each other, but of the same size:

     button .b1 -text b1
     button .b2 -text "hello world"
     button .b3 -text b3
     pack .b1 .b2 .b3 -fill x


 [image src="images/tcltkex8.png" text="" ]                  Using `fill' For Evenly Sized Widgets

How does this work? The width of the toplevel windows is dictated by
button `.b2' because it has the widest text. Because the three buttons
are packed from top to bottom, the slices of space allocated to them
are cut progressively straight along the top of the remaining space.
i.e. each widget gets a horizontal slice of space the same width cut
from the top-level widget.  Only the wide button `.b2' would normally
fit the whole width of its slice.  But by allowing the other two
widgets to fill horizontally, they will also take up the whole width of
their slices.  The result: 3 buttons stacked on top of each other, each
with the same width, although the texts they display are not the same
length.

   A further common example is adding a scrollbar to a listbox.  The
trick is to get the scrollbar to size itself to the listbox; see also
`library('tcltk/examples/ex9a.tcl')':

     listbox .l
     scrollbar .s
     pack .l .s -side left


 [image src="images/tcltkex9a.png" text="" ]                    Scrollbar With Listbox, First Try

So far we have a listbox on the left and a tiny scrollbar on the right.
To get the scrollbar to fill up the vertical space around it add the
following command:

     pack .s -fill y

   Now the display looks like a normal listbox with a scrollbar.


 [image src="images/tcltkex9b.png" text="" ]                   Scrollbar With Listbox, Second Try

Why does this work? They are packed from the left, so first a large
vertical slice of the master is given to the listbox, then a thin
vertical slice is given to the scrollbar. The scrollbar has a small
default width and height and so it does not fill the vertical space of
its slice. But filling in the vertical direction (through the `pack .s
-fill y' command) allows it to fill its space, and so it adjusts to the
height of the listbox.

   The `fill' packing option specifies whether the widget should fill
space left over in its slice of space.  A further option to take into
account is what happens when the space allocated to the master widget is
much greater than the that used by its slaves.  This is not usually a
problem initially because the master container widget is sized to
shrink-wrap around the space used by its slaves.  If the container is
subsequently resized, however, to a much larger size there is a question
as to what should happen to the slave widgets.  A common example of
resizing a container widget is the resizing of a top-level window
widget.

   The default behavior of the packer is not to change the size or
arrangement of the slave widgets. There is an option though through the
`expand' option to cause the slices of space allocated to slaves to
expand to fill the newly available space in the master.  `expand' can
have one of two values: `0' for no expansion, and `1' for expansion.

   Take the listbox-scrollbar example; see also
`library('tcltk/examples/ex10.tcl')':

     listbox .l
     scrollbar .s
     pack .l -side left
     pack .s -side left -fill y

   Initially this looks good, but now resize the window to a much bigger
size.  You will find that the listbox stays the same size and that empty
space appears at the top and bottom of it, and that the scrollbar
resizes in the vertical. It is now not so nice.


 [image src="images/tcltkex10.png" text="" ]              Scrollbar And Listbox, Problems With Resizing

We can fix part of the problem by having the listbox expand to fill the
extra space generated by resizing the window.

     pack .l -side left -expand 1


 [image src="images/tcltkex10a.png" text="" ]                   Scrollbar And Listbox, Almost There

The problem now is that `expand' just expands the space allocated to
the listbox, it doesn't stretch the listbox itself. To achieve that we
need to apply the `fill' option to the listbox too.

     pack .l -side left -expand 1 -fill both


 [image src="images/tcltkex10b.png" text="" ]           Scrollbar And Listbox, Problem Solved Using `fill'

Now whichever way the top-level window is resized, the listbox-scrollbar
combination should look good.

   If more than one widget has the expansion bit set, the space is
allocated equally to those widgets. This can be used, for example, to
make a row of buttons of equal size that resize to fill the widget of
their container.  Try the following code; see also
`library('tcltk/examples/ex11.tcl')':

     button .b1 -text "one"
     button .b2 -text "two"
     button .b3 -text "three"
     pack .b1 .b2 .b3 -side left -fill x -expand 1


 [image src="images/tcltkex11.png" text="" ]                      Resizing Evenly Sized Widgets

Now resize the window. You will see that the buttons resize to fill the
width of the window, each taking an equal third of the width.

     *Please note*: the best way to get the hang of the packer is to
     play with it. Often the results are not what you expect,
     especially when it comes to fill and expand options. When you have
     created a display that looks pleasing, always try resizing the
     window to see if it still looks pleasing, or whether some of your
     fill and expand options need revising.

   There is an option to change how a slave is displayed if its
allocated space is larger than itself. Normally it will be displayed
centered. That can be changed by anchoring it with the `-anchor'
option. The option takes a compass direction as its argument: `n', `s',
`e', `w', `nw', `ne', `sw', `se', or `c' (for center).

   For example, the previous example with the resizing buttons displays
the buttons in the center of the window, the default anchoring point.
If we wanted the buttons to be displayed at the top of the window, we
would anchor them there thus; see also
`library('tcltk/examples/ex12.tcl')':

     button .b1 -text "one"
     button .b2 -text "two"
     button .b3 -text "three"
     pack .b1 .b2 .b3 -side left -fill x -expand 1 -anchor n


 [image src="images/tcltkex12.png" text="" ]                            Anchoring Widgets

Each button is anchored at the top of its slice and so in this case is
displayed at the top of the window.

   The packing order of widget can also be changed. For example,

     pack .b3 -before .b2

will change the positions of `.b2' and `.b3' in our examples.


 [image src="images/tcltkex13.png" text="" ]                  Changing The Packing Order Of Widgets

The _grid geometry manager_ is useful for arranging widgets in grids or
tables.  A grid has a number of rows and columns and a widget can occupy
one of more adjacent rows and columns.

   A simple example of arranging three buttons; see also
`library('tcltk/examples/ex14.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     grid .b1 -row 0 -column 0
     grid .b2 -row 1 -column 0
     grid .b3 -row 0 -column 1 -rowspan 2

this will display button `.b1' above button `.b2'. Button `.b3' will be
displayed in the next column and it will take up two rows.


 [image src="images/tcltkex14.png" text="" ]                    Using the `grid' Geometry Manager

However, `.b3' will be displayed in the center of the space allocated
to it. It is possible to get it to expand to fill the two rows it has
using the `-sticky' option. The `-sticky' option says to which edges of
its cells a widget "sticks" to, i.e. expands to reach.  (This is like
the fill and expand options in the pack manager.)  So to get `.b3' to
expand to fill its space we could use the following:

     grid .b3 -sticky ns

which says stick in the north and south directions (top and bottom).
This results in `.b3' taking up two rows and filling them.


 [image src="images/tcltkex15.png" text="" ]            `grid' Geometry Manager, Cells With Sticky Edges

There are plenty of other options to the grid geometry manager.  For
example, it is possible to give some rows/columns more "weight" than
others, which gives them more space in the master.  For example, if in
the above example you wanted to allocate 1/3 of the width of the master
to column 0 and 2/3 of the width to column 1, the following commands
would achieve that:

     grid columnconfigure . 0 -weight 1
     grid columnconfigure . 1 -weight 2

which says that the weight of column 0 for master `.' (the root window)
is 1 and the weight of column 1 is 2. Since column 1 has more weight
than column 0 it gets proportionately more space in the master.

   It may not be apparent that this works until you resize the window.
You can see even more easily how much space is allocated to each button
by making expanding them to fill their space through the sticky option.
The whole example looks like this; see also
`library('tcltk/examples/ex16.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     grid .b1 -row 0 -column 0 -sticky nsew
     grid .b2 -row 1 -column 0 -sticky nsew
     grid .b3 -row 0 -column 1 -rowspan 2 -sticky nsew
     grid columnconfigure . 0 -weight 1
     grid columnconfigure . 1 -weight 2

   Now resize the window to various sizes and we will see that button
`.b3' has twice the width of buttons `.b1' and `.b2'.


 [image src="images/tcltkex16.png" text="" ]                       Changing Row/Column Ratios

The same kind of thing can be specified for each row too via the `grid
rowconfigure' command.

   For other options and a full explanation of the grid manager see the
manual.

   `place' simply places the slave widgets in the master at the given x
and y coordinates. It displays the widgets with the given width and
height. For example (see also `library('tcltk/examples/ex17.tcl')'):

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     place .b1 -x 0 -y 0
     place .b2 -x 100 -y 100
     place .b3 -x 200 -y 200


 [image src="images/tcltkex17.png" text="" ]                   Using The `place' Geometry Manager

will place the buttons `.b1', `.b2', and `.b3' along a diagonal 100
pixels apart in both the x and y directions.  Heights and widths can be
given in absolute sizes, or relative to the size of the master in which
case they are specified as a floating point proportion of the master;
0.0 being no size and 1.0 being the size of the master.  x and y
coordinates can also be specified in a relative way, also as a floating
point number. For example, a relative y coordinate of 0.0 refers to the
top edge of the master, while 1.0 refers to the bottom edge.  If both
relative and absolute x and y values are specified, they are summed.

   Through this system the placer allows widgets to be placed on a kind
of rubber sheet. If all the coordinates are specified in relative
terms, as the master is resized then so will the slaves move to their
new relative positions.


File: sicstus.info,  Node: Event Handling,  Next: Miscellaneous,  Prev: Geometry Managers,  Up: Tk

10.38.3.6 Event Handling
........................

So far we have covered the widgets types, how instances of them are
created, how their attributes can be set and queried, and how they can
be managed for display using geometry managers.  What we have not
touched on is how to give each widget a behavior.

   This is done through event handlers.  Each widget instance can be
given a window event handler for each kind of window event.  A window
event is something like the cursor moving into or out of the widget, a
key press happening while the widget is active (in focus), or the widget
being destroyed.

   Event handlers are specified through the `bind' command:

     bind WIDGETNAME EVENTSEQUENCE COMMAND

where WIDGETNAME is the name or class of the widget to which the event
handler should be attached, EVENTSQUEUENCE is a description of the
event that this event handler will handle, and COMMAND is a script that
is invoked when the event happens (i.e. it is the event handler).

   Common event types are

`Key'
`KeyPress'
     when a key was pressed

`KeyRelease'
     when a key was released

`Button'
`ButtonPress'
     when a mouse button was pressed

`ButtonRelease'
     when a mouse button was released

`Enter'
     when the cursor moves into a widget

`Leave'
     when the cursor moved our of a widget

`Motion'
     when the cursor moves within a widget

   There are other event types. Please refer to the Tk documentation for
a complete list.

   The EVENTSEQUENCE part of a `bind' command is a list of one or more
of these events, each event surrounded by angled brackets. (Mostly, an
event sequence consists of handling a single event. Later we will show
more complicated event sequences.)

   An example is the following:

     button .b -text "click me"
     pack .b
     bind .b <Enter> { puts "entering .b" }

makes a button `.b' displaying text `click me' and displays it in the
root window using the packing geometry manager. The `bind' command
specifies that when the cursor enters (i.e. goes onto) the widget, then
the text `entering .b' is printed at the terminal.

   We can make the button change color as the cursor enters or leaves
it like this:

     button .b -text "click me" -background red
     pack .b
     bind .b <Enter> { .b config -background blue }
     bind .b <Leave> { .b config -background red }

which causes the background color of the button to change to blue when
the cursor enters it and to change back to red when the cursor leaves.

   An action can be appended to an event handler by prefixing the
action with a `+' sign. An example is:

     bind .b <Enter> {+puts "entering .b"}

which, when added to the example above, would not only change the color
of the button to red when the cursor enters it, but would also print
`entering .b' to the terminal.

   A binding can be revoked simply by binding the empty command to it:

     bind .b <Enter> {}

   A list of events that are bound can be found by querying the widget
thus:

     bind .b

which will return a list of bound events.

   To get the current command(s) bound to an event on a widget, invoke
`bind' with the widget name and the event. An example is:

     bind .b <Enter>

which will return a list of the commands bound to the event <Enter> on
widget `.b'.

   Binding can be generalized to sequences of events.  For example, we
can create an entry widget that prints `spells rob' each time the key
sequence `ESC r o b' happens:

     entry .e
     pack .e
     bind .e <Escape>rob {puts "spells rob"}

   (A letter on its own in an event sequence stands for that key being
pressed when the corresponding widget is in focus.)

   Events can also be bound for entire classes of widgets.  For
example, if we wanted to perform the same trick for ALL entry widgets
we could use the following command:

     bind entry <Escape>rob {puts "spells rob"}

   In fact, we can bind events over all widgets using `all' as the
widget class specifier.

   The event script can have substitutions specified in it.  Certain
textual substitutions are then made at the time the event is processed.
For example, `%x' in a script gets the x coordinate of the mouse
substituted for it. Similarly, `%y' becomes the y coordinate, `%W' the
dot path of the window on which the event happened, `%K' the keysym of
the button that was pressed, and so on.  For a complete list, see the
manual.

   In this way it is possible to execute the event script in the context
of the event.

   A clever example of using the `all' widget specifier and text
substitutions is given in John Ousterhout's book on Tcl/Tk (*note
Resources::):

     bind all <Enter> {puts "Entering %W at (%x, %y)"}
     bind all <Leave> {puts "Leaving %W at (%x, %y)"}
     bind all <Motion> {puts "Pointer at (%x, %y)"}

which implements a mouse tracker for all the widgets in a Tcl/Tk
application.  The widget's name and x and y coordinates are printed at
the terminal when the mouse enters or leaves any widget, and also the x
and y coordinates are printed when the mouse moves within a widget.


File: sicstus.info,  Node: Miscellaneous,  Next: What We Have Left Out (Tk),  Prev: Event Handling,  Up: Tk

10.38.3.7 Miscellaneous
.......................

There are a couple of other Tk commands that we ought to mention:
`destroy' and `update'.

   The `destroy' command is used to destroy a widget, i.e. remove it
from the Tk interpreter entirely and so from the display.  Any children
that the widget may have are also `destroy'-ed.  Anything connected to
the destroyed widget, such as bindings, are also cleaned up
automatically.

   For example, to create a window containing a button that is
destroyed when the button is pressed:

     button .b -text "Die!" -command { destroy . }
     pack .b

creates a button `.b' displaying the text `Die!', which runs the
command `destroy .' when it is pressed. Because the widget `.' is the
main toplevel widget or window, running that command will kill the
entire application associated with that button.

   The command `update' is used to process any pending Tk events.  An
event is not just such things as moving the mouse but also updating the
display for newly created and displayed widgets.  This may be necessary
in that usually Tk draws widgets only when it is idle. Using the
`update' command forces Tk to stop and handle any outstanding events
including updating the display to its actually current state, i.e.
flushing out the pending display of any widgets.  (This is analogous to
the `fflush' command in C that flushes writes on a stream to disk. In
Tk displaying of widgets is "buffered"; calling the `update' command
flushes the buffer.)


File: sicstus.info,  Node: What We Have Left Out (Tk),  Next: Queens Display,  Prev: Miscellaneous,  Up: Tk

10.38.3.8 What We Have Left Out
...............................

There are a number of Tk features that we have not described but we
list some of them here in case the reader is interested.  Refer to the
Tk manual for more explanation.

`photo'
     creating full color images through the  command

`wm'
     setting and getting window attributes

selection and focus commands

modal interaction
     (not recommended)

`send'
     sending messages between Tk applications

