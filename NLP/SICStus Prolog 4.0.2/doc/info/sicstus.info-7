This is info/sicstus.info, produced by makeinfo version 4.8 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 6 November 2007.


File: sicstus.info,  Node: mpg-ref-generate_message_hook,  Next: mpg-ref-get_byte,  Prev: mpg-ref-generate_message,  Up: mpg-bpr

11.3.88 `generate_message_hook/3'  "[hook]"
-------------------------------------------

Synopsis
--------

`:- multifile user:generate_message_hook/3.'

   `user:generate_message_hook(+MESSAGETERM, -S0, -S)'

   A way for the user to override the call to
`'SU_messages':generate_message/3' in `print_message/2'.

Arguments
---------

MESSAGETERM
     "term"

     May be any term.

S0
     "list of pair"

     The resulting list of CONTROL-ARGS pairs.

S
     "list of pair"

     The remaining list.

Description
-----------

For a given MESSAGETERM, generates the list of CONTROL-ARGS pairs
required for `print_message_lines/3' to format the message for display.

   This is the same as `'SU_messages':generate_message/3' except that
it is a hook.  It is intended to be used when you want to override
particular messages from the Prolog system, or when you want to add
some messages.  If you are using your own exception classes (see
`raise_exception/1') it may be useful to provide generate_message_hook
clauses for those exceptions so that the `print_message/2' (and thus
the default exception handler that calls `print_message/2') can print
them out nicely.

   The Prolog system uses the built-in predicate `print_message/2' to
print all its messages.  When `print_message/2' is called, it calls
`user:generate_message_hook(Message,L,[])' to generate the message.  If
that fails, `'SU_messages':generate_message(Message,L,[])' is called
instead.  If that succeeds, L is assumed to have been bound to a list
whose elements are either CONTROL-ARGS pairs or the atom `nl'.  Each
CONTROL-ARG pair should be such that the call

     format(user_error, CONTROL, ARGS)

is valid.  The atom `nl' is used for breaking the message into lines.
Using the format specification `~n' (new-line) is discouraged, since
the routine that actually prints the message (see `user:message_hook/3'
and `print_message_lines/3') may need to have control over newlines.

Examples
--------

     :- multifile user:generate_message_hook/3.
     user:generate_message_hook(hello_world) -->
             ['hello world'-[],nl].

Note that the terminating `nl' is required.

See Also
--------

*Note ref-msg::.


File: sicstus.info,  Node: mpg-ref-get_byte,  Next: mpg-ref-get_char,  Prev: mpg-ref-generate_message_hook,  Up: mpg-bpr

11.3.89 `get_byte/[1,2]'  "[ISO]"
---------------------------------

Synopsis
--------

`get_byte(-BYTE)'

   `get_byte(+STREAM, -BYTE)'

   Unifies BYTE with the next "byte" from STREAM or with -1 if there
are no more bytes.

Arguments
---------

STREAM
     "stream_object", must be ground

     valid input _binary_ stream, defaults to the current input stream.

BYTE
     "byte" or -1

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`type_error'
     BYTE is an invalid byte.

`existence_error'
     Trying to read beyond end of STREAM

See Also
--------

*Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-get_char,  Next: mpg-ref-get_code,  Prev: mpg-ref-get_byte,  Up: mpg-bpr

11.3.90 `get_char/[1,2]'  "[ISO]"
---------------------------------

Synopsis
--------

`get_char(-CHAR)'

   `get_char(+STREAM, -CHAR)'

   Unifies CHAR with the next "char" from STREAM or with `end_of_file'
if there are no more characters.

Arguments
---------

STREAM
     "stream_object", must be ground.

     Valid input _text_ stream, defaults to the current input stream.

CHAR
     "char" or "one of [`end_of_file']"

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`existence_error'
     Trying to read beyond end of STREAM

See Also
--------

*Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-get_code,  Next: mpg-ref-get_mutable,  Prev: mpg-ref-get_char,  Up: mpg-bpr

11.3.91 `get_code/[1,2]'  "[ISO]"
---------------------------------

Synopsis
--------

`get_code(-CODE)'

   `get_code(+STREAM, -CODE)'

   Unifies CODE with the next "code" from STREAM or with -1 if there
are no more characters.

Arguments
---------

STREAM
     "stream_object", must be ground

     Valid input _text_ stream, defaults to the current input stream.

CODE
     "code" or -1

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`existence_error'
     Trying to read beyond end of STREAM

See Also
--------

*Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-get_mutable,  Next: mpg-ref-goal_expansion,  Prev: mpg-ref-get_code,  Up: mpg-bpr

11.3.92 `get_mutable/2'
-----------------------

Synopsis
--------

`get_mutable(-DATUM, +MUTABLE)'

   DATUM is the current value of the mutable term MUTABLE.

Arguments
---------

DATUM
     "term", must be nonvar

MUTABLE
     "mutable", must be nonvar

Exceptions
----------

`instantiation_error'
     MUTABLE is uninstantiated.

`type_error'
     MUTABLE is not a mutable.


See Also
--------

*Note ref-lte-mut::.


File: sicstus.info,  Node: mpg-ref-goal_expansion,  Next: mpg-ref-goal_source_info,  Prev: mpg-ref-get_mutable,  Up: mpg-bpr

11.3.93 `goal_expansion/5'  "[hook]"
------------------------------------

Synopsis
--------

`M:goal_expansion(+GOAL1, +LAYOUT1, +MODULE, -GOAL2, -LAYOUT2)'

   Defines transformations on goals while clauses are being compiled or
asserted, and during meta-calls.

Arguments
---------

GOAL1
     "callable"

     Goal to transform.

LAYOUT1
     "term"

     Layout of goal to transform.

MODULE
     "atom"

     Source module of goal to transform.

GOAL2
     "callable"

     Transformed goal.

LAYOUT2
     "term"

     Layout of transformed goal.

Description
-----------

Defines transformations on goals while clauses are being consulted,
compiled or asserted, _after_ any processing by `user:term_expansion/6'
of the terms being read in.  It is called for every simple GOAL1 in the
source module MODULE found while traversing the clause bodies.
Typically, MODULE has imported the predicate GOAL1 from module M.

   If it succeeds, GOAL1 is replaced by GOAL2; otherwise, GOAL1 = GOAL2.
GOAL2 may be an arbitrarily complex goal, and `M:goal_expansion/5' is
recursively applied to its subgoals.

     *Please note*: the arguments of built-in meta-predicates such as
     `call/1', `setof/3' and `on_exception/3' are _not_ subject to such
     compile-time processing.

   This predicate is also used to resolve any meta-calls to GOAL1 at
runtime via the same mechanism.  If the transformation succeeds, GOAL2
is simply called instead of GOAL1.  Otherwise, if GOAL1 is a goal of an
existing predicate, that predicate is invoked.  Otherwise, error
recovery is attempted by `user:unknown_predicate_handler/3'.

   `M:goal_expansion/5' can be regarded as a macro expansion facility.
It is used for this purpose to support the interface to attributed
variables in `library(atts)', which defines the predicates
`M:get_atts/2' and `M:put_atts/2' to access module-specific variable
attributes.  These "predicates" are actually implemented via the
`M:goal_expansion/5' mechanism.  This has the effect that calls to the
interface predicates are expanded at compile time to efficient code.

   For accessing aspects of the load context, e.g. the name of the file
being compiled, the predicate `prolog_load_context/2' (*note
ref-lps-lco::) can be used.

   LAYOUT1 and LAYOUT2 are for supporting source-linked debugging in
the context of goal expansion.  The predicate should construct a
suitable LAYOUT2 compatible with TERM2 that contains the line number
information from LAYOUT1. If source-linked debugging of TERM2 is not
important, LAYOUT2 should be `[]'.

Exceptions
----------

Exceptions are treated as failures, except an error message is printed
also.

See Also
--------

*Note ref-lod-exp::.


File: sicstus.info,  Node: mpg-ref-goal_source_info,  Next: mpg-ref-ground,  Prev: mpg-ref-goal_expansion,  Up: mpg-bpr

11.3.94 `goal_source_info/3'
----------------------------

Synopsis
--------

`goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'

   Decompose the AGOAL annotated goal into a GOAL proper and the
SOURCEINFO descriptor term, indicating the source position of the goal.

Arguments
---------

AGOAL
     "callable", must be nonvar

GOAL
     "callable"

SOURCEINFO
     "term"

Description
-----------

Annotated goals occur in most of error message terms, and carry
information on the GOAL causing the error and its source position. The
SOURCEINFO term, retrieved by `goal_source_info/3' will be one of the
following:
`[]'
     The goal has no source information associated with it.

`fileref(FILE,LINE)'
     The goal occurs in file FILE, line LINE.

`clauseref(FILE,MFUNC,CLAUSENO,CALLNO,LINE)'
     The goal occurs in file FILE, within predicate MFUNC, clause
     number CLAUSENO, call number CALLNO and virtual line number LINE.
     Here, MFUNC is of form `MODULE:NAME/ARITY', calls are numbered
     textually and the virtual line number shows the position of the
     goal within the listing of the predicate MFUNC, as produced by
     `listing/1'. Such a term is returned for goals occurring in
     interpreted predicates, which do not have "real" line number
     information, e.g. because they were entered from the terminal, or
     created dynamically.

Exceptions
----------

`instantiation_error'
     GOAL is uninstantiated

`type_error'
     GOAL is not a callable

See Also
--------

*Note ref-msg::.


File: sicstus.info,  Node: mpg-ref-greater_than,  Next: mpg-ref-not_less_than,  Prev: mpg-ref-not_equal_to,  Up: mpg-bpr

11.3.95 `> /2'  "[ISO]"
-----------------------

Synopsis
--------

+EXPR1 `>' +EXPR2

   Succeeds if the result of evaluating EXPR1 is strictly _greater
than_ the result of evaluating EXPR2.

Arguments
---------

EXPR1
     "expr", must be ground

EXPR2
     "expr", must be ground

Description
-----------

Evaluates EXPR1 and EXPR2 as arithmetic expressions and compares the
results.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- "g" > "g".

     no

     | ?- 4*2 > 15/2.

     yes

See Also
--------

*Note ref-ari::


File: sicstus.info,  Node: mpg-ref-ground,  Next: mpg-ref-halt,  Prev: mpg-ref-goal_source_info,  Up: mpg-bpr

11.3.96 `ground/1'
------------------

Synopsis
--------

`ground(+TERM)'

   TERM is currently instantiated to a ground term.

Arguments
---------

TERM
     "term"

Description
-----------

Tests whether X is completely instantiated, i.e. free of unbound
variables.  In this context, mutable terms are treated as nonground, so
as to make `ground/1' a monotone predicate.

Examples
--------

     | ?- ground(9).

     yes
     | ?- ground(major(tom)).

     yes
     | ?- ground(a(1,Term,3)).

     no
     | ?- ground("a").

     yes
     | ?- ground([1,foo(Term)]).

     no

See Also
--------

*Note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-halt,  Next: mpg-ref-if,  Prev: mpg-ref-ground,  Up: mpg-bpr

11.3.97 `halt/[0,1]'  "[ISO]"
-----------------------------

Synopsis
--------

`halt'

   `halt(+EXITCODE)'

   Causes an exit from the running process.

Arguments
---------

EXITCODE
     "integer", must be nonvar

     Exit status code. Only the lower 8 bits of this value is used.


Description
-----------

Causes an exit from the running process with exit code EXITCODE.
EXITCODE defaults to zero which, by convention, signifies a successful
exit from the process.

   `halt/[0,1]' is implemented by raising a reserved exception, which
has handler at the top level; *note ref-ere-int::.

Exceptions
----------

`instantiation_error'

`type_error'
     EXITCODE is not an integer.

See Also
--------

`abort/0', `break/0', `runtime_entry/1', *Note ref-ere-int::.


File: sicstus.info,  Node: mpg-ref-if,  Next: mpg-ref-include,  Prev: mpg-ref-halt,  Up: mpg-bpr

11.3.98 `if/3'
--------------

Synopsis
--------

`if(+P,+Q,+R)'

   _If_ P _then_ Q _else_ R, for all solution of P.

Arguments
---------

:P
     "callable", must be nonvar

:Q
     "callable", must be nonvar

:R
     "callable", must be nonvar

Description
-----------

Analogous to

     if P then Q else R

but differs from `P -> Q ; R' in that `if(P, Q, R)' explores _all_
solutions to the goal P.  There is a small time penalty for this--if P
is known to have only one solution of interest, the form `P -> Q ; R'
should be preferred.

   This is normally regarded as part of the syntax of the language, but
it is like a built-in predicate in that you can write `call(if(P,Q,R))'.

   Cuts in P do not make sense, but they are allowed, their scope being
the goal P.  The scope of cuts in Q and R extends to the containing
clause.

Backtracking
------------

Depends on the arguments.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*Note ref-sem::.


File: sicstus.info,  Node: mpg-ref-if_then,  Next: mpg-ref-or,  Prev: mpg-ref-and,  Up: mpg-bpr

11.3.99 `-> /2'  "[ISO]"
------------------------

Synopsis
--------

+P `->' +Q

   When occurring other than as the first argument of a disjunction
operator (`;/2'), this is equivalent to:

     P -> Q ; fail.

Arguments
---------

:P
     "callable", must be nonvar

:Q
     "callable", must be nonvar

Description
-----------

This is not normally regarded as a built-in predicate, since it is part
of the syntax of the language.  However, it is like a built-in
predicate in that you can say `call((P `->' Q))'.

   `->' cuts away any choice points in the execution of P

   Note that the operator precedence of `->' is greater than 1000, so
it dominates commas.  Thus, in:
     f :- p, q -> r, s.
     f.

   `->' cuts away any choices in `p' or in `q', but unlike cut (`!') it
does not cut away the alternative choice for `f'.

   Cuts in P do not make sense, but they are allowed, their scope being
the goal P.  The scope of cuts in Q extends to the containing clause.

Backtracking
------------

Depends on Q.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*Note ref-sem::.


File: sicstus.info,  Node: mpg-ref-include,  Next: mpg-ref-instance,  Prev: mpg-ref-if,  Up: mpg-bpr

11.3.100 `include/1'  "[ISO,declaration]"
-----------------------------------------

Synopsis
--------

`:- include +FILES'

   Literally embed the Prolog clauses and directives in FILES into the
file being loaded.  The file or files will be opened with default
options.

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extension
     optional.

Description
-----------

The effect is such as if the declaration itself was replaced by the
text in the FILES. Including some files is thus different from loading
them in several respects:

   * The embedding file counts as the source file of the predicates
     loaded, e.g. with respect to the built-in predicate
     `source_file/2'; *note ref-lps-apf::.

   * Some clauses of a predicate can come from the embedding file, and
     some from included files.

   * When including a file twice, all the clauses in it will be entered
     twice into the program (although this is not very meaningful).

Exceptions
----------

`instantiation_error'
     FILES not ground.

`context_error'
     "declaration appeared in query"

See Also
--------

*Note Include Declarations::.


File: sicstus.info,  Node: mpg-ref-initialization,  Next: mpg-ref-meta_predicate,  Prev: mpg-ref-dynamic,  Up: mpg-bpr

11.3.101 `(initialization)/1'  "[ISO,declaration]"
--------------------------------------------------

Synopsis
--------

`:- initialization +GOAL'

   Declares that GOAL is to be run when the file in which the
declaration appears is loaded into a running system, or when a
stand-alone program or runtime system that contains the file is started
up.

Arguments
---------

:GOAL
     "callable", must be nonvar

Description
-----------

Callable at any point during loading of a file. That is, it can be used
as a directive, or as part of a goal called at load time.  The
initialization goal will be run as soon as the loading of the file is
completed. That is at the end of the load, and notably after all other
directives appearing in the file have been run.

   `save_program/[1,2]' saves initialization goals in the saved state,
so that they will run when the saved state is restored.

   GOAL is associated with the file loaded and a module.  When a file,
or module, is going to be reloaded, all goals earlier installed by that
file or in that module, are removed.  This is done before the actual
load, thus allowing a new initialization GOAL to be specified, without
creating duplicates.

Exceptions
----------

`instantiation_error'
     The argument GOAL is not instantiated.

See Also
--------

*Note Initializations::.


File: sicstus.info,  Node: mpg-ref-instance,  Next: mpg-ref-integer,  Prev: mpg-ref-include,  Up: mpg-bpr

11.3.102 `instance/2'
---------------------

Synopsis
--------

`instance(+REF, -TERM)'

   Unifies TERM with the most general instance of the dynamic clause or
recorded term indicated by the database reference REF.

Arguments
---------

REF
     "db_reference", must be nonvar

TERM
     "term"

Description
-----------

REF must be instantiated to a database reference to an existing clause
or recorded term.  `instance/2' is not sensitive to the source module
and can be used to access any clause, regardless of its module.

Exceptions
----------

`instantiation_error'
     if REF is not instantiated

`type_error'
     if REF is not a syntactically valid database reference

`existence_error'
     if REF is a syntactically valid database reference but does not
     refer to an existing clause or recorded term.

Examples
--------

     | ?- assert(foo:bar,R).

     R = '$ref'(771292,1)

     | ?- instance('$ref'(771292,1),T).

     T = (bar:-true)

     | ?- clause(H,B,'$ref'(771292,1)).

     no
     | ?- clause(foo:H,B,'$ref'(771292,1)).

     H = bar,
     B = true

     | ?-

See Also
--------

*Note ref-mdb-acl::.


File: sicstus.info,  Node: mpg-ref-integer,  Next: mpg-ref-is,  Prev: mpg-ref-instance,  Up: mpg-bpr

11.3.103 `integer/1'  "[ISO]"
-----------------------------

Synopsis
--------

`integer(+TERM)'

   TERM is currently instantiated to an integer.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- integer(5).

     yes
     | ?- integer(5.0).

     no

See Also
--------

*Note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-is,  Next: mpg-ref-keysort,  Prev: mpg-ref-integer,  Up: mpg-bpr

11.3.104 `is/2'  "[ISO]"
------------------------

Synopsis
--------

`-TERM is +EXPRESSION'

   Evaluates EXPRESSION as an arithmetic expression, and unifies the
resulting number with TERM.

Arguments
---------

EXPRESSION
     "expr", must be ground.

     An expression made up of:

        * functors representing arithmetic operations

        * numbers

        * variables bound to numbers or arithmetic expressions

TERM
     "number"

Exceptions
----------

Evaluation errors.

Examples
--------

     | ?- X is 2 * 3 + 4.

     X = 10

     | ?- Y = 32.1, X is Y * Y.

     X = 1030.41
     Y = 32.1

     | ?- Arity is 3 * 8, X is 4 + Arity + (3 * Arity * Arity).

     Arity = 24
     X = 1756

     | ?- X is 6/0.
     ! Domain error in argument 2 of is/2
     ! expected an integer not equal to 0, but found 0
     ! goal:  _98 is 6/0

     | ?- X is "a".

     X = 97

     | ?- X is 4 * 5, Y is X * 4.

     X = 20,
     Y = 80

Comments
--------

If a variable in an arithmetic expression is bound to another
arithmetic expression (as opposed to a number) at runtime then the cost
of evaluating that expression is much greater.  It is approximately
equal to the cost of `call/1' of an arithmetic goal.

See Also
--------

*Note ref-ari::.


File: sicstus.info,  Node: mpg-ref-keysort,  Next: mpg-ref-leash,  Prev: mpg-ref-is,  Up: mpg-bpr

11.3.105 `keysort/2'
--------------------

Synopsis
--------

`keysort(+LIST1, -LIST2)'

   Sorts the elements of the list LIST1 into ascending standard order
(*note ref-lte-cte-sot::) with respect to the key of the pair structure.

Arguments
---------

    LIST1
          "list of pair", must be a proper list of proper pairs

    LIST2
          "list of pair"

Description
-----------

The list LIST1 must consist of terms of the form KEY-VALUE.  Multiple
occurrences of any term are not removed.

   (The time taken to do this is at worst order (N log N) where N is
the length of the list.)

   Note that the elements of LIST1 are sorted _only_ according to the
value of KEY, _not_ according to the value of VALUE.

   `keysort' is stable in the sense that the relative position of
elements with the same key is maintained.

Exceptions
----------

`instantiation_error'
     If LIST1 is not properly instantiated

`type_error'
     If LIST1 is not a list of key-value pair.

Examples
--------

     | ?- keysort([3-a,1-b,2-c,1-a,1-b], X).

     X = [1-b,1-a,1-b,2-c,3-a]

     |?- keysort([2-1, 1-2], [1-2, 2-1]).

     yes

See Also
--------

*Note ref-lte-cte-sor::.


File: sicstus.info,  Node: mpg-ref-leash,  Next: mpg-ref-length,  Prev: mpg-ref-keysort,  Up: mpg-bpr

11.3.106 `leash/1'  "[development]"
-----------------------------------

Synopsis
--------

`leash(+MODE)'

   Starts leashing on the ports given by MODE.

Arguments
---------

MODE
     "one of `[all]'" or "list of one of
     `[call,exit,redo,fail,exception]'", must be ground

     Either the atom `all', or a list of the ports to be leashed..

Description
-----------

The leashing mode only applies to procedures that do not have spypoints
on them, and it determines which ports of such procedures are leashed.
By default, all five ports are leashed.  On arrival at a leashed port,
the debugger will stop to allow you to look at the execution state and
decide what to do next.  At unleashed ports, the goal is displayed but
program execution does not stop to allow user interaction.

Exceptions
----------

`instantiation_error'
     MODE is not ground

`domain_error'
     MODE is not a valid leash specification

Examples
--------

     | ?- leash([]).

turns off all leashing; now when you creep you will get an exhaustive
trace but no opportunity to interact with the debugger.  You can get
back to the debugger to interact with it by pressing `^c t'.

     | ?- leash([call,redo]).

   leashes on the Call and Redo ports.  When creeping, the debugger will
now stop at every Call and Redo port to allow you to interact.

See Also
--------

*Note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-length,  Next: mpg-ref-library_directory,  Prev: mpg-ref-leash,  Up: mpg-bpr

11.3.107 `length/2'
-------------------

Synopsis
--------

`length(?LIST, ?INTEGER)'

   INTEGER is the length of LIST. If LIST is instantiated to a proper
"list of term", or INTEGER to an integer, the predicate is determinate.

Arguments
---------

LIST
     "list of term"

INTEGER
     "integer", non-negative

Description
-----------

If LIST is a list of indefinite length (that is, either a variable or
of the form `[...|X]') and if INTEGER is bound to an integer, then LIST
is made to be a list of length INTEGER with unique variables used to
"pad" the list. If LIST cannot be made into a list of length INTEGER,
the call fails.
     | ?-  List = [a,b|X], length(List, 4).

     List = [a,b,_A,_B],
     X = [_A,_B] ;

     | ?-

   If LIST is bound, and is not a list, `length/2' simply fails.

Backtracking
------------

If INTEGER is unbound, then it is unified with all possible lengths for
the list LIST.

Exceptions
----------

`type_error'
     INTEGER is not an integer

`domain_error'
     INTEGER < 0

Examples
--------


     | ?- length([1,2], 2).

     yes
     | ?- length([1,2], 0).

     no
     | ?- length([1,2], X).

     X = 2 ;

     no

See Also
--------

*Note ref-lte-acl::, `library(lists)'.


File: sicstus.info,  Node: mpg-ref-less_than,  Next: mpg-ref-unify,  Prev: mpg-ref-or,  Up: mpg-bpr

11.3.108 `< /2'  "[ISO]"
------------------------

Synopsis
--------

+EXPR1 `<' +EXPR2

   Evaluates EXPR1 and EXPR2 as arithmetic expressions.  The goal
succeeds if the result of evaluating EXPR1 is strictly _less than_ the
result of evaluating EXPR2.

Arguments
---------

EXPR1
     "expr", must be ground

EXPR2
     "expr", must be ground

Description
-----------

Evaluates EXPR1 and EXPR2 as arithmetic expressions and compares the
results.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- 23 + 2.2  <  23 - 2.2.

     yes
     | ?- X = 31, Y = 25, X + Y  <  X - Y

     no

See Also
--------

*Note ref-ari::


File: sicstus.info,  Node: mpg-ref-library_directory,  Next: mpg-ref-line_count,  Prev: mpg-ref-length,  Up: mpg-bpr

11.3.109 `library_directory/1'  "[hook]"
----------------------------------------

Synopsis
--------

`:- multifile user:library_directory/1.'

   `user:library_directory(+DIRSPEC)'

   Defines a library directory. Used by predicates taking "file_spec"
as input argument.

Arguments
---------

DIRSPEC
     "file_spec"

     Either an atom giving the path to a file or directory, or
     PATHALIAS(DIRSPEC), where PATHALIAS is defined by a
     `file_search_path/2' rule.

Description
-----------

These facts define directories to search when a file specification
`library(FILE)' is expanded to the full path, in addition to the
predefined library path, which is tried first.

   The `file_search_path' mechanism is an extension of the
`library_directory' scheme.

   The predicate is undefined at startup, but behaves as if it were a
multifile predicate with a single clause defining the location of the
Prolog library. The initial value is the same as the value of the
environment variable `SP_LIBRARY_DIR'.  The predicate may succeed
nondeterminately in this search for a library directory.

Examples
--------

     | ?- [user].
     % compiling user...
     | :- multifile user:library_directory/1.
     | library_directory('/usr/joe_bob/prolog/libs').
     | end_of_file.
     % compiled user in module user, 0 msec 384 bytes
     yes
     | ?- ensure_loaded(library(flying)).
     % loading file /usr/joe_bob/prolog/libs/flying.qof
     ...

See Also
--------

`absolute_file_name/[2,3]', `file_search_path/2', `load_files/[1,2]',
*Note ref-fdi::.


File: sicstus.info,  Node: mpg-ref-line_count,  Next: mpg-ref-line_position,  Prev: mpg-ref-library_directory,  Up: mpg-bpr

11.3.110 `line_count/2'
-----------------------

Synopsis
--------

`line_count(+STREAM, -COUNT)'

   Obtains the total number of lines either input from or output to the
open text stream STREAM and unifies it with COUNT.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open _text_ stream.

COUNT
     "integer"

     The resulting line count of the stream.


Description
-----------

A freshly opened stream has a line count of 0, i.e. this predicate
counts the number of newlines seen.  When a line is input from or
output to a non-tty Prolog stream, the line count of the Prolog stream
is increased by one.  Line count for a tty stream reflects the total
line input from or output to the tty since the tty is opened to any
stream.

   The count is reset by `set_stream_position/2'.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

`byte_count/2', `character_count/2', `line_position/2',
`stream_position/2', `set_stream_position/2', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-line_position,  Next: mpg-ref-listing,  Prev: mpg-ref-line_count,  Up: mpg-bpr

11.3.111 `line_position/2'
--------------------------

Synopsis
--------

`line_position(+STREAM, -COUNT)'

   Obtains the total number of characters either input from or output to
the current line of the open text stream STREAM and unifies it with
COUNT.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open _text_ stream.

COUNT
     "integer"

     The resulting line count of the stream.


Description
-----------

A fresh line has a line position of 0, i.e. this predicate counts the
length of the current line.  Line count for a tty stream reflects the
total line input from or output to the tty since the tty is opened to
any stream.

   The count is reset by `set_stream_position/2'.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

`byte_count/2', `character_count/2', `line_count/2',
`stream_position/2', `set_stream_position/2', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-listing,  Next: mpg-ref-load_files,  Prev: mpg-ref-line_position,  Up: mpg-bpr

11.3.112 `listing/[0,1]'
------------------------

Synopsis
--------

`listing'

   `listing(+PREDSPECS)'

   Prints the clauses of all the interpreted procedures currently in the
type-in module of the Prolog database, or of PREDSPECS, to the current
output stream, using `portray_clause/1'.

Arguments
---------

:PREDSPECS
     "pred_spec_tree"

     A predicate specification, or a list of such.

Exceptions
----------

`type_error'
     PREDSPECS of the wrong type.

Examples
--------

You could list the entire program to a file using the command
     | ?- tell(file), listing, told.

   Note that `listing/[0,1]' does not work on compiled procedures.

   `listing/1' is dependent on the source module.  As a special case,
     | ?- listing(mod:_).

   will list all the dynamic predicates in module mod.  However,
`listing/0' is not dependent on the source module; it refers instead to
the type-in module.

   Variables may be included in predicate specifications given to
`listing/1'.  For example, you can list clauses for `f' in any current
module with:
     | ?- listing(_:f).

See Also
--------

*Note ref-mod::.


File: sicstus.info,  Node: mpg-ref-load_files,  Next: mpg-ref-load_foreign_resource,  Prev: mpg-ref-listing,  Up: mpg-bpr

11.3.113 `load_files/[1,2]'
---------------------------

Synopsis
--------

`load_files(+FILES)'

   `load_files(+FILES, +OPTIONS)'

   `[+FILES]'

   Loads the specified Prolog source and/or object file(s) into memory.
Subsumes all other load predicates.

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extensions
     optional.

OPTIONS
     "list of term", must be ground

     A list of zero or more options of the form:
    `if(X)'
          `true' (the default) to always load, or `changed' to load
          only if the file has not yet been loaded or if it has been
          modified since it was last loaded.  A non-module-file is not
          considered to have been previously loaded if it was loaded
          into a different module.  The file `user' is never considered
          to have been previously loaded.

    `when(WHEN)'
          `always' (the default) to always load, or `compile_time' to
          load only if the goal is not in the scope of another
          `load_files/[1,2]' directive occurring in a PO file.

          The latter is intended for use when the file only defines
          predicates that are needed for proper term or goal expansion
          during compilation of other files.

    `load_type(LOADTYPE)'
          `source' to load source files only, `object' to load object
          (PO) files only, or `latest' (the default) to load any type
          of file, whichever is newest.  If the file is `user',
          `source' is forced.

    `imports(IMPORTS)'
          `all' (the default) to import all exported predicates if the
          file is a module-file, or a list of predicates to import.

    `compilation_mode(MODE)'
          `compile' to translate into compiled code, `consult' to
          translate into static, interpreted code, or `assert_all' to
          translate into dynamic, interpreted code.

          The default is the compilation mode of any ancestor
          `load_files/[1,2]' goal, or `compile' otherwise. Note that
          MODE has no effect when a PO file is loaded, and that it is
          recommended to use `assert_all' in conjunction with
          `load_type(source)', to ensure that the source file will be
          loaded even in the presence of a PO file.

     In addition the `open/4' options `encoding/1',
     `encoding_signature/1' and `eol/1' can be specfied. These will be
     used if the Prolog code is loaded from a source file.  *Note
     mpg-ref-open::, for details.

Description
-----------

`load_files/[1,2]' reads Prolog clauses, in source or precompiled form,
and adds them to the Prolog database, after first deleting any previous
versions of the predicates they define.  Clauses for a single predicate
must all be in the same file unless that predicate is declared to be
`multifile'.

   If a source file contains directives, that is, terms with principal
functor `:-/1' or `?-/1', then these are executed as they are
encountered.  Initialization goals specified with `initialization/1'
are executed after the load.

   A non-module source file can be loaded into any module by
`load_files/[1,2]', but the module of the predicates in a precompiled
file is fixed at the time it is created.

Exceptions
----------

`instantiation_error'
     FILES or OPTIONS is not ground.

`type_error'
     In FILES or OPTIONS.

`domain_error'
     Illegal option in OPTIONS.

`existence_error'
     A specified file does not exist.  If the `fileerrors' flag is
     `off', the predicate fails instead of raising this exception.

`permission_error'
     A specified file is protected.  If the `fileerrors' flag is `off',
     the predicate fails instead of raising this exception.

See Also
--------

*Note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-load_foreign_resource,  Next: mpg-ref-member,  Prev: mpg-ref-load_files,  Up: mpg-bpr

11.3.114 `load_foreign_resource/1'  "[hookable]"
------------------------------------------------

Synopsis
--------

`load_foreign_resource(:RESOURCE)'

   Load the foreign resource RESOURCE into Prolog.  Relies on the hook
predicates `foreign_resource/2' and `foreign/3'.

Arguments
---------

:RESOURCE
     "file_spec", must be ground

     The foreign resource to be loaded. The file extension can be
     omitted.

Description
-----------

`load_foreign_resource/1' takes a foreign resource and loads it into
Prolog.

   The extension can be omitted from the filename given in the RESOURCE
argument.

   Uses the `foreign/3' and `foreign_resource/2' facts defined by the
user to make the connection between a Prolog procedure and the foreign
function. In this context, the "resource name" is derived from RESOURCE
name by deleting any leading path and extension from the absolute file
name of RESOURCE.

   When loading the foreign resource, it looks for a
`foreign_resource/2' fact for the resource name.  For each symbol in
that fact, it looks for a `foreign/3' fact that gives the name of the
Prolog procedure associated with the foreign symbol and the argument
specification.

   Contrary to most hook predicates which reside in the `user' module,
`load_foreign_resource/1' will look for `foreign_resource/2' and
`foreign/3' facts defined in its source module.

   Foreign resources are created with the `splfr' tool (*note The
Foreign Resource Linker::).

Exceptions
----------

Errors in the specification of `foreign/[2,3]' and `foreign_resource/2'
will all be reported when `load_foreign_resource/1' is called.

See Also
--------

`foreign/[2,3]', *Note Foreign Resources::, *Note Calling C from
Prolog::.


File: sicstus.info,  Node: mpg-ref-member,  Next: mpg-ref-memberchk,  Prev: mpg-ref-load_foreign_resource,  Up: mpg-bpr

11.3.115 `member/2'
-------------------

Synopsis
--------

`member(?ELEMENT, ?LIST)'

   is true if ELEMENT occurs in the LIST.  It may be used to test for
an element or to enumerate all the elements by backtracking.  Indeed,
it may be used to generate the LIST!

Arguments
---------

ELEMENT
     "term"

LIST
     "list of term"

Description
-----------

In the context of this predicate, a term occurs in a list if it can be
unified with an element of the list.

Backtracking
------------

On backtracking, an attempt is made to unify ELEMENT with successive
elements of LIST.  If LIST is not a proper list, then on backtracking
it is unified with lists of ever increasing length.

Examples
--------


     | ?- member(foo(X), [foo(1), bar(2), foo(3)]).
     X = 1 ? ;
     X = 3 ? ;
     no

See Also
--------

*Note ref-lte-acl::, `library(lists)'.


File: sicstus.info,  Node: mpg-ref-memberchk,  Next: mpg-ref-message_hook,  Prev: mpg-ref-member,  Up: mpg-bpr

11.3.116 `memberchk/2'
----------------------

Synopsis
--------

`memberchk(?ELEMENT, ?LIST)'

   is true if the given ELEMENT occurs in the given LIST.  Its purpose
is to test for membership. Normally, the two arguments are ground.

Arguments
---------

ELEMENT
     "term"

LIST
     "list of term"

Description
-----------

In the context of this predicate, a term occurs in a list if it can be
unified with an element of the list.

Backtracking
------------

The predicate is determinate and commits to the first successful
unification, if any.

Examples
--------


     | ?- memberchk(bar, [foo,bar,baz]).
     yes

See Also
--------

*Note ref-lte-acl::, `library(lists)'.


File: sicstus.info,  Node: mpg-ref-message_hook,  Next: mpg-ref-module,  Prev: mpg-ref-memberchk,  Up: mpg-bpr

11.3.117 `message_hook/3'  "[hook]"
-----------------------------------

Synopsis
--------

`:- multifile user:message_hook/3.'

   `user:message_hook(+SEVERITY, +MESSAGETERM, +LINES)'

   Overrides the call to `print_message_lines/3' in `print_message/2'.
A way for the user to intercept the MESSAGE of type SEVERITY, whose
translations is LINES, before it is actually printed.

Arguments
---------

SEVERITY
     "one of `[informational,warning,error,help,silent]'"

MESSAGETERM
     "term"

LINES
     "list of list of pair"

     Is of the form `[LINE1, LINE2, ...]', where each LINEI is of the
     form `[CONTROL_1-ARGS_1,CONTROL_2-ARGS_2, ...]'.

Description
-----------

After a message is parsed, but before the message is written,
`print_message/2' calls

     user:message_hook(+Severity,+MsgTerm,+Lines)

   If the call to `user:message_hook/3' succeeds, `print_message/2'
succeeds without further processing.  Otherwise the built-in message
portrayal is used.  It is often useful to have a message hook that
performs some action and then fails, allowing other message hooks to
run, and eventually allowing the message to be printed as usual.

Exceptions
----------

An exception raised by this predicate causes an error message to be
printed and then the original message is printed using the default
message text and formatting.

See Also
--------

*Note ref-msg::.


File: sicstus.info,  Node: mpg-ref-meta_predicate,  Next: mpg-ref-mode,  Prev: mpg-ref-initialization,  Up: mpg-bpr

11.3.118 `(meta_predicate)/1'  "[declaration]"
----------------------------------------------

Synopsis
--------

`:- meta_predicate +METASPEC'

   Provides for module name expansion of arguments in calls to the
predicate given by METASPEC. All `meta_predicate/1' declarations should
be at the beginning of a module.

Arguments
---------

:METASPEC
     "callable", must be ground

     Goal template or list of goal templates, of the form
     `functor(ARG1, ARG2,...)'.  Each ARGN is one of:

    `:'
          requires module name expansion

    `+'
    `-'
    `?'
          ignored

Exceptions
----------

`type_error'
`domain_error'
     in METASPEC

`context_error'
     "declaration appeared in query"

Examples
--------

Consider a sort routine, `mysort/3', to which the name of the
comparison predicate is passed as an argument:
     mysort(COMPAREPROC, INPUTLIST, OUTPUTLIST)

   If COMPAREPROC is module sensitive, an appropriate `meta_predicate'
declaration for `mysort/3' is:
     :- meta_predicate mysort(:, +, -).

   This means that whenever a goal `mysort(A, B, C)' appears in a
clause, it will be transformed at load time into `mysort(M:A, B, C)',
where M is the source module.  The transformation will happen unless:

  1. A has an explicit module prefix, or

  2. A is a variable and the same variable appears in the head of the
     clause in a module-name-expansion position.

See Also
--------

*Note Meta-Predicate Declarations::, *Note ref-mod-mne::.


File: sicstus.info,  Node: mpg-ref-mode,  Next: mpg-ref-multifile,  Prev: mpg-ref-meta_predicate,  Up: mpg-bpr

11.3.119 `(mode)/1'  "[declaration]"
------------------------------------

Synopsis
--------

`:- mode +MODE'

   Currently a dummy declaration.

Arguments
---------

:MODE
     "term"

See Also
--------

*Note Mode Declarations::.


File: sicstus.info,  Node: mpg-ref-module,  Next: mpg-ref-mutable,  Prev: mpg-ref-message_hook,  Up: mpg-bpr

11.3.120 `module/[2,3]'  "[declaration]"
----------------------------------------

Synopsis
--------

`:- module(+MODULENAME, +PUBLICPRED)'.

   `:- module(+MODULENAME, +PUBLICPRED, +OPTIONS)'.

   Declares the file in which the declaration appears to be a
module-file named MODULENAME, with public predicates PUBLICPRED. Must
appear as the first term in the file.

Arguments
---------

MODULENAME
     "atom", must be nonvar

PUBLICPRED
     "list of simple_pred_spec", must be ground

     List of predicate specifications of the form NAME/ARITY.

OPTIONS
     "list of term", must be ground

     A list of zero or more options of the form:

    `hidden(BOOLEAN)'
          BOOLEAN is `false' (the default) or `true'.  In the latter
          case, tracing of the predicates of the module is disabled
          (although spypoints can be set), and no source information is
          generated at compile time.

Description
-----------

The definition of a module is not limited to a single file, because a
module-file may contain commands to load other files.  If `myfile', a
module-file for MODULENAME, contains an embedded command to load
`yourfile' and if `yourfile' is not itself a module-file, then all the
predicates in `yourfile' are loaded into module MODULENAME.

   If the export list is not properly specified, there will be a warning
or error message at compile time.

Exceptions
----------

`instantiation_error'

`type_error'
     PREDSPECLIST is not a "list of simple_pred_spec"

`context_error'
     "declaration appeared in query", or TODO: declaration appears
     other than as the first term in a file being loaded.

See Also
--------

*Note Module Declarations::, *Note ref-mod::.


File: sicstus.info,  Node: mpg-ref-multifile,  Next: mpg-ref-nospy,  Prev: mpg-ref-mode,  Up: mpg-bpr

11.3.121 `(multifile)/1'  "[ISO,declaration]"
---------------------------------------------

Synopsis
--------

`:- multifile +PREDSPECS'

   Declares the clauses of the predicates defined by PREDSPECS to be
multifile in the source file (suppresses compile-time warnings).

Arguments
---------

:PREDSPECS
     "pred_spec_forest", must be ground

     A predicate specification, or a list of such, or a sequence of
     such separated by commas.

Description
-----------

By default, all clauses for a predicate are expected to come from just
one file.  This assists with reloading and debugging of code.
Declaring a predicate `multifile' means that its clauses can be spread
across several different files.  This is independent of whether or not
the predicate is declared `dynamic'.

   Should precede all the clauses for the specified predicates in the
file.

   There should be a `multifile' declaration for a predicate P in every
file that contains clauses for P.  If a `multifile' predicate is
dynamic, there should be a `dynamic' declaration in every file
containing clauses for the predicate.

   When a file containing clauses for a `multifile' predicate (P) is
reloaded, the clauses for P that previously came from that file are
removed.  Then the new clauses for P (which may be the same as the old
ones) are added to the end of the definition of the `multifile'
predicate.

   If a `multifile' declaration is found for a predicate that has
already been defined in another file (without a `multifile'
declaration), then this is considered to be a redefinition of that
predicate.  Normally this will result in a multiple-definition
style-check warning (see `style_check/1').

   The predicate `source_file/2' can be used to find all the files
containing clauses for a `multifile' predicate.

Exceptions
----------

`instantiation_error'
     PREDSPECS not ground.

`type_error'
     Either name or arity in PREDSPEC has the wrong type

`domain_error'
     ARITY not in the range 0..255.

`context_error'
     "declaration appeared in query", or TODO: declaration appears
     other than as the first term in a file being loaded.

See Also
--------

*Note Multifile Declarations::.


File: sicstus.info,  Node: mpg-ref-mutable,  Next: mpg-ref-name,  Prev: mpg-ref-module,  Up: mpg-bpr

11.3.122 `mutable/1'
--------------------

Synopsis
--------

`mutable(+TERM)'

   Succeeds if TERM is currently instantiated to a mutable term.

Arguments
---------

TERM
     "term"

See Also
--------

*Note ref-lte-met-typ::, *Note ref-lte-mut::.


File: sicstus.info,  Node: mpg-ref-name,  Next: mpg-ref-nl,  Prev: mpg-ref-mutable,  Up: mpg-bpr

11.3.123 `name/2'
-----------------

Synopsis
--------

`name(+CONSTANT, -CODES)'

   `name(-CONSTANT, +CODES)'

   CODES is the list consisting of the "codes" comprising the printed
representation of CONSTANT.

Arguments
---------

CONSTANT
     "atomic"

CODES
     "codes"

Description
-----------

Initially, either CONSTANT must be instantiated to a number or an atom,
or CODES must be instantiated to a proper "codes".

   If CONSTANT is initially instantiated to an atom or number, CODES
will be unified with the "codes" that make up its printed
representation.

   If CONSTANT is uninstantiated and CODES is initially instantiated to
a "codes" that corresponds to the correct syntax of a number (either
integer or float), CONSTANT will be bound to that number; otherwise
CONSTANT will be instantiated to an atom containing exactly those
characters.

   There are atoms for which `name(CONST,CHARLIST)' is true, but which
will not be constructed if `name/2' is called with CONST
uninstantiated.  One such atom is the atom `'1976''.  It is recommended
that new programs use `atom_codes/2' or `number_codes/2', as these
predicates do not have this inconsistency.

Exceptions
----------

`instantiation_error'
     If CONSTANT and CODES are both uninstantiated

`type_error'
     If CONSTANT is not a constant

`domain_error'
     CODES is not a "codes"

Examples
--------

     | ?- name(foo, L).

     L = [102,111,111]

     | ?- name('Foo', L).

     L = [70,111,111]

     | ?- name(431, L).

     L = [52,51,49]

     | ?- name(X, [102,111,111]).

     X = foo

     | ?- name(X, [52,51,49]).

     X = 431

     | ?- name(X, "15.0e+12").

     X = 1.5e+13

See Also
--------

*Note ref-lte-c2t::.


File: sicstus.info,  Node: mpg-ref-nl,  Next: mpg-ref-nodebug,  Prev: mpg-ref-name,  Up: mpg-bpr

11.3.124 `nl/[0,1]'  "[ISO]"
----------------------------

Synopsis
--------

`nl'

   `nl(+STREAM)'

   Terminates the current output record on the current output stream or
on STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid output _text_ stream, defaults to the current output
     stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`existence_error'
     Some operating system dependent error occurred in writing.

`permission_error'
     There is an error in the bottom layer of write function of the
     stream.

See Also
--------

*Note ref-iou-cou::.


File: sicstus.info,  Node: mpg-ref-nodebug,  Next: mpg-ref-nonmember,  Prev: mpg-ref-nl,  Up: mpg-bpr

11.3.125 `nodebug/0'  "[development]"
-------------------------------------

Synopsis
--------

`nodebug'

   Turns the debugger off.

See Also
--------

*Note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-nonmember,  Next: mpg-ref-nonvar,  Prev: mpg-ref-nodebug,  Up: mpg-bpr

11.3.126 `nonmember/2'
----------------------

Synopsis
--------

`nonmember(?ELEMENT, ?LIST)'

   is true if the given ELEMENT does not occur in the given LIST.  Its
purpose is to test for membership. Normally, the two arguments are
ground.

Arguments
---------

ELEMENT
     "term"

LIST
     "list of term"

Description
-----------

In the context of this predicate, a term occurs in a list if it can be
unified with an element of the list.

Backtracking
------------

The predicate is determinate and either succeeds or fails. It never
binds variables.

Examples
--------


     | ?- nonmember(bar, [foo,bar,baz]).
     no

See Also
--------

*Note ref-lte-acl::, `library(lists)'.


File: sicstus.info,  Node: mpg-ref-nonvar,  Next: mpg-ref-nospyall,  Prev: mpg-ref-nonmember,  Up: mpg-bpr

11.3.127 `nonvar/1'  "[ISO]"
----------------------------

Synopsis
--------

`nonvar(+TERM)'

   TERM is currently instantiated.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- nonvar(foo(X,Y)).

     true ;
     no
     | ?- nonvar([X,Y]).

     true ;
     no
     | ?- nonvar(X).

     no
     | ?- Term = foo(X,Y), nonvar(Term).

     true ;
     no

See Also
--------

*Note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-nospy,  Next: mpg-ref-public,  Prev: mpg-ref-multifile,  Up: mpg-bpr

11.3.128 `(nospy)/1'
--------------------

Synopsis
--------

`nospy +PREDSPECS'

   Any spypoints (plain and conditional) on the predicates represented
by PREDSPECS are removed.

Arguments
---------

:PREDSPECS
     "pred_spec_tree"

     A predicate specification, or a list of such.

Exceptions
----------

`instantiation_error'

`type_error'

`domain_error'

See Also
--------

*Note Basic Debug::, *Note Plain Spypoint::.


File: sicstus.info,  Node: mpg-ref-nospyall,  Next: mpg-ref-notrace,  Prev: mpg-ref-nonvar,  Up: mpg-bpr

11.3.129 `nospyall/0'  "[development]"
--------------------------------------

Synopsis
--------

`nospyall'

   Removes all the spypoints (including the generic ones) that have
been set.

See Also
--------

*Note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-not_equal_to,  Next: mpg-ref-greater_than,  Prev: mpg-ref-term_equal_to,  Up: mpg-bpr

11.3.130 `=\= /2'  "[ISO]"
--------------------------

Synopsis
--------

+EXPR1 `=\=' +EXPR2

   Succeeds if the results of evaluating EXPR1 and EXPR2 are _not
equal_.

Arguments
---------

EXPR1
     "expr", must be ground

EXPR2
     "expr", must be ground

Description
-----------

Evaluates EXPR1 and EXPR2 as arithmetic expressions and compares the
results.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- 7 =\= 14/2.

     no

     | ?- 7 =\= 15/2.

     yes

See Also
--------

*Note ref-ari::


File: sicstus.info,  Node: mpg-ref-not_greater_than,  Next: mpg-ref-term_equal_to,  Prev: mpg-ref-equal_to,  Up: mpg-bpr

11.3.131 `=< /2'  "[ISO]"
-------------------------

Synopsis
--------

+EXPR1 `=<' +EXPR2

   Succeeds if the result of evaluating EXPR1 is _less than or equal_
to the result of evaluating EXPR2.

Arguments
---------

EXPR1
     "expr", must be ground

EXPR2
     "expr", must be ground

Description
-----------

Evaluates EXPR1 and EXPR2 as arithmetic expressions and compares the
results.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- 42 =< 42.

     yes

     | ?- "b" =< "a".

     no

Comments
--------

Note that the symbol `=<' is used here rather than `<=', which is used
in some other languages.  One way to remember this is that the
inequality symbols in Prolog are the ones that cannot be thought of as
looking like arrows.  The `<' or `>' always points at the `='.

See Also
--------

*Note ref-ari::


File: sicstus.info,  Node: mpg-ref-not_less_than,  Next: mpg-ref-term_unify_decided,  Prev: mpg-ref-greater_than,  Up: mpg-bpr

11.3.132 `>= /2'  "[ISO]"
-------------------------

Synopsis
--------

+EXPR1 `>=' +EXPR2

   Succeeds if the results of evaluating EXPR1 and EXPR2 _are equal_.

Arguments
---------

EXPR1
     "expr", must be ground

EXPR2
     "expr", must be ground

Description
-----------

Succeeds if the result of evaluating EXPR1 is _greater than or equal
to_ the result of evaluating EXPR2.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- 42 >= 42.

     yes

     | ?- "b" >= "a".

     yes

See Also
--------

*Note ref-ari::


File: sicstus.info,  Node: mpg-ref-not_provable,  Next: mpg-ref-block,  Prev: mpg-ref-cut,  Up: mpg-bpr

11.3.133 `(\+)/1'  "[ISO]"
--------------------------

Synopsis
--------

`\+' +P

   Fails if the goal P has a solution, and succeeds otherwise.
Equivalent to:

     P -> fail ; true.

Arguments
---------

:P
     "callable", must be nonvar

Description
-----------

This is not normally regarded as a built-in predicate, since it is part
of the syntax of the language.  However, it is like a built-in
predicate in that you can say `call((`\+' P))'.

   Cuts in P do not make sense, but they are allowed, their scope being
the goal P.

Comments
--------

Remember that with prefix operators such as this one it is necessary to
be careful about spaces if the argument starts with a `('.  For example:

     | ?- \+ (P,Q).

is this operator applied to the conjunction of P and Q, but

     | ?- \+(P,Q).

would require a predicate `\+ /2' for its solution.  The prefix
operator can however be written as a functor of one argument; thus

     | ?- \+((P,Q)).

is also correct.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*Note ref-sem::.


File: sicstus.info,  Node: mpg-ref-not_unifiable,  Next: mpg-ref-term_not_equal_to,  Prev: mpg-ref-term_not_less_than,  Up: mpg-bpr

11.3.134 `\= /2'  "[ISO]"
-------------------------

Synopsis
--------

+TERM1 `\=' +TERM2

   TERM1 and TERM2 do not unify.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

Description
-----------

The same as `\+ X = Y'; i.e. X and Y are not unifiable.

See Also
--------

*Note Glossary::.


File: sicstus.info,  Node: mpg-ref-notrace,  Next: mpg-ref-nozip,  Prev: mpg-ref-nospyall,  Up: mpg-bpr

11.3.135 `notrace/0'  "[development]"
-------------------------------------

Synopsis
--------

`notrace'

   Turns the debugger off.

See Also
--------

*Note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-nozip,  Next: mpg-ref-number,  Prev: mpg-ref-notrace,  Up: mpg-bpr

11.3.136 `nozip/0'  "[development]"
-----------------------------------

Synopsis
--------

`nozip'

   Turns the debugger off.

See Also
--------

*Note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-number,  Next: mpg-ref-number_chars,  Prev: mpg-ref-nozip,  Up: mpg-bpr

11.3.137 `number/1'  "[ISO]"
----------------------------

Synopsis
--------

`number(+TERM)'

   TERM is currently instantiated to a number.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- number(5.2).

     yes
     | ?- number(5).

     yes

See Also
--------

*Note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-number_chars,  Next: mpg-ref-number_codes,  Prev: mpg-ref-number,  Up: mpg-bpr

11.3.138 `number_chars/2'  "[ISO]"
----------------------------------

Synopsis
--------

`number_chars(+NUMBER, -CHARS)'

   `number_chars(-NUMBER, +CHARS)'

   CHARS is the "chars" comprising the printed representation of NUMBER.

Arguments
---------

NUMBER
     "number"

CHARS
     "chars"

Description
-----------

Initially, either NUMBER must be instantiated to a number, or CHARS
must be instantiated to a proper "chars" (containing no variables).

   If NUMBER is initially instantiated to a number, CHARS will be
unified with the "chars" that make up its printed representation.

   If NUMBER is uninstantiated and CHARS is initially instantiated to a
"chars" that corresponds to the correct syntax of a number, NUMBER will
be bound to that number; otherwise `number_chars/2' will simply fail.

Exceptions
----------

`instantiation_error'
     NUMBER and CHARS are both uninstantiated

`type_error'
     NUMBER is not a number or CHARS is not a list, or CHARS is not a
     "chars"

`representation_error'
     CHARS is a list corresponding to a number that can't be represented

`syntax_error'
     CHARS does not correspond to a syntactically valid number

See Also
--------

`number_codes/2'.


File: sicstus.info,  Node: mpg-ref-number_codes,  Next: mpg-ref-numbervars,  Prev: mpg-ref-number_chars,  Up: mpg-bpr

11.3.139 `number_codes/2'  "[ISO]"
----------------------------------

Synopsis
--------

`number_codes(+NUMBER, -CODES)'

   `number_codes(-NUMBER, +CODES)'

   CODES is the "codes" comprising the printed representation of NUMBER.

Arguments
---------

NUMBER
     "number"

CODES
     "codes"

Description
-----------

Initially, either NUMBER must be instantiated to a number, or CODES
must be instantiated to a proper "codes".

   If NUMBER is initially instantiated to a number, CODES will be
unified with the "codes" that make up its printed representation.

   If NUMBER is uninstantiated and CODES is initially instantiated to a
"codes" that corresponds to the correct syntax of a number, NUMBER will
be bound to that number; otherwise `number_codes/2' will simply fail.

Exceptions
----------

`instantiation_error'
     NUMBER and CODES are both uninstantiated

`type_error'
     NUMBER is not a number or CODES is not a list

``domain_error''
     CODES is not a "codes"

`representation_error'
     CODES is a list corresponding to a number that can't be represented

`syntax_error'
     CHARS does not correspond to a syntactically valid number

Examples
--------

     | ?- number_codes(foo, L).

     no

     | ?- number_codes(431, L).

     L = [52,51,49]

     | ?- number_codes(X, [102,111,111]).

     no

     | ?- number_codes(X, [52,51,49]).

     X = 431

     | ?- number_codes(X, "15.0e+12").

     X = 1.5e+13

See Also
--------

`number_chars/2'.


File: sicstus.info,  Node: mpg-ref-numbervars,  Next: mpg-ref-on_exception,  Prev: mpg-ref-number_codes,  Up: mpg-bpr

11.3.140 `numbervars/3'  "[meta_logic]"
---------------------------------------

Synopsis
--------

`numbervars(+TERM, +FIRSTVAR, -LASTVAR)'

   instantiates  each of the variables in TERM to a term of the form
`'$VAR'(N)'.

Arguments
---------

TERM
     "term"

FIRSTVAR
     "integer", must be nonvar

LASTVAR
     "integer"

Description
-----------

FIRSTVAR is used as the value of N for the first variable in TERM
(starting from the left).  The second distinct variable in TERM is
given a value of N satisfying "N is FIRSTVAR+1"; the third distinct
variable gets the value FIRSTVAR+2, and so on.  The last variable in
TERM has the value LASTVAR-1.

   Notice that in the example below, `display/1' is used rather than
`write/1'.  This is because `write/1' treats terms of the form
`'$VAR'(N)' specially; it writes `A' if N=0, `B' if N=1, ...`Z' if N=25,
`A1' if N=26, etc.  That is why, if you type the goal in the example
below, the variable bindings will also be printed out as follows:

     Term = foo(W,W,X),
     A = W,
     B = X

Exceptions
----------

`instantiation_error'
     FIRSTVAR is uninstantiated

`type_error'
     FIRSTVAR is not an integer

Examples
--------

     | ?- Term = foo(A, A, B), numbervars(Term, 22, _), display(Term).
     foo($VAR(22),$VAR(22),$VAR(23))

See Also
--------

*Note ref-lte-anv::, `listing/[0,1]', `write_term/[2,3]'.


File: sicstus.info,  Node: mpg-ref-on_exception,  Next: mpg-ref-once,  Prev: mpg-ref-numbervars,  Up: mpg-bpr

11.3.141 `on_exception/3'
-------------------------

Synopsis
--------

`on_exception(-EXCEPTION, +PROTECTEDGOAL, +HANDLER)'

   Specify an exception handler for PROTECTEDGOAL, and call
PROTECTEDGOAL, as described in *Note ref-ere::.

Arguments
---------

EXCEPTION
     "term"

:PROTECTEDGOAL
     "callable", must be nonvar

:HANDLER
     "callable", must be nonvar

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

Fail on exception:
     :-meta_predicate fail_on_exception(:).
     fail_on_exception(C):-
         on_exception(E,C,print_exception_then_fail(C,E)).

     print_exception_then_fail(C,E):-
         format('Exception occured while calling ~q:~n', [C]),
         print_message(warning,E),
         fail.

Backtracking
------------

Depends on PROTECTEDGOAL and HANDLER.

See Also
--------

*Note ref-ere::.


File: sicstus.info,  Node: mpg-ref-once,  Next: mpg-ref-op,  Prev: mpg-ref-on_exception,  Up: mpg-bpr

11.3.142 `once/1'  "[ISO]"
--------------------------

Synopsis
--------

`once(+P)'

   Equivalent to:

     P -> true ; fail.

Arguments
---------

:P
     "callable", must be nonvar

   Cuts in P do not make sense, but they are allowed, their scope being
the goal P.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*Note ref-sem::.


File: sicstus.info,  Node: mpg-ref-op,  Next: mpg-ref-open,  Prev: mpg-ref-once,  Up: mpg-bpr

11.3.143 `op/3'  "[ISO]"
------------------------

Synopsis
--------

`op(+PRECEDENCE, +TYPE, +NAME)'

   declares NAME to be an operator of the stated TYPE and PRECEDENCE.

Arguments
---------

PRECEDENCE
     "integer", must be nonvar and in the range 1-1200

TYPE
     "one of `[xfx,xfy,yfx,fx,fy,xf,yf]'", must be nonvar

NAME
     "atom" or "list of atom", must be ground

Description
-----------

Operators are a notational convenience to read and write Prolog terms.
You can define new operators using `op/3'.

   The PRECEDENCE of an operator is used to disambiguate the way terms
are parsed. The general rule is that the operator with the highest
precedence is the principal functor.

   The TYPE of an operator decides the position of an operator and its
associativity. In the atom that represents the type the character `f'
represents the position of the operator.  For example, a type `fx' says
that the operator is a prefix operator.  The character `y' indicates
that the operator is associative in that direction. For example, an
operator of type `xfy' is a right-associative, infix operator.

   To cancel the operator properties of NAME (if any) set PRECEDENCE to
0.  

Exceptions
----------

`instantiation_error'
     An argument is not ground

`type_error'
     PRECEDENCE is not an integer or TYPE is not an integer or an
     operator is not an atom

`domain_error'
     PRECEDENCE is not in the range 1-1200, or TYPE is invalid,

`permission_error'
     Attempt to redefine the operator `',''

See Also
--------

`current_op/3', *Note ref-syn-ops::.


File: sicstus.info,  Node: mpg-ref-open,  Next: mpg-ref-open_null_stream,  Prev: mpg-ref-op,  Up: mpg-bpr

11.3.144 `open/[3,4]'  "[ISO]"
------------------------------

Synopsis
--------

`open(+FILESPEC, +MODE, -STREAM)'

   `open(+FILESPEC, +MODE, -STREAM, +OPTIONS)'

   Creates a Prolog stream by opening the file FILESPEC in mode MODE
with options OPTIONS.

Arguments
---------

FILESPEC
     "file_spec" or "integer", must be ground

     A file specification or file descriptor.

MODE
     "one of `[read,write,append]'", must be nonvar

     An atom specifying the open mode of the target file.  One of:

    `read'
          open FILESPEC for input.

    `write'
          open FILESPEC for output.  A new file is created if FILESPEC
          does not exist. If the file already exists, then it is set to
          empty and its previous contents are lost.

    `append'
          opens FILESPEC for output.  If FILESPEC already exists, adds
          output to the end of it.  If not, a new file is created.

OPTIONS
     "list of term", must be ground

     A list of zero or more of the following.

    `type(+T)'
          Specifies whether the stream is a `text' or `binary' stream.
          Default is `text'.

    `reposition(+BOOLEAN)'
          Specifies whether repositioning is required for the stream
          (`true'), or not (`false'). The latter is the default.

    `alias(+A)'
          Specifies that the atom A is to be an alias for the stream.

    `eof_action(+ACTION)'
          Specifies what action is to be taken when the end of stream
          has already been reported (by returning -1 or `end_of_file'),
          and a further attempt to input is made. ACTION can have the
          following values:

         `error'
               An exception is raised. This is the default.

         `eof_code'
               An end of stream indicator (-1 or `end_of_file') is
               returned again.

         `reset'
               The stream is considered not to be past end of stream and
               another attempt is made to input from it.

    `encoding(ENCODING)'
          Specifies the encoding to use if the stream is opened in text
          mode, as an atom. The default is `'ISO-8859-1'', the 8 bit
          subset of UNICODE, i.e. "ISO 8859/1" (Latin 1) (*note
          ref-iou-sfh-enc::).

          Overridden by the `encoding_signature/1' option, see below.

    `encoding_signature(+BOOLEAN)'
          Specifies whether an encoding signature should be used
          (`true'), or not (`false'). An encoding signature is a
          special byte sequence that identifies the encoding used in
          the file. The most common case is one of the Unicode
          signatures, often called "byte order mark" (BOM).

          A Unicode signature is a special byte sequence that can be
          used to distinguish between several UTF encoding variants,
          such as "UTF-8", "UTF-16-BE" and "UTF-16-LE".

          If the file is opened in mode read then `encoding_signature/1'
          defaults to `true'. When `encoding_signature(true)' is
          specified additional heuristics will be used if no Unicode
          signature is detected. Only if neither a Unicode signature
          nor these heuristics specifies a character encoding will the
          `encoding/1' option, if any, be used.

          The method used for selecting character encoding when a text
          file is opened in mode `read' is the first applicable item in
          the following list:

            1. If the `encoding_signature/1' option is `true' (the
               default): If a byte order mark is detected it will be
               used to select between the encodings "UTF-8", "UTF-16"
               or "UTF-32" with suitable endianess.

            2. If the `encoding_signature/1' option is `true' (the
               default): If an Emacs style
               `-*- coding: CODING-SYSTEM-*-' is present on the first
               non-empty line of the file then it will be used.

            3. If an option `encoding(ENCODING)' is supplied, the
               specified encoding will be used.

            4. As a final fallback, "ISO 8859/1" (Latin 1) will be used.


          the character encoding selected in this way will be used if
          it is recognized, otherwise an error exception is raised.

          If the file is opened in mode write then it depends on the
          character encoding whether an encoding signature will be
          output by default or not. If you want to force an encoding
          signature to be output for those encodings that supports it
          you can specify `encoding_signature(true)'.  Conversely, if
          you want to prevent an encoding signature from being output
          you can explicitly specify `encoding_signature(false)'.

          All UTF encodings supports an encoding signature in the form
          of a BOM. "UTF-8" does not write a BOM unless you explicitly
          specify `encoding_signature(true)', the 16 and 32 bit UTF
          encodings, e.g. "UTF-16 BE", "UTF-32 LE" writes a BOM unless
          explicitly requested not to with `encoding_signature(false)'.

          If the file is opened in mode append then
          `encoding_signature/1' defaults to `false'.

    `eol(EOL)'
          Specifies how line endings in the file should be handled if
          the stream is opened in text mode.

          In Prolog code, end of line is always represented by the
          character `'\n'', which has character code 10, i.e. the same
          as ASCII Line Feed (<LFD>). The representation in the file
          may be different, however.

          EOL can have the following values:

         `lf'
               Line Feed (`LF', character code 10) is used to specify a
               end of line.  This can be used for both read mode and
               write mode streams.

         `crlf'
               A two character sequence Carriage Return (`CR',
               character code 13) followed by Line Feed (`LF',
               character code 10) is used to specify a end of line.
               This can be used for both read mode and write mode
               streams.

         `auto'
               Translate both the two character sequence `CR' `LF' and
               single `CR' or `LF' into an end of line character.  This
               can be used only for read mode streams.

         `default'
               Use a default end of line convention. This is the
               default.

               Under UNIX, this uses `lf' for streams opened in write
               mode and `auto' for streams opened in read mode. Under
               Windows, this uses `crlf' for streams opened in write
               mode and `auto' for streams opened in read mode.  This
               can be used for both read mode and write mode streams.


    `if_exists(+ACTION)'
          Specifies what should happen if the file already exists. Only
          valid if MODE is `write' or `append'. ACTION can have the
          following values:

         `default'
               The file is overwritten or appended to, according to the
               MODE argument. This is the default.

         `error'
               An exception is raised.

         `generate_unique_name'
               If a file named FILESPEC already exists, FILESPEC is
               rewritten so that it refers to a non-existing file.
               FILESPEC is rewritten by adding digits at the end of the
               file name (but before any extension). The generated
               name, REALNAME can be obtain by using
               `stream_property(STREAM, file_name(RealName))' on the
               resulting stream. See the example below.


Description
-----------

If FILESPEC is a valid file specification, the file that it denotes is
opened in mode MODE.

   The resulting stream is unified with STREAM.

   STREAM is used as an argument to Prolog input and output predicates.

   STREAM can also be converted to the corresponding foreign
representation through `stream_code/2' and used in foreign code to
perform input/output operations.

   The following example creates two log files, both based on the the
base name `my.log'. The files will be written to a directory suitable
for temporary files (*note ref-fdi-fsp-pre::).

     open(temp('my.log'), write, S1, [if_exists(generate_unique_name)]),
     open(temp('my.log'), write, S2, [if_exists(generate_unique_name)]),
     stream_property(S1, file_name(N1)),
     stream_property(S2, file_name(N2)),
     format('Logging to ~a and ~a~n', [N1, N2]),
     ...

   Under UNIX this would produce something like:

     Logging to /tmp/my.log and /tmp/my1886415233.log

Exceptions
----------

`instantiation_error'
     FILESPEC or MODE is not instantiated.  OPTIONS argument is not
     ground.

`type_error'
     FILESPEC or MODE is not an atom type.  OPTIONS is not a list type
     or an element in OPTIONS is not a correct type for open options.

`domain_error'
     MODE is not one of `read', `write' or `append'.  OPTIONS has an
     undefined option or an element in OPTIONS is out of the domain of
     the option.

`existence_error'
     The specified FILESPEC does not exist.

`permission_error'
     Can not open FILESPEC with specified MODE and OPTIONS.

`resource_error'
     There are too many files opened.

See Also
--------

*Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-open_null_stream,  Next: mpg-ref-otherwise,  Prev: mpg-ref-open,  Up: mpg-bpr

11.3.145 `open_null_stream/1'
-----------------------------

Synopsis
--------

`open_null_stream(-STREAM)'

   opens an output _text_ stream that is not connected to any file and
unifies its stream object with STREAM.

Arguments
---------

STREAM
     "stream_object"

Description
-----------

Characters or terms that are sent to this stream are thrown away.  This
predicate is useful because various pieces of local state are kept for
null streams: the predicates `character_count/2', `line_count/2', and
`line_position/2' can be used on these streams.

See Also
--------

*Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-or,  Next: mpg-ref-less_than,  Prev: mpg-ref-if_then,  Up: mpg-bpr

11.3.146 `;/2'  "[ISO]"
-----------------------

Synopsis
--------

+P `;' +Q

   Disjunction: Succeeds if P succeeds _or_ Q succeeds.

   +P `->' +Q `;' +R

   _If_ P _then_ Q _else_ R, using first solution of P only.

Arguments
---------

:P
     "callable", must be nonvar

:Q
     "callable", must be nonvar

:R
     "callable", must be nonvar

Description
-----------

These are normally regarded as part of the syntax of the language, but
they are like a built-in predicate in that you can write `call((P `;'
Q))' or `call((P `->' Q `;' R))'.

   The character `|' (vertical bar) can be used as an alternative to
`;'.

   The operator precedences of the `;' and `->' are both greater than
1000, so that they dominate commas.

   Cuts in P do not make sense, but they are allowed, their scope being
the goal P.  The scope of cuts in Q and R extends to the containing
clause.

Backtracking
------------

For the if-then-else construct: if P succeeds and Q then fails,
backtracking into P does not occur.  A cut in P does not make sense.
`->' acts like a cut except that its range is restricted to within the
disjunction: it cuts away R and any choice points within P.  `->' may
be thought of as a "local cut".  

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*Note ref-sem::.


File: sicstus.info,  Node: mpg-ref-otherwise,  Next: mpg-ref-peek_byte,  Prev: mpg-ref-open_null_stream,  Up: mpg-bpr

11.3.147 `otherwise/0'
----------------------

Synopsis
--------

`otherwise'

   Always succeeds (same as `true/0').

Tips
----

Useful for laying out conditionals in a readable way.

See Also
--------

*Note ref-sem::.


File: sicstus.info,  Node: mpg-ref-peek_byte,  Next: mpg-ref-peek_char,  Prev: mpg-ref-otherwise,  Up: mpg-bpr

11.3.148 `peek_byte/[1,2]'  "[ISO]"
-----------------------------------

Synopsis
--------

`peek_byte(-BYTE)'

   `peek_byte(+STREAM, -BYTE)'

   looks ahead for next input byte on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _binary_ stream, defaults to the current input
     stream.

BYTE
     "byte" or -1

     The resulting next input byte available on the stream.

Description
-----------

`peek_byte/[1,2]' looks ahead of the next input byte of the specified
input stream and unifies the "byte" with BYTE.  The peeked byte is
still available for subsequent input on the stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`type_error'
     BYTE is an invalid byte.

`existence_error'
     Attempt to read past end of file, or some operating system
     dependent error occurred in reading.

See Also
--------

*Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-peek_char,  Next: mpg-ref-peek_code,  Prev: mpg-ref-peek_byte,  Up: mpg-bpr

11.3.149 `peek_char/[1,2]'  "[ISO]"
-----------------------------------

Synopsis
--------

`peek_char(-CHAR)'

   `peek_char(+STREAM, -CHAR)'

   looks ahead for next input character on the current input stream or
on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream.

CHAR
     "char" or "one of [`end_of_file']"

     The resulting next input character available on the stream.

Description
-----------

`peek_char/[1,2]' looks ahead of the next input character of the
specified input stream and unifies the character with CHAR.  The peeked
character is still available for subsequent input on the stream.

Comments
--------

It is safe to call `peek_char/[1,2]' several times without actually
inputting any character.  For example:
     | ?- peek_char(X), peek_char(X), get_char(X).
     |: a

     X = a

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`existence_error'
     Attempt to read past end of file, or some operating system
     dependent error occurred in reading.

See Also
--------

*Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-peek_code,  Next: mpg-ref-phrase,  Prev: mpg-ref-peek_char,  Up: mpg-bpr

11.3.150 `peek_code/[1,2]'  "[ISO]"
-----------------------------------

Synopsis
--------

`peek_code(-CODE)'

   `peek_code(+STREAM, -CODE)'

   looks ahead for next input character on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream, defaults to the current input stream.

CODE
     "code" or -1

     The resulting next input character available on the stream.

Description
-----------

`peek_code/[1,2]' looks ahead of the next input character of the
specified input stream and unifies the character with CODE.  The peeked
character is still available for subsequent input on the stream.

Comments
--------

Comments
--------

It is safe to call `peek_code/[1,2]' several times without actually
inputting any character.  For example:
     | ?- peek_code(X), peek_code(X), get_code(X).
     |: a

     X = 97

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`existence_error'
     Attempt to read past end of file, or some operating system
     dependent error occurred in reading.

See Also
--------

*Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-phrase,  Next: mpg-ref-portray,  Prev: mpg-ref-peek_code,  Up: mpg-bpr

11.3.151 `phrase/[2,3]'
-----------------------

Synopsis
--------

`phrase(+PHRASETYPE, +LIST)'

   `phrase(+PHRASETYPE, +LIST, -REST)'

   Used in conjunction with a grammar to parse or generate strings.

Arguments
---------

:PHRASETYPE
     "callable", must be nonvar

     Name of a phrase type.

LIST
     "list of term"

     A list of symbols -- tokens or "codes".

REST
     "list of term"

     A tail of LIST; what remains of LIST after PHRASETYPE has been
     found.  Defaults to `[]'.

Description
-----------

This predicate is a convenient way to start execution of grammar rules.
Runs through the grammar rules checking whether there is a path by
which PHRASETYPE can be rewritten as LIST.

   If LIST is bound, this goal corresponds to using the grammar for
parsing.  If LIST is unbound, this goal corresponds to using the
grammar for generation.

   `phrase/[2,3]' succeeds when the portion of LIST between the start of
LIST and the start of REST is a phrase of type PHRASETYPE (according to
the current grammar rules), where PHRASETYPE is either a non-terminal
or, more generally, a grammar rule body.

   `phrase/[2,3]' allows variables to occur as non-terminals in grammar
rule bodies, just as `call/1' allows variables to occur as goals in
clause bodies.

Backtracking
------------

Depends on PHRASETYPE.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*Note ref-lod-exp::, *Note ref-gru::.


File: sicstus.info,  Node: mpg-ref-portray,  Next: mpg-ref-portray_clause,  Prev: mpg-ref-phrase,  Up: mpg-bpr

11.3.152 `portray/1'  "[hook]"
------------------------------

Synopsis
--------

`:- multifile user:portray/1.'

   `user:portray(+TERM)'

   A way for the user to over-ride the default behavior of `print/1'.

Arguments
---------

TERM
     "term"

Description
-----------

If `user:portray/1' is defined, then the predicates listed below
performing term output will call it on the term itself and on every
non-variable subterm T.  If `user:portray/1' succeeds, it is assumed to
have written T. If it fails, the calling predicate will write the
principal functor of T and treat the arguments of T recursively.

   Note that on lists (`[_|_]'), `user:portray/1' will be called on the
whole list to `user:portray/1' and, if that call fails, on each list
element, but _not_ on every tail of the list.

   The affected predicates are:

`print/[1,2]'

`write_term/[2,3]'
     when used with the option `portrayed(true)'

goals during debugging
     controlled by the `debugger_print_options' Prolog flag, whose
     value by default includes `portrayed(true)'

top-level variable bindings
     controlled by the `toplevel_print_options' Prolog flag, whose
     value by default includes `portrayed(true)'

Exceptions
----------

Exceptions are treated as failures, except an error message is printed
also

See Also
--------

*Note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-portray_clause,  Next: mpg-ref-portray_message,  Prev: mpg-ref-portray,  Up: mpg-bpr

11.3.153 `portray_clause/[1,2]'
-------------------------------

Synopsis
--------

`portray_clause(+CLAUSE)'

   `portray_clause(+STREAM, +CLAUSE)'

   Writes CLAUSE to the current output stream. Used by `listing/[0,1]'.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

CLAUSE
     "term"

Description
-----------

The operation used by `listing/[0,1]'.  CLAUSE is written to STREAM, in
exactly the format in which `listing/[0,1]' would have written it,
including a terminating full-stop.

   If you want to print a clause, this is almost certainly the command
you want.  By design, none of the other term output commands puts a
full-stop after the written term.  If you are writing a file of facts
to be loaded by the Load Predicates, use `portray_clause/[1,2]', which
attempts to ensure that the clauses it writes out can be read in again
as clauses.

   The output format used by `portray_clause/[1,2]' and `listing/[0,1]'
has been carefully designed to be clear.  We recommend that you use a
similar style.  In particular, never put a semicolon (disjunction
symbol) at the end of a line in Prolog.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

Examples
--------

     | ?- portray_clause((X:- a -> b ; c)).
     _ :-
             (   a ->
                 b
             ;   c
             ).

     | ?- portray_clause((X:- a -> (b -> c ; d ; e); f)).
     _ :-
             (   a ->
                 (   b ->
                     c
                 ;   d
                 ;   e
                 )
             ;   f
             ).

     | ?- portray_clause((a:-b)).
     a :-
             b.

     | ?- portray_clause((a:-b,c)).
     a :-
             b,
             c.

     | ?- portray_clause((a:-(b,!,c))).
     a :-
             b, !,
             c.

See Also
--------

`listing/[0,1]', *Note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-portray_message,  Next: mpg-ref-predicate_property,  Prev: mpg-ref-portray_clause,  Up: mpg-bpr

11.3.154 `portray_message/2'  "[hook]"
--------------------------------------

Synopsis
--------

`:- multifile user:portray_message/2.'

   `user:portray_message(+SEVERITY, +MESSAGETERM)'

   Called by `print_message/2' before processing the message.  If this
succeeds, it is assumed that the message has been processed and nothing
further is done.

Arguments
---------

SEVERITY
     "one of `[informational,warning,error,help,silent]'"

MESSAGETERM
     "term"

Exceptions
----------

An exception raised by this predicate causes an error message to be
printed and then the original message is printed using the default
message text and formatting.

See Also
--------

*Note ref-msg::.


File: sicstus.info,  Node: mpg-ref-predicate_property,  Next: mpg-ref-print,  Prev: mpg-ref-portray_message,  Up: mpg-bpr

11.3.155 `predicate_property/2'
-------------------------------

Synopsis
--------

`predicate_property(?CALLABLE, ?PREDPROPERTY)'

   Unifies PREDPROPERTY with a predicate property of an existing
predicate, and CALLABLE with the most general term that corresponds to
that predicate.

Arguments
---------

:CALLABLE
     "callable"

     The skeletal specification of a loaded predicate.

PREDPROPERTY
     "term"

     The various properties associated with CALLABLE.    Each loaded
     predicate will have one or more of the properties:

        * one of the atoms `built_in' (for built-in predicates) or
          `compiled' or `interpreted' (for user defined predicates) or
          `fd_constraint' for FD predicates *note Defining Primitive
          Constraints::.

        * the atom `dynamic' for predicates that have been declared
          dynamic (*note Dynamic Declarations::),

        * the atom `multifile' for predicates that have been declared
          multifile (*note Multifile Declarations::),

        * the atom `volatile' for predicates that have been declared
          volatile (*note Volatile Declarations::),

        * one or more terms `(block TERM)' for predicates that have
          block declarations (*note Block Declarations::),

        * the atom `exported' or terms `imported_from(MODULEFROM)' for
          predicates exported or imported from modules (*note
          ref-mod::),

        * the term `(meta_predicate TERM)' for predicates that have
          meta-predicate declarations (*note ref-mod-met::).

Description
-----------

If CALLABLE is instantiated then `predicate_property/2' successively
unifies PREDPROPERTY with the various properties associated with
CALLABLE.

   If PREDPROPERTY is bound to a valid predicate property, then
`predicate_property/2' successively unifies CALLABLE with the skeletal
specifications of all loaded predicates having PREDPROPERTY.

   If CALLABLE is not a loaded predicate or PREDPROPERTY is not a valid
predicate property, the call fails.

   If both arguments are unbound, then `predicate_property/2' can be
used to backtrack through all currently defined predicates and their
corresponding properties.

Examples
--------

   * Predicates acquire properties when they are defined:

          | ?- [user].
          | :- dynamic p/1.
          | p(a).
          | end_of_file.
          % user compiled 0.117 sec 296 bytes

          yes
          | ?- predicate_property(p(_), Property).

          Property = dynamic ;

          Property = interpreted ;

   * To backtrack through all the predicates `P' imported into module
     `m' from any module:
          | ?- predicate_property(m:P, imported_from(_)).

   * To backtrack through all the predicates `P' imported into module
     `m1' from module `m2':
          | ?- predicate_property(m1:P, imported_from(m2)).

   * To backtrack through all the predicates `P' exported by module `m':
          | ?- predicate_property(m:P, exported).

   * A variable can also be used in place of a module atom to find the
     names of modules having a predicate and property association:

          | ?- predicate_property(M:f, imported_from(m1)).

     will return all modules `M' that import `f/0' from `m1'.

See Also
--------

*Note ref-lps-ove::.


File: sicstus.info,  Node: mpg-ref-print,  Next: mpg-ref-print_message,  Prev: mpg-ref-predicate_property,  Up: mpg-bpr

11.3.156 `print/[1,2]'  "[hookable]"
------------------------------------

Synopsis
--------

`print(+STREAM, +TERM)'

   `print(+TERM)'

   Writes TERM on the standard output stream, without quoting atoms,
calling `user:portray/1' on subterms.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

`print(Term)' is equivalent to:

     write_term(Term, [portrayed(true),numbervars(true)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*Note ref-iou-tou::, `user:portray/1'.


File: sicstus.info,  Node: mpg-ref-print_message,  Next: mpg-ref-print_message_lines,  Prev: mpg-ref-print,  Up: mpg-bpr

11.3.157 `print_message/2'  "[hookable]"
----------------------------------------

Synopsis
--------

`print_message(+SEVERITY, +MESSAGETERM)'

   Print a MESSAGE of a given SEVERITY. The behavior can be customized
using the hooks `user:portray_message/2',
`user:generate_message_hook/3' and `user:message_hook/3'.

Arguments
---------

SEVERITY
     "atom", must be nonvar

     Unless the default system portrayal is overidden with
     `user:message_hook/3', SEVERITY must be one of:

    Value
          Prefix

    `informational'
          `% '

    `warning'
          `* '

    `error'
          `! '

    `help'
    `query'
    `silent'
          no prefix

MESSAGETERM
     "term"

Description
-----------

First `print_message/2' calls `user:portray_message/2' with the same
arguments.  If this does not succeed, the message is processed in the
following phases:

   * Message generation phase: the abstract message term MESSAGE is
     formatted, i.e. converted to a format-command list.  First the hook
     predicate `user:generate_message_hook/3' is tried, then if it does
     not succeed, `'SU_messages':generate_message/3' is called.  The
     latter predicate is defined in terms of definite clause grammars
     in `library('SU_messages')'.  If that also does not succeed, then
     the built-in default conversion is used, which gives the following
     result:

          ['~q'-[MESSAGE],nl]

   * Line splitting transformation: the format-command list is
     converted to format-command lines--the list is broken up into a
     list of lists, each list containing format-commands for one line.

   * Message printing phase: The text of the message (format-command
     lines generated in the previous stage) is printed.  First the hook
     predicate `user:message_hook/3' is tried, then, if it does not
     succeed, the built-in predicate `print_message_lines/3' is called
     for the `user_error' stream.

   An unhandled exception message E calls `print_message(error, E)'
before returning to the top level.  The convention is that an error
message is the result of an unhandled exception.  Thus, an error
message should only be printed if `raise_exception/1' does not find a
handler and unwinds to the top-level.

   All messages from the system are printed using this predicate.
Means of intercepting these messages before they are printed are
provided.

   `print_message/2' always prints to `user_error'. Messages can be
redirected to other streams using `user:message_hook/3' and
`print_message_lines/3'

   Silent messages do not get translated or printed, but they can be
intercepted with `user:portray_message/2' and `user:message_hook/3'.

Exceptions
----------

`instantiation_error'
`type_error'
`domain_error'
     in SEVERITY

See Also
--------

*Note ref-msg::.


File: sicstus.info,  Node: mpg-ref-print_message_lines,  Next: mpg-ref-profile_data,  Prev: mpg-ref-print_message,  Up: mpg-bpr

11.3.158 `print_message_lines/3'
--------------------------------

Synopsis
--------

`print_message_lines(+STREAM, +SEVERITY, +LINES)'

   Print the LINES to STREAM, preceding each line with a prefix
corresponding to SEVERITY.

Arguments
---------

STREAM
     "stream_object", must be ground

     Any valid output stream.

SEVERITY
     "one of `[query,help,informational,warning,error,silent,"term"]'"

LINES
     "list of list of pair"

     Must be of the form `[LINE1, LINE2, ...]', where each LINEI must
     be of the form `[CONTROL_1-ARGS_1,CONTROL_2-ARGS_2, ...]'.

Description
-----------

If SEVERITY is a valid severity, the prefix will be as described for
`print_message/2', otherwise SEVERITY itself will be used as the
prefix.  If SEVERITY is `query', no newline is written after the last
line (otherwise, a newline is written).

   This predicate is intended to be used in conjunction with
`user:message_hook/3'.  After a message is intercepted using
`user:message_hook/3', this command is used to print the lines.  If the
hook has not been defined, the arguments are those provided by the
system.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`instantiation_error'
`type_error'
     in LINES.

Examples
--------

Suppose you want to intercept messages and force them to go to a
different stream:

     user:message_hook(Severity, Message, Lines):-
         my_stream(MyStream),
         print_message_lines(MyStream, Severity, Lines).

See Also
--------

*Note ref-msg::.


File: sicstus.info,  Node: mpg-ref-profile_data,  Next: mpg-ref-profile_reset,  Prev: mpg-ref-print_message_lines,  Up: mpg-bpr

11.3.159 `profile_data/4'  "[development]"
------------------------------------------

Synopsis
--------

`profile_data(+SPEC, ?SELECTION, ?RESOLUTION, ?DATA)'

   DATA is profiling data collected from the predicates covered by the
generalized predicate spec SPEC.

Arguments
---------

:SPEC
     "pred_spec_tree"

     A predicate specification, or a list of such.

SELECTION
     "one of `[calls,choice_points,instructions]'"

     The kind of profiling data to be collected.

RESOLUTION
     "one of `[predicate,clause]'"

     The level of resolution of the profiling data.

DATA
     "list of pair"

     Will be instantiated to a list of key-value pairs.

Description
-----------

The SELECTION argument determines the kind of profiling data to be
collected.  If uninstantiated, the predicate will backtrack over its
possible values, which are:

`calls'
     All instances of entering a clause by a procedure call are
     counted.  This is equivalent to counting all procedure calls _that
     have not been determined to fail by indexing on the first
     argument_.

`choice_points'
     All instances of accessing a choicepoint are counted.  This occurs,
     roughly, when there are more than one possibly matching clauses
     for a procedure call, when a disjunction is entered, as well as
     when profiled code is re-entered upon backtracking.

`instructions'
     The (number of virtual machine instructions) executed in the
     selected piece of code, plus 2*(number of choiceopint accesses).

   The RESOLUTION argument determines the level of resolution of the
profiling data to be collected.  If uninstantiated, the predicate will
backtrack over its possible values, which are:

`predicate'
     DATA is a list of terms `MODULE:NAME/ARITY-COUNT', where COUNT is
     a sum of the corresponding counts per clause.

`clause'
     DATA is a list of terms `MODULE:NAME/ARITY/CLAUSENO-COUNT'.

Backtracking
------------

Can be used to backtrack over all profiling data for the given SPEC.

See Also
--------

*Note Execution Profiling::.


File: sicstus.info,  Node: mpg-ref-profile_reset,  Next: mpg-ref-prolog_flag,  Prev: mpg-ref-profile_data,  Up: mpg-bpr

11.3.160 `profile_reset/1'  "[development]"
-------------------------------------------

Synopsis
--------

`profile_reset(+SPEC)'

   Zeroes all counters for predicates covered by the generalized
predicate spec SPEC.

Arguments
---------

:SPEC
     "pred_spec_tree"

     A predicate specification, or a list of such.

See Also
--------

*Note Execution Profiling::.


File: sicstus.info,  Node: mpg-ref-prolog_flag,  Next: mpg-ref-prolog_load_context,  Prev: mpg-ref-profile_reset,  Up: mpg-bpr

11.3.161 `prolog_flag/[2,3]'
----------------------------

Synopsis
--------

`prolog_flag(?FLAGNAME, ?VALUE)'

   FLAGNAME is a flag, which currently is set to VALUE.

   `prolog_flag(+FLAGNAME, -OLDVALUE, +NEWVALUE)'

   Unifies the current value of FLAGNAME with OLDVALUE and then sets
the value of the flag to NEWVALUE.  The available Prolog flags are
listed in *Note ref-lps-flg::.

Arguments
---------

FLAGNAME
     "atom", must be nonvar in `prolog_flag/3'

VALUE
     "term"

OLDVALUE
     "term"

NEWVALUE
     "term", must be nonvar and belong to proper type/domain

Description
-----------

To inspect the value of a flag without changing it, use `prolog_flag/2'
or the following idiom, where FLAGNAME is bound to one of the valid
flags above.
      | ?- prolog_flag(FlagName, Value, Value).

   Use `prolog_flag/2' to query and `prolog_flag/3' to set values.

   `prolog_flag/3' can be used to save flag values so that one can
return a flag to its previous state.  For example:
     ...
     prolog_flag(debugging,Old,on), % Save in Old and set
     ...
     prolog_flag(debugging,_,Old),  % Restore from Old
     ...

Backtracking
------------

`prolog_flag/2' enumerates all valid flagnames of a given current
value, or all pairs of flags and their current values.

Exceptions
----------

`instantiation_error'
     In `prolog_flag/3', FLAGNAME unbound, _or_ NEWVALUE unbound and
     not identical to OLDVALUE.

`type_error'
     FLAGNAME is not an atom.

`domain_error'
     In `prolog_flag/3', FLAGNAME bound to an atom that does not
     represent a supported flag, _or_ NEWVALUE bound to a term that
     does not represent a valid value for FLAGNAME.

`permission_error'
     In `prolog_flag/3', NEWVALUE not identical to OLDVALUE for a
     read-only flag.

Examples
--------

See Also
--------

`current_prolog_flag/2', `set_prolog_flag/2', *Note ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-prolog_load_context,  Next: mpg-ref-prompt,  Prev: mpg-ref-prolog_flag,  Up: mpg-bpr

11.3.162 `prolog_load_context/2'
--------------------------------

Synopsis
--------

`prolog_load_context(?KEY, ?VALUE)'

   Finds out the context of the current load.  The available context
keys are described in *Note ref-lps-lco::.

Arguments
---------

KEY
     "atom"

VALUE
     "term"

Description
-----------

You can call `prolog_load_context/2' from an embedded command or from
`term_expansion/6' to find out the context of the current load.  If
called outside the context of a load, it simply fails.

See Also
--------

`load_files/[2,3]', *Note ref-lps-lco::.


File: sicstus.info,  Node: mpg-ref-prompt,  Next: mpg-ref-put_byte,  Prev: mpg-ref-prolog_load_context,  Up: mpg-bpr

11.3.163 `prompt/2'
-------------------

Synopsis
--------

`prompt(-OLDPROMPT, +NEWPROMPT)'

   Queries or changes the prompt string of the current input stream or
an input stream STREAM.

Arguments
---------

OLDPROMPT
     "atom"

     The old prompt atom.

NEWPROMPT
     "atom", must be nonvar

     The new prompt atom.

Description
-----------

A "prompt atom" is a sequence of characters that indicates the Prolog
system is waiting for input when a "Read" or "Get" predicate is called.
If an input stream connected to a terminal is waiting for input at the
beginning of a line (at line position 0), the prompt atom will be
printed through an output stream associated with the same terminal.

   Prolog sets the prompt to `|: ' for every new top-level query. This
is the prompt that can be changed by invoking `prompt/2'.

   Unlike state changes such as those implemented as prolog flags, the
scope of a prompt change is a goal typed at the toplevel.  Therefore,
the change is in force only until returning to the toplevel (prompt =
`| ?- ').

   To _query_ the current prompt atom, OLDPROMPT and NEWPROMPT should
be the same unbound variable.

   To _set_ the prompt, NEWPROMPT should be an instantiated atom.

   The "Load" predicates change the prompt during the time operations
are performed: If a built-in loading predicate is performed on `user'
(such as `compile(user)', etc.), the prompt is set to `| '.  This
prompt is not affected by `prompt/2'.

Exceptions
----------

`instantiation_error'
`type_error'
     NEWPROMPT is not an atom

See Also
--------

*Note ref-iou-tin-cpr::.


File: sicstus.info,  Node: mpg-ref-public,  Next: mpg-ref-spy,  Prev: mpg-ref-nospy,  Up: mpg-bpr

11.3.164 `(public)/1'  "[declaration]"
--------------------------------------

Synopsis
--------

`:- public +TERM'

   Currently a dummy declaration.

Arguments
---------

:TERM
     "term"

See Also
--------

*Note Public Declarations::.


File: sicstus.info,  Node: mpg-ref-put_byte,  Next: mpg-ref-put_char,  Prev: mpg-ref-prompt,  Up: mpg-bpr

11.3.165 `put_byte/[1,2]'  "[ISO]"
----------------------------------

Synopsis
--------

`put_byte(+BYTE)'

   `put_byte(+STREAM, +BYTE)'

   Writes the byte BYTE to STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid output _binary_ stream, defaults to the current output
     stream.

BYTE
     "byte", must be nonvar

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`instantiation_error'
`type_error'
     BYTE is not a "byte".

`permission_error'
     There is an error in the bottom layer of write function of the
     stream.

See Also
--------

*Note ref-iou-cou::.


File: sicstus.info,  Node: mpg-ref-put_char,  Next: mpg-ref-put_code,  Prev: mpg-ref-put_byte,  Up: mpg-bpr

11.3.166 `put_char/[1,2]'  "[ISO]"
----------------------------------

Synopsis
--------

`put_char(+CHAR)'

   `put_char(+STREAM, +CHAR)'

   The "char" CHAR is written to STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid output _text_ stream, defaults to the current output
     stream.

CHAR
     "char", must be nonvar

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`type_error'
     CHAR is not a "char"

`permission_error'
     There is an error in the bottom layer of write function of the
     stream.

See Also
--------

*Note ref-iou-cou::.


File: sicstus.info,  Node: mpg-ref-put_code,  Next: mpg-ref-query_abbreviation,  Prev: mpg-ref-put_char,  Up: mpg-bpr

11.3.167 `put_code/[1,2]'  "[ISO]"
----------------------------------

Synopsis
--------

`put_code(+CODE)'

   `put_code(+STREAM, +CODE)'

   The "code" CODE is written to the stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid output _text_ stream, defaults to the current output
     stream.

CODE
     "code", must be nonvar

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`instantiation_error'
`type_error'
     CODE  is not a "code".

`permission_error'
     There is an error in the bottom layer of write function of the
     stream.

See Also
--------

*Note ref-iou-cou::.


File: sicstus.info,  Node: mpg-ref-query_abbreviation,  Next: mpg-ref-query_class,  Prev: mpg-ref-put_code,  Up: mpg-bpr

11.3.168 `query_abbreviation/3'  "[extendible]"
-----------------------------------------------

Synopsis
--------

`:- multifile 'SU_messages':query_abbreviation/3.'

   `'SU_messages':query_abbreviation(+QUERYCLASS, -PROMPT, -PAIRS)'

   A way to specify one letter abbreviations for responses to queries
from the Prolog System.

Arguments
---------

QUERYCLASS
     "atom"

     The query class being defined.

PROMPT
     "atom"

     The prompt to be used, typically indicating appropriate
     abbreviations.

PAIRS
     "list of pair"

     A list of word-abbreviation pairs, defining the characters accepted
     and the corresponding abstract answers.

Description
-----------

This predicate defines a query class with the given prompt, the `line'
input method, the `char(PAIRS)' map method and `help_query' failure
mode.  The predicate is actually implemented by the first clause of
`'SU_messages':query_class/5':

     query_class(QueryClass, Prompt, line, char(Pairs), help_query) :-
             query_abbreviation(QueryClass, Prompt, Pairs), !.

   Prolog only asks for keyboard input in a few different ways.  These
are enumerated in the clauses for `'SU_messages':query_abbreviation/3'.
These clauses specify valid abbreviations for a given key word.  For
example,

     query_abbreviation(yes_or_no, ' (y or n) ', [yes-[-1,0'y,0'Y], no-"nN"]) :- !.

   a French translator might decide that the letters `O' and `o' are
reasonable abreviations for `oui' (yes), and therefore write

     query_abbreviation(yes_or_no, ' (y or n) ', [yes-[-1,0'o,0'O], no-"nN"]) :- !.

See Also
--------

*Note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_class,  Next: mpg-ref-query_class_hook,  Prev: mpg-ref-query_abbreviation,  Up: mpg-bpr

11.3.169 `query_class/5'  "[extendible]"
----------------------------------------

Synopsis
--------

`:- multifile 'SU_messages':query_class/5.'

   `'SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD,
-MAPMETHOD, -FAILUREMODE)'

   Access the parameters of a given QUERYCLASS.

Arguments
---------

QUERYCLASS
     "term"

     Determines the allowed values for the atom ANSWER.

PROMPT
     "atom"

     The prompt to display at the terminal.

INPUTMETHOD
     "term"

     A ground term, which specifies how to obtain input from the user

MAPMETHOD
     "term"

     A ground term, which specifies how to process the input to get the
     abstract answer to the query.

FAILUREMODE
     "term"

     An atom determining what to print in case of an input error,
     before re-querying the user.  Possible values are:

        - `help_query' - print the help message and print the query text
          again;

        - `help' - only print the help message;

        - `query' - only print the query text;

        - `none' - do not print anything.


Description
-----------

For the list of default input- and map methods, see the "Default Input
Methods" and "Default Map Methods" subsections in *Note Query
Processing::.

See Also
--------

*Note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_class_hook,  Next: mpg-ref-query_hook,  Prev: mpg-ref-query_class,  Up: mpg-bpr

11.3.170 `query_class_hook/5'  "[hook]"
---------------------------------------

Synopsis
--------

`:- multifile user:query_class_hook/5.'

   `user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD,
-MAPMETHOD, -FAILUREMODE)'

   Provides the user with a method of overriding the call to
`'SU_messages':query_class/5' in the preparation phase of query
processing.  This way the default query class characteristics can be
changed.

Arguments
---------

QUERYCLASS
     "term"

     Determines the allowed values for the atom ANSWER.

PROMPT
     "atom"

     The prompt to display at the terminal.

INPUTMETHOD
     "term"

     The input method to use.

MAPMETHOD
     "term"

     The map method to use.

FAILUREMODE
     "term"

     The failure mode to use.

See Also
--------

*Note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_hook,  Next: mpg-ref-query_input,  Prev: mpg-ref-query_class_hook,  Up: mpg-bpr

11.3.171 `query_hook/6'  "[hook]"
---------------------------------

Synopsis
--------

`:- multifile 'SU_messages':query_hook/6.'

   `'SU_messages':query_hook(+QUERYCLASS, +PROMPT, +PROMPTLINES, +HELP,
+HELPLINES, -ANSWER)'

   Provides a method of overriding Prolog's default keyboard based
input requests.

Arguments
---------

QUERYCLASS
     "term"

     Determines the allowed values for the atom ANSWER.

PROMPT
     "term"

     A message term.

PROMPTLINES
     "list of pair"

     The message generated from the PROMPT message term.

HELP
     "term"

     A message term.

HELPLINES
     "list of pair"

     The message generated from the HELP message term.

ANSWER
     "term"

     See QUERYCLASS

Description
-----------

This provides a way of overriding Prolog's default method of
interaction.  If this predicate fails, Prolog's default method of
interaction is invoked.

   The default method first prints out the prompt, then if the response
from the user is not one of the allowed values, the help message is
printed.

   It is useful to compare this predicate to `user:message_hook/3',
since this explains how you might use the PROMPT, PROMPTLINES, HELP,
HELPLINES.

Exceptions
----------

An exception raised by this predicate causes an error message to be
printed and then the default method of interation is invoked.  In other
words, exceptions are treated as failures.

See Also
--------

*Note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_input,  Next: mpg-ref-query_input_hook,  Prev: mpg-ref-query_hook,  Up: mpg-bpr

11.3.172 `query_input/3'  "[extendible]"
----------------------------------------

Synopsis
--------

`:- multifile 'SU_messages':query_input/3.'

   `'SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)'

   Implements the input phase of query processing.  The user is prompted
with PROMPT, input is read according to INPUTMETHOD, and the result is
returned in RAWINPUT.

Arguments
---------

INPUTMETHOD
     "term"

     The input method to use.

PROMPT
     "atom"

     The prompt to display at the terminal.

RAWINPUT
     "term"

See Also
--------

*Note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_input_hook,  Next: mpg-ref-query_map,  Prev: mpg-ref-query_input,  Up: mpg-bpr

11.3.173 `query_input_hook/3'  "[hook]"
---------------------------------------

Synopsis
--------

`:- multifile user:query_input_hook/3.'

   `user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)'

   Provides the user with a method of overriding the call to
`'SU_messages':query_input/3' in the input phase of query processing.
This way the implementation of the default input methods can be changed.

Arguments
---------

INPUTMETHOD
     "term"

     The input method to use.

PROMPT
     "atom"

     The prompt to display at the terminal.

RAWINPUT
     "term"

See Also
--------

*Note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_map,  Next: mpg-ref-query_map_hook,  Prev: mpg-ref-query_input_hook,  Up: mpg-bpr

11.3.174 `query_map/4'  "[extendible]"
--------------------------------------

Synopsis
--------

`:- multifile 'SU_messages':query_map/4.'

   `'SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)'

   Implements the mapping phase of query processing.  The RAWINPUT,
received from `query_input/3', is mapped to the abstract answer term
ANSWER.

Arguments
---------

MAPMETHOD
     "term"

     The map method to use.

RAWINPUT
     "atom"

     As received from `query_input/3'.

RESULT
     "one of `[success,failure,failure(WARNING)]'"

     Result of conversion.

ANSWER
     "one of `[success,failure,failure(WARNING)]'"

     Abstract answer term.

See Also
--------

*Note Query Processing::.


File: sicstus.info,  Node: mpg-ref-query_map_hook,  Next: mpg-ref-raise_exception,  Prev: mpg-ref-query_map,  Up: mpg-bpr

11.3.175 `query_map_hook/4'  "[hook]"
-------------------------------------

Synopsis
--------

`:- multifile user:query_map_hook/4.'

   `user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)'

   Provides the user with a method of overriding the call to
`'SU_messages':query_map/4' in the map phase of query processing.  This
way the implementation of the default map methods can be changed.

Arguments
---------

MAPMETHOD
     "term"

     The map method to use.

RAWINPUT
     "atom"

     As received from `query_input/3'.

RESULT
     "one of `[success,failure,failure(WARNING)]'"

     Result of conversion.

ANSWER
     "one of `[success,failure,failure(WARNING)]'"

     Abstract answer term.

See Also
--------

*Note Query Processing::.


File: sicstus.info,  Node: mpg-ref-raise_exception,  Next: mpg-ref-read,  Prev: mpg-ref-query_map_hook,  Up: mpg-bpr

11.3.176 `raise_exception/1'
----------------------------

Synopsis
--------

`raise_exception(+EXCEPTION)'

   Raise an exception (that might be intercepted by `on_exception/3').

Arguments
---------

EXCEPTION
     "term", must be nonvar

Exceptions
----------

`instantiation_error'
     EXCEPTION is unbound.

See Also
--------

*Note ref-ere::.


File: sicstus.info,  Node: mpg-ref-read,  Next: mpg-ref-read_line,  Prev: mpg-ref-raise_exception,  Up: mpg-bpr

11.3.177 `read/[1,2]'  "[ISO]"
------------------------------

Synopsis
--------

`read(-TERM)'

   `read(+STREAM, -TERM)'

   Reads the next term from STREAM and unifies it with TERM.  Same as:

   `read_term(TERM, [])'

   `read_term(STREAM, TERM, [])'

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog input stream.

TERM
     "term"

     The term to be read.

Description
-----------

Term must be followed by a full-stop.  The full-stop is removed from
the input stream and is not a part of the term that is read.  The term
is read with respect to current operator declarations.

   Does not finish until the full-stop is encountered.  Thus, if you
type at top level
     | ?- read(X)

   you will keep getting prompts (first `|: ', and five spaces
thereafter) every time you type <RET>, but nothing else will happen,
whatever you type, until you type a full-stop.

   If a syntax error is encountered, the action taken depends on the
current value of the `syntax_errors' Prolog flag.  *Note ref-lps-flg::.

   If the end of the current input stream has been reached, then TERM
will be unified with the atom `end_of_file'.  Further calls to
`read/[1,2]' for the same stream will then raise an exception, unless
the stream is connected to the terminal. The characters read are
subject to character-conversion.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`syntax_error'
     A syntax error was found.

Examples
--------

See Also
--------

`read_term/[2,3]', `char_conversion/2', *Note ref-iou-tin-trm::.


File: sicstus.info,  Node: mpg-ref-read_line,  Next: mpg-ref-read_term,  Prev: mpg-ref-read,  Up: mpg-bpr

11.3.178 `read_line/[0,1]'
--------------------------

Synopsis
--------

`read_line(-LINE)'

   `read_line(+STREAM, -LINE)'

   Reads one line of input from STREAM, and unifies the "codes" with
LINE. On end of file, LINE is unified with `end_of_file'.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream, defaults to the current input stream.

LINE
     "list of code" or "one of [`end_of_file']"

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`existence_error'
     Trying to read beyond end of STREAM.

See Also
--------

`at_end_of_line/[0,1]', *Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-read_term,  Next: mpg-ref-reconsult,  Prev: mpg-ref-read_line,  Up: mpg-bpr

11.3.179 `read_term/[2,3]'  "[ISO]"
-----------------------------------

Synopsis
--------

`read_term(-TERM, +OPTIONS)'

   `read_term(+STREAM, -TERM, +OPTIONS)'

   Read a term from STREAM, optionally returning extra information
about the term.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog input stream, defaults to the current input stream.

TERM
     "term"

     The term that is read.

OPTIONS
     "list of term", must be ground, except VARS, NAMES, and LAYOUT as
     described below.

     A list of zero or more of the following:

    `syntax_errors(VAL)'
          Controls what action to take on syntax errors.  VAL must be
          one of the values allowed for the `syntax_errors' Prolog
          flag.  The default is set by that flag. *Note ref-lps-flg::.  

    `variables(VARS)'
          VARS is bound to the list of variables in the term input, in
          left-to-right traversal order.

    `variable_names(NAMES)'
          NAMES is bound to a list of `NAME=VAR' pairs, where each NAME
          is an atom indicating the name of a non-anonymous variable in
          the term, and VAR is the corresponding variable.

    `singletons(NAMES)'
          NAMES is bound to a list of `NAME=VAR' pairs, one for each
          variable appearing only once in the term and whose name does
          not begin with `_'.

    `cycles(BOOLEAN)'
          BOOLEAN must be `true' or `false'.  If selected, any
          occurrences of `@/2' in the term read in are replaced by the
          potentially cyclic terms they denote as described above.
          Otherwise (the default), TERM is just unified with the term
          read in.

    `layout(LAYOUT)'
          LAYOUT is bound to a "layout term" corresponding to TERM
          (*note Glossary::).

    `consume_layout(BOOLEAN)'
          BOOLEAN must be `true' or `false'.  If this option is `true',
          `read_term/[2,3]' will consume the LAYOUT-TEXT-ITEM that
          follows the terminating `.' (this LAYOUT-TEXT-ITEM can either
          be a LAYOUT-CHAR or a COMMENT starting with a `%'). If the
          option is `false', the LAYOUT-TEXT-ITEM will remain in the
          input stream, so that subsequent character input predicates
          will see it. The default of the `consume_layout' option is
          `false'.

Description
-----------

The characters read are subject to character-conversion.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`syntax_error'
     A syntax error was found.

`instantiation_error'

`domain_error'

`domain_error'
     An illegal option was specified.

Examples
--------

     | ?- read_term(T, [variable_names(L)]).
     |: append([U|X],Y,[U|Z]) :- append(X,Y,Z).
     L = ['U'=_A,'X'=_B,'Y'=_C,'Z'=_D],
     T = (append([_A|_B],_C,[_A|_D]):-append(_B,_C,_D))

     | ?- read_term(T, [layout(L), variable_names(Va), singletons(S)]).
     |: [
          foo(X),
          X = Y
          ].

     L = [35,[36,36],[36,[37,37,37],38]],
     S = ['Y'=_A],
     T = [foo(_B),_B=_A],
     Va = ['X'=_B,'Y'=_A]

     | ?- read_term(T, [consume_layout(false)]), get_code(C).
     |: 1.

     C = 10,
     T = 1

     | ?- read_term(T, [consume_layout(true)]), get_code(C).
     |: 1.
     |: a

     C = 97,
     T = 1

See Also
--------

`read/[1,2]', `char_conversion/2', *Note ref-iou-tin-trm::.


File: sicstus.info,  Node: mpg-ref-reconsult,  Next: mpg-ref-recorda,  Prev: mpg-ref-read_term,  Up: mpg-bpr

11.3.180 `reconsult/1'
----------------------

Synopsis
--------

`reconsult(+FILES)'

   same as:

   `consult(FILES)'

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extensions
     optional.

Exceptions
----------

See `load_files/[2,3]'.

See Also
--------

*Note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-recorda,  Next: mpg-ref-recorded,  Prev: mpg-ref-reconsult,  Up: mpg-bpr

11.3.181 `recorda/3'
--------------------

Synopsis
--------

`recorda(+KEY, +TERM, -REF)'

   records the TERM in the internal database as the first item for the
key KEY; a database reference to the newly-recorded term is returned in
REF.

Arguments
---------

KEY
     "atomic", must be nonvar

TERM
     "term"

REF
     "db_reference"

Description
-----------

If KEY is a compound term, only its principal functor is significant.
That is, `foo(1)' represents the same key as `foo(n)'.

   Any uninstantiated variables in the TERM will be replaced by new
private variables, along with copies of any subgoals blocked on these
variables (*note ref-sem-sec::).

Exceptions
----------

`instantiation_error'
     KEY is not instantiated

Examples
--------

See Also
--------

*Note ref-mdb-idb::.


File: sicstus.info,  Node: mpg-ref-recorded,  Next: mpg-ref-recordz,  Prev: mpg-ref-recorda,  Up: mpg-bpr

11.3.182 `recorded/3'
---------------------

Synopsis
--------

`recorded(-KEY, -TERM, +REF)'

   `recorded(?KEY, ?TERM, ?REF)'

   Searches the internal database for a term recorded under the key KEY
that unifies with TERM, and whose database reference unifies with REF.

Arguments
---------

KEY
     "atomic"

TERM
     "term"

REF
     "db_reference"

Description
-----------

If REF is instantiated, then KEY and TERM are unified with the key and
term associated with REF.  Otherwise, If KEY is a compound term, only
its principal functor is significant.  That is, `foo(1)' represents the
same key as `foo(n)'.

Backtracking
------------

Can be used to backtrack through all the matching terms recorded under
the specified key.

Exceptions
----------

`type_error'
     REF is not a database reference

Examples
--------

See Also
--------

*Note ref-mdb-idb::.


File: sicstus.info,  Node: mpg-ref-recordz,  Next: mpg-ref-remove_breakpoints,  Prev: mpg-ref-recorded,  Up: mpg-bpr

11.3.183 `recordz/3'
--------------------

Synopsis
--------

`recordz(+KEY, +TERM, -REF)'

   records the TERM in the internal database as the last item for the
key KEY; a database reference to the newly-recorded term is returned in
REF.

Arguments
---------

KEY
     "atomic", must be nonvar

TERM
     "term"

REF
     "db_reference"

Description
-----------

If KEY is a compound term, only its principal functor is significant.
That is, `foo(1)' represents the same key as `foo(n)'.

   Any uninstantiated variables in the TERM will be replaced by new
private variables, along with copies of any subgoals blocked on these
variables (*note ref-sem-sec::).

Exceptions
----------

`instantiation_error'
     KEY is not instantiated

Examples
--------

See Also
--------

*Note ref-mdb-idb::.


File: sicstus.info,  Node: mpg-ref-remove_breakpoints,  Next: mpg-ref-repeat,  Prev: mpg-ref-recordz,  Up: mpg-bpr

11.3.184 `remove_breakpoints/1'  "[development]"
------------------------------------------------

Synopsis
--------

`remove_breakpoints(+BIDS)'

   Removes the breakpoints specified by BIDS.

Arguments
---------

BIDS
     "list of integer", must be ground

     Breakpoint identifiers.

Exceptions
----------

`instantiation_error'
`type_error'
     in BIDS

See Also
--------

*Note Built-in Predicates for Breakpoint Handling::, *Note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-repeat,  Next: mpg-ref-restore,  Prev: mpg-ref-remove_breakpoints,  Up: mpg-bpr

11.3.185 `repeat/0'  "[ISO]"
----------------------------

Synopsis
--------

`repeat'

   Succeeds immediately when called and whenever reentered by
backtracking.

Description
-----------

Generally used to simulate the looping constructs found in traditional
procedural languages.

   Generates an infinite sequence of backtracking choices.  In sensible
code, `repeat/0' is hardly ever used except in _repeat loops_.  A
repeat loop has the structure

     HEAD :-
             ...
             SAVE_STATE(OldState),
             repeat,
               GENERATE(Datum),
               ACTION(Datum),
               TEST(Datum),
             !,
             RESTORE_STATE(OldState),
             ...

   The purpose is to repeatedly perform some ACTION on elements that
are somehow GENERATEd, e.g. by reading them from a stream, until some
TEST becomes true.  Usually, GENERATE, ACTION, and TEST are all
determinate.  Repeat loops cannot contribute to the logic of the
program.  They are only meaningful if the ACTION involves side-effects.

   The easiest way to understand the effect of `repeat/0' is to think of
failures as "bouncing" back off them causing re-execution of the later
goals.

   Repeat loops are not often needed; usually recursive procedure calls
will lead to code that is easier to understand as well as more
efficient.  There are certain circumstances, however, in which
`repeat/0' will lead to greater efficiency.  An important property of
SICStus Prolog is that all run-time data is stored in stacks so that
any storage that has been allocated during a proof of a goal is
recovered immediately on backtracking through that goal.  Thus, in the
above example, any space allocated by any of the ACTIONS is very
efficiently reclaimed.  When an iterative construct is implemented
using recursion, storage reclamation will only be done by the garbage
collector.

Tips
----

In the most common use of repeat loops, each of the calls succeeds
determinately.  It can be confusing if calls sometimes fail, so that
backtracking starts before the test is reached, or if calls are
nondeterminate, so that backtracking does not always go right back to
`repeat/0'.

   Note that the repeat loop can only be useful if one or more of the
ACTIONS involves a side-effect -- either a change to the data base
(such as an assertion) or an I/O operation.  Otherwise you would do the
same thing each time around the loop (which would never terminate).

Backtracking
------------

Succeeds repeatedly until backtracking is terminated by a cut or an
exception.

See Also
--------

*Note ref-sem::.


File: sicstus.info,  Node: mpg-ref-restore,  Next: mpg-ref-retract,  Prev: mpg-ref-repeat,  Up: mpg-bpr

11.3.186 `restore/1'
--------------------

Synopsis
--------

`restore(+FILESPEC)'

   Restores a saved-state.

Arguments
---------

FILESPEC
     "file_spec", must be ground

     The name of a saved state, `.sav' extension optional.

Description
-----------

The system is returned to the program state previously saved to the
file denoted by FILESPEC with start-up goal GOAL.  `restore/1' may
succeed, fail or raise an exception depending on GOAL.

Exceptions
----------

`instantiation_error'
`type_error'
     In FILESPEC.

`existence_error'
     The specified file does not exist.  If the `fileerrors' Prolog
     flag is `off', the predicate fails instead of raising this
     exception.

`permission_error'
     A specified file is protected.  If the `fileerrors' Prolog flag is
     `off', the predicate fails instead of raising this exception.

See Also
--------

`save_program/[1,2]', *Note ref-sls::, *Note ref-sls-sst::.


File: sicstus.info,  Node: mpg-ref-retract,  Next: mpg-ref-retractall,  Prev: mpg-ref-restore,  Up: mpg-bpr

11.3.187 `retract/1'  "[ISO]"
-----------------------------

Synopsis
--------

`retract(+CLAUSE)'

   Removes the first occurrence of dynamic clause CLAUSE from module M.

Arguments
---------

:CLAUSE
     "callable", must be nonvar

     A valid Prolog clause.

Description
-----------

`retract/1' erases the first clause in the database that matches
CLAUSE.  CLAUSE is retracted in module M if specified.  Otherwise,
CLAUSE is retracted in the source module.

   `retract/1' is nondeterminate.  If control backtracks into the call
to `retract/1', successive clauses matching CLAUSE are erased.  If and
when no clauses match, the call to `retract/1' fails.

   CLAUSE must be of one of the forms:

   * HEAD

   * `HEAD :- BODY'

   * `MODULE:CLAUSE'

   where HEAD is of type callable and the principal functor of HEAD is
the name of a dynamic procedure.  If specified, MODULE must be an atom.

   `retract(HEAD)' means retract the unit-clause HEAD.  The exact same
effect can be achieved by `retract((HEAD :- true))'.

   BODY may be uninstantiated, in which case it will match any body.  In
the case of a unit-clause it will be bound to `true'.  Thus, for
example,

     | ?- retract((foo(X) :- Body)), fail.

   is guaranteed to retract all the clauses for `foo/1', including any
unit-clauses, providing of course that `foo/1' is dynamic.

Backtracking
------------

Can be used to retract all matching clauses through backtracking.

Exceptions
----------

`instantiation_error'
     if HEAD (in CLAUSE) or M is uninstantiated.

`type_error'
     if HEAD is not of type callable, or if M is not an atom, or if
     BODY is not a valid clause body.

`permission_error'
     if the procedure corresponding to HEAD is not static.

See Also
--------

`retractall/1', *Note ref-mdb-rcd::.


File: sicstus.info,  Node: mpg-ref-retractall,  Next: mpg-ref-save_files,  Prev: mpg-ref-retract,  Up: mpg-bpr

11.3.188 `retractall/1'
-----------------------

Synopsis
--------

`retractall(+HEAD)'

   Removes every clause in module M whose head matches HEAD.

Arguments
---------

:HEAD
     "callable", must be nonvar

     Head of a Prolog clause.

Description
-----------

HEAD must be instantiated to a term that looks like a call to a dynamic
procedure.  For example, to retract all the clauses of `foo/3', you
would write
     | ?- retractall(foo(_,_,_)).

   HEAD may be preceded by a M: prefix, in which case the clauses are
retracted from module M instead of the calling module.

   `retractall/1' is useful for erasing all the clauses of a dynamic
procedure without forgetting that it is dynamic; `abolish/1' will not
only erase all the clauses, but will also forget absolutely everything
about the procedure.  `retractall/1' only erases the clauses. This is
important if the procedure is called later on.

   Since `retractall/1' erases _all_ the dynamic clauses whose heads
match HEAD, it has no choices to make, and is determinate.  If there
are no such clauses, it succeeds trivially.  None of the variables in
HEAD will be instantiated by this command.

Exceptions
----------

`instantiation_error'
     if HEAD or MODULE is uninstantiated.

`type_error'
     if HEAD is not of type callable.

`permission_error'
     if the procedure corresponding to HEAD is not static.

See Also
--------

`retract/1', *Note ref-mdb-rcd::.


File: sicstus.info,  Node: mpg-ref-save_files,  Next: mpg-ref-save_modules,  Prev: mpg-ref-retractall,  Up: mpg-bpr

11.3.189 `save_files/2'
-----------------------

Synopsis
--------

`save_files(+SOURCEFILES, +FILE)'

   Any code loaded from SOURCEFILES is saved into FILE in PO format.

Arguments
---------

SOURCEFILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extensions
     optional.

FILE
     "file_spec", must be ground

     A file specification, `.po' extension optional.

Description
-----------

Any module declarations, predicates, multifile clauses, or directives
encountered in SOURCEFILES are saved in object format into the file
denoted by FILE.  Source file information as provided by
`source_file/[1,2]' for the relevant predicates and modules is also
saved.

   FILE can later be loaded by `load_files/[1,2]', at which time any
saved directives will be re-executed.  If any of the SOURCEFILES
declares a module, FILESPEC too will behave as a module-file and export
the predicates listed in the first module declaration encountered in
SOURCEFILES.  *Note ref-sls::.

Exceptions
----------

`instantiation_error'
     SOURCEFILES or FILE is not bound.

`type_error'
     SOURCEFILES or FILE is not a valid file specification.

`permission_error'
     FILE is not writable, or a predicate is built-in, TODO.

See Also
--------

`load_files/[1,2]', *Note ref-sls::, *Note ref-sls-ssl::.


File: sicstus.info,  Node: mpg-ref-save_modules,  Next: mpg-ref-save_predicates,  Prev: mpg-ref-save_files,  Up: mpg-bpr

11.3.190 `save_modules/2'
-------------------------

Synopsis
--------

`save_modules(+MODULES, +FILE)'

   Saves all predicates in MODULES in PO format to FILE.

Arguments
---------

MODULES
     "atom" or "list of atom", must be ground

     An atom representing a current module, or a list of such atoms
     representing a list of modules.

FILE
     "file_spec", must be ground

     A file specification, `.po' extension optional.

Description
-----------

The module declarations, predicates, multifile clauses and
initializations belonging to MODULES are saved in object format into
the file denoted by FILE.  Source file information and embedded
directives (except initializations) are _not_ saved.

   The PO file produced can be loaded using `load_files/[1,2]'.  When
multiple modules are saved into a file, loading that file will import
only the first of those modules into the module in which the load
occurred.

Exceptions
----------

`instantiation_error'
     MODULES or FILE is not bound.

`type_error'
     MODULES is not a valid list of module names, or a single module
     name, or FILE is not a valid file specification.

`permission_error'
     FILE is not writable.

`existence_error'
     A given module is not a current module.

See Also
--------

`load_files/[1,2]', *Note ref-sls::, *Note ref-sls-ssl::.


File: sicstus.info,  Node: mpg-ref-save_predicates,  Next: mpg-ref-save_program,  Prev: mpg-ref-save_modules,  Up: mpg-bpr

11.3.191 `save_predicates/2'
----------------------------

Synopsis
--------

`save_predicates(+PREDSPECS, +FILE)'

   Saves all predicates in PREDSPECS in PO format to FILE.

Arguments
---------

:PREDSPECS
     "pred_spec_tree"

     A list of predicate specifications.

FILE
     "file_spec", must be ground

     A file specification, `.po' extension optional.

Description
-----------

`save_predicates/2' saves the current definitions of all the predicates
specified by the list of predicate specifications in PO format into a
file.  The module of the predicates saved in the PO file is fixed, so
it is not possible to save a predicate from any module `foo', and
reload it into module `bar'.  Source file information and embedded
directives are _not_ saved.  A typical use of this would be to take a
snapshot of a table of dynamic facts.

   The PO file that is written out can be loaded using
`load_files/[1,2]'.

Exceptions
----------

`instantiation_error'
     PREDSPECS or FILE is not bound.

`type_error'
     PREDSPECS is not a valid list of predicate specifications, or FILE
     is not a valid file specification.

`permission_error'
     FILE is not writable, or a predicate is built-in, TODO.

`existence_error'
     A predicate is undefined, TODO.

See Also
--------

`load_files/[1,2]', *Note ref-sls::, *Note ref-sls-ssl::.


File: sicstus.info,  Node: mpg-ref-save_program,  Next: mpg-ref-see,  Prev: mpg-ref-save_predicates,  Up: mpg-bpr

11.3.192 `save_program/[1,2]'
-----------------------------

Synopsis
--------

`save_program(+FILE)'

   `save_program(+FILE, +GOAL)'

   Saves the state of the current execution in object format to FILE. A
goal, GOAL, to be called upon execution/restoring of the saved state,
may be specified.

Arguments
---------

FILE
     "file_spec", must be ground

     A file specification, `.sav' extension optional.

:GOAL
     "callable", must be nonvar

     A goal, defaults to `true'.

Description
-----------

`save_program/[1,2]' creates a binary representation of all predicates
in all modules existing in the system.  However, it does not save the
user's pre-linked code.  It also saves such states of the system as
operator definitions, Prolog flags, debugging and advice state,
initializations, and dependencies on foreign resources.

   The resulting file can be restored using `restore/1'.

Exceptions
----------

`instantiation_error'
     FILE or GOAL is not bound.

`type_error'
     FILE is not a valid file specification, or GOAL is not a callable.

`permission_error'
     FILE is not writable.

See Also
--------

`restore/1', *Note ref-sls::, *Note ref-sls-sst::.


File: sicstus.info,  Node: mpg-ref-see,  Next: mpg-ref-seeing,  Prev: mpg-ref-save_program,  Up: mpg-bpr

11.3.193 `see/1'
----------------

Synopsis
--------

`see(+FILEORSTREAM)' Makes file FILEORSTREAM the current input stream.

Arguments
---------

FILEORSTREAM
     "file_spec" or "stream_object", must be ground

Description
-----------

If there is an open input stream associated with FILEORSTREAM, and that
stream was opened by `see/1', then it is made the current input stream.
Otherwise, the specified file is opened for input in text mode with
default options and made the current input stream.

   Different file names (that is, names that do not unify) represent
different streams (even if they correspond to the same file).
Therefore, assuming `food' and `./food' represent the same file, the
following sequence will open two streams, both connected to the same
file.

     see(food)
     ...
     see('./food')

   It is important to remember to close streams when you have finished
with them.  Use `seen/0' or `close/[1,2]'.

Exceptions
----------

`instantiation_error'
     FILEORSTREAM is not instantiated enough.

`existence_error'
     FILEORSTREAM not currently open for input, and the `fileerrors'
     Prolog flag is `on'.

`domain_error'
     FILEORSTREAM is neither a filename nor a stream.

See Also
--------

`seen/0', `open/[3,4]', `current_input/1', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-seeing,  Next: mpg-ref-seek,  Prev: mpg-ref-see,  Up: mpg-bpr

11.3.194 `seeing/1'
-------------------

Synopsis
--------

`seeing(-FILEORSTREAM)'

   Unifies FILEORSTREAM with the current input stream or file.

Arguments
---------

FILEORSTREAM
     "file_spec" or "stream_object"

Description
-----------

Exactly the same as `current_input(FILEORSTREAM)', except that
FILEORSTREAM will be unified with a filename if the current input
stream was opened by `see/1' (*Note ref-iou-sfh::).

   Can be used to verify that `FileNameOrStream' is still the current
input stream as follows:

     % nonvar(FileNameOrStream),
     see(FileNameOrStream),
     ...
     seeing(FileNameOrStream)

   If the current input stream has not been changed (or if changed, then
restored), the above sequence will succeed for all file names and all
stream objects opened by `open/[3,4]'.  However, it will fail for all
stream objects opened by `see/1' (since only filename access to streams
opened by `see/1' is supported).  This includes the stream object
`user_input' (since the standard input stream is assumed to be opened
by `see/1', and so `seeing/1' would return `user' in this case).

   If FILEORSTREAM is instantiated to a value that is not the
identifier of the current input stream, `seeing(FILEORSTREAM)' simply
fails.

   Can be followed by `see/1' to ensure that a section of code leaves
the current input unchanged:

     % var(OldFileNameOrStream),
     seeing(OldFileNameOrStream),
     ...
     see(OldFileNameOrStream)

   The above is analogous to its stream-object-based counterpart,

     % var(OldStream),
     current_input(OldStream),
     ...
     set_input(OldStream)

   Both of these sequences will always succeed regardless of whether
the current input stream was opened by `see/1' or `open/[3,4]'.

See Also
--------

`see/1', `open/[3,4]', `current_input/1', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-seek,  Next: mpg-ref-seen,  Prev: mpg-ref-seeing,  Up: mpg-bpr

11.3.195 `seek/4'
-----------------

Synopsis
--------

`seek(+STREAM, +OFFSET, +METHOD, -NEWLOCATION)'

   Seeks to an arbitrary position in STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog stream.

OFFSET
     "integer", must be nonvar

     The offset, in _items_, to seek relative to the specified METHOD.
     Items are bytes for binary streams, characters for text streams.

METHOD
     "one of `[bof,current,eof]'", must be nonvar

     Where start seeking, one of the following:

    `bof'
          Seek from beginning of the file stream.

    `current'
          Seek from current position of the file stream.

    `eof'
          Seek from end of the file stream.

NEWLOCATION
     "integer"

     The offset from beginning of the file after seeking operation.

Description
-----------

Sets the current position of the file stream STREAM to a new position
according to OFFSET and METHOD.  If METHOD is:

`bof'
     the new position is set to OFFSET _items_ from beginning of the
     file stream.

`current'
     the new position is OFFSET plus the current position of STREAM.

`eof'
     the new position is OFFSET, plus the current size of the stream.

     Avoid using this METHOD. Determining the size of the stream may be
     expensive or unsupported for some streams.


   Positions and offsets are measured in _items_, bytes for binary
streams and characters for text streams. Note that there may not be any
simple relationship between the number of characters read and the byte
offset of a text file.

   After applying this operation on a text stream, the line counts and
line position aspects of the stream position of STREAM will be
undefined.

   The term "file" above is used even though the stream may be
connected to other seekable objects that are not files, e.g. an
in-memory buffer.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`instantiation_error'
     OFFSET or METHOD is not instantiated.

`type_error'
     STREAM is not a stream object, or OFFSET is not an integer, or
     METHOD is not an atom.

`domain_error'
     METHOD is not one of `bof', `current' or `eof', or the resulting
     position would refer to an unsupported location.  Some streams
     supports setting the position past the current end of the stream,
     in this case the stream is padded with zero bytes or characters as
     soon as an item is written to the new location.

`permission_error'
     Seeking was not possible. Common reasons include: the stream has
     not been opened with `reposition(true)', the stream is a text
     stream that does not implement seeking, or an I/O error happened
     during seek.


See Also
--------

`stream_position/2', `set_stream_position/2', `open/[3,4]',
`byte_count/2', `character_count/2', `line_count/2', `line_position/2',
*Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-seen,  Next: mpg-ref-set_input,  Prev: mpg-ref-seek,  Up: mpg-bpr

11.3.196 `seen/0'
-----------------

Synopsis
--------

`seen'

   Closes the current input stream.

Description
-----------

Current input stream is set to be `user_input'; that is, the user's
terminal.

   Always succeeds

Exceptions
----------

Examples
--------

See Also
--------

`see/1', `close/[1,2]', `current_input/1', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-set_input,  Next: mpg-ref-set_module,  Prev: mpg-ref-seen,  Up: mpg-bpr

11.3.197 `set_input/1'  "[ISO]"
-------------------------------

Synopsis
--------

`set_input(+STREAM)'

   makes STREAM the current input stream.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

`see/1', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-set_module,  Next: mpg-ref-set_output,  Prev: mpg-ref-set_input,  Up: mpg-bpr

11.3.198 `set_module/1'
-----------------------

Synopsis
--------

`set_module(+MODULENAME)'

   Changes the type-in module (*note ref-mod-tyi::) to MODULENAME.
Thus subsequent top-level goals use MODULENAME as their source module.

Arguments
---------

MODULENAME
     "atom", must be nonvar

     The name of a module.

Description
-----------

If MODULENAME is not a current module, a warning message is printed,
but the type-in module is changed nonetheless.

   Calling `set_module/1' from a command embedded in a file that is
being loaded does not affect the loading of clauses from that file.  It
only affects subsequent goals that are typed at top level.

Exceptions
----------

`instantiation_error'

`type_error'

Examples
--------

See Also
--------

*Note ref-mod::, *Note ref-mod-tyi::.


File: sicstus.info,  Node: mpg-ref-set_output,  Next: mpg-ref-set_prolog_flag,  Prev: mpg-ref-set_module,  Up: mpg-bpr

11.3.199 `set_output/1'  "[ISO]"
--------------------------------

Synopsis
--------

`set_output(+STREAM)'

   makes STREAM the current output stream.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid output stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

`tell/1', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-set_prolog_flag,  Next: mpg-ref-set_stream_position,  Prev: mpg-ref-set_output,  Up: mpg-bpr

11.3.200 `set_prolog_flag/2'  "[ISO]"
-------------------------------------

Synopsis
--------

`set_prolog_flag(+FLAGNAME, +VALUE)'

   same as:

   `prolog_flag(FLAGNAME, _, VALUE)'

Arguments
---------

FLAGNAME
     "atom", must be nonvar

VALUE
     "term", must be nonvar and belong to proper type/domain

Exceptions
----------

`instantiation_error'
     An argument is  unbound.

`type_error'
     FLAGNAME is not an atom, or VALUE has the wrong type.

`domain_error'
     FLAGNAME is not a valid flag name, or VALUE is not a valid value
     for it.

`permission_error'
     The flag is read-only.

See Also
--------

`prolog_flag/3'.


File: sicstus.info,  Node: mpg-ref-set_stream_position,  Next: mpg-ref-setof,  Prev: mpg-ref-set_prolog_flag,  Up: mpg-bpr

11.3.201 `set_stream_position/2'  "[ISO]"
-----------------------------------------

Synopsis
--------

`set_stream_position(+STREAM, +POSITION)'

   Sets the current position of STREAM to POSITION.

Arguments
---------

STREAM
     "stream_object", must be ground

     An open stream.

POSITION
     "term"

     Stream position object representing the current position of STREAM.


Description
-----------

`set_stream_position/2' repositions the stream pointer, and also the
other counts, such as byte, character, and line counts and line
position.  It may only be used on streams that have been opened with the
`open/4' option `reposition(true)'.

   *Please note:* A stream position object is represented by a special
Prolog term.  The only safe way of obtaining such an object is via
`stream_position/2' or `stream_property/2'.  You should not try to
construct, change, or rely on the form of this object.  It may change in
subsequent releases.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`instantiation_error'
`domain_error'
     POSITION is not a valid stream position object.

See Also
--------

`stream_position/2', `stream_property/2', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-setof,  Next: mpg-ref-simple,  Prev: mpg-ref-set_stream_position,  Up: mpg-bpr

11.3.202 `setof/3'  "[ISO]"
---------------------------

Synopsis
--------

`setof(+TEMPLATE, +GENERATOR, -SET)'

   Returns the non-empty set SET of all instances of TEMPLATE such that
GENERATOR is provable.

Arguments
---------

TEMPLATE
     "term"

:GENERATOR
     "callable", must be nonvar

     A goal to be proved as if by `call/1'.

SET
     "list of term"

Description
-----------

SET is a non-empty set of terms represented as a list of those terms,
without duplicates,  in the standard order for terms (*note
ref-lte-cte::).  If there are no instances of TEMPLATE such that
GENERATOR is satisfied, then `setof/3' simply fails.

   Obviously, the set to be enumerated should be finite, and should be
enumerable by Prolog in finite time.  It is possible for the provable
instances to contain variables, but in this case SET will only provide
an imperfect representation of what is in reality an infinite set.

   If GENERATOR is instantiated, but contains uninstantiated variables
that do not also appear in TEMPLATE, then `setof/3' can succeed
nondeterminately, generating alternative values for SET corresponding
to different instantiations of the free variables of GENERATOR.  (It is
to allow for such usage that SET is constrained to be non-empty.)

   If GENERATOR is of the form A^B then all the variables in A are
treated as being existentially quantified.

Backtracking
------------

`setof/3' can succeed nondeterminately, generating alternative values
for SET corresponding to different instantiations of the free variables
of GENERATOR.

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

See `findall/3' for examples that illustrate the differences among
`findall/3', `setof/3', and `bagof/3'.

See Also
--------

`findall/3', `bagof/3', `^/2', *Note ref-all::.


File: sicstus.info,  Node: mpg-ref-simple,  Next: mpg-ref-skip_byte,  Prev: mpg-ref-setof,  Up: mpg-bpr

11.3.203 `simple/1'
-------------------

Synopsis
--------

`simple(+TERM)'

   TERM is currently not instantiated to a compound term.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- simple(9).

     yes
     | ?- simple(_X).

     yes
     | ?- simple("a").

     no

See Also
--------

*Note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-skip_byte,  Next: mpg-ref-skip_char,  Prev: mpg-ref-simple,  Up: mpg-bpr

11.3.204 `skip_byte/[1,2]'
--------------------------

Synopsis
--------

`skip_byte(+BYTE)'

   `skip_byte(+STREAM, +BYTE)'

   read up to and including the first occurrence of BYTE on the current
input stream or on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _binary_ stream, defaults to the current input
     stream.

BYTE
     "byte"

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`type_error'
     BYTE is an invalid byte.

`existence_error'
     Attempt to read past end of file, or some operating system
     dependent error occurred in reading.

See Also
--------

*Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-skip_char,  Next: mpg-ref-skip_code,  Prev: mpg-ref-skip_byte,  Up: mpg-bpr

11.3.205 `skip_char/[1,2]'
--------------------------

Synopsis
--------

`skip_char(+CHAR)'

   `skip_char(+STREAM, +CHAR)'

   Read up to and including the first occurrence of CHAR on the current
input stream or on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream.

CHAR
     "char"

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`existence_error'
     Attempt to read past end of file, or some operating system
     dependent error occurred in reading.

See Also
--------

*Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-skip_code,  Next: mpg-ref-skip_line,  Prev: mpg-ref-skip_char,  Up: mpg-bpr

11.3.206 `skip_code/[1,2]'
--------------------------

Synopsis
--------

`skip_code(+CODE)'

   `skip_code(+STREAM, +CODE)'

   read up to and including the first occurrence of CODE on the current
input stream or on the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream, defaults to the current input stream.

CODE
     "code"

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`existence_error'
     Attempt to read past end of file, or some operating system
     dependent error occurred in reading.

See Also
--------

*Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-skip_line,  Next: mpg-ref-sort,  Prev: mpg-ref-skip_code,  Up: mpg-bpr

11.3.207 `skip_line/[0,1]'
--------------------------

Synopsis
--------

`skip_line'

   `skip_line(+STREAM)'

   Skip the remaining input characters on the current line on STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid input _text_ stream, defaults to the current input stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`existence_error'
     Trying to read beyond end of STREAM.

Comments
--------

Coding with `skip_line/[0,1]' and `at_end_of_line/[0,1]' to handle line
input is more portable among different operating systems than checking
end of line by the input character code.

See Also
--------

`at_end_of_line/[0,1]', *Note ref-iou-cin::.


File: sicstus.info,  Node: mpg-ref-sort,  Next: mpg-ref-source_file,  Prev: mpg-ref-skip_line,  Up: mpg-bpr

11.3.208 `sort/2'
-----------------

Synopsis
--------

`sort(+LIST1, -LIST2)'

   Sorts the elements of the list LIST1 into the ascending standard
order, and removes any multiple occurrences of an element.  The
resulting sorted list is unified with the list LIST2.

Arguments
---------

LIST1
     "list of term", must be a proper list

LIST2
     "list of term"

Exceptions
----------

`instatiation_error'
`type_error'
     LIST1 is not a proper list

Examples
--------

     | ?- sort([a,X,1,a(x),a,a(X)], L).
     L = [X,1,a,a(X),a(x)]

(The time taken to do this is at worst order (N log N) where N is the
length of the list.)

See Also
--------

*Note ref-lte-cte-sor::.


File: sicstus.info,  Node: mpg-ref-source_file,  Next: mpg-ref-statistics,  Prev: mpg-ref-sort,  Up: mpg-bpr

11.3.209 `source_file/[1,2]'
----------------------------

Synopsis
--------

`source_file(?ABSFILE)'

   `source_file(?PRED, ?ABSFILE)'

   ABSFILE is the absolute name of a loaded file, and PRED is a
predicate with clauses in that file.

Arguments
---------

:PRED
     "callable"

     Selected predicate specification.

ABSFILE
     "atom"

     Absolute filename.

Description
-----------

Loaded files include compiled, consulted, restored, PO loaded and
pre-linked files.

   If ABSFILE is bound and not the name of a loaded file, or if PRED is
bound and not the name of a a loaded predicate, then
`source_file(ABSFILE)' simply fails.

   To find _any_ predicates defined in a given file, use the form:

     source_file(M:P, File)

See Also
--------

*Note ref-lps-apf::.


File: sicstus.info,  Node: mpg-ref-spy,  Next: mpg-ref-volatile,  Prev: mpg-ref-public,  Up: mpg-bpr

11.3.210 `(spy)/[1,2]'  "[development]"
---------------------------------------

Synopsis
--------

`spy +PREDSPECS'

   Sets plain spypoints on all the predicates represented by PREDSPECS.

   `spy(+PREDSPECS, +CONDITIONS)'

   Sets conditional spypoints on all the predicates represented by
PREDSPECS.

Arguments
---------

:PREDSPECS
     "pred_spec_tree"

     A predicate specification, or a list of such.

:CONDITIONS
     "term", must be ground

     Spypoint conditions.

Description
-----------

Turns debugger on in debug mode, so that it will stop as soon as it
reaches a spypoint.  Turning off the debugger does not remove
spypoints.  Use `nospy/1' or `nospyall/0') to explicitly remove them.

   If you use the predicate specification form NAME but there are no
clauses for NAME (of any arity), then a warning message will be
displayed and no spypoint will be set.
     | ?- spy test.
     * spy user:test - no matching predicate

Exceptions
----------

`instantiation_error'
`type_error'
`domain_error'
     if a PREDSPEC is not a valid procedure specification

See Also
--------

*Note Basic Debug::, *Note Plain Spypoint::, *Note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-statistics,  Next: mpg-ref-stream_code,  Prev: mpg-ref-source_file,  Up: mpg-bpr

11.3.211 `statistics/[0,2]'
---------------------------

Synopsis
--------

`statistics'

   Displays statistics relating to memory usage and execution time.

   `statistics(?KEYWORD, ?LIST)'

   Obtains individual statistics.

Arguments
---------

KEYWORD
     "atom"

     Statistics key.

LIST
     "list of integer"

     List of statistics.

Description
-----------

`statistics/0' displays various statistics relating to memory usage,
runtime and garbage collection, including information about which areas
of memory have overflowed and how much time has been spent expanding
them.  The printing is handled by `print_message/2'.

   Garbage collection statistics are initialized to zero when a Prolog
session starts.  The statistics increase until the session is over.

   `statistics/2' is usually used with KEYWORD instantiated to a
keyword such as `runtime' and LIST unbound.  The predicate then binds
LIST to a list of statistics related to the keyword.  It can be used in
programs that depend on current runtime statistical information for
their control strategy, and in programs that choose to format and write
out their own statistical summaries.

Exceptions
----------

`type_error'
`domain_error'
     Invalid keyword.

Examples
--------

To report information on the runtime of a predicate `p/0', add the
following to your program:
     :- statistics(runtime, [T0|_]),
        p,
        statistics(runtime, [T1|_]),
        T is T1 - T0,
        format('p/0 took ~3d sec.~n', [T]).

See Also
--------

*Note ref-mgc::, *Note ref-msg::.


File: sicstus.info,  Node: mpg-ref-stream_code,  Next: mpg-ref-stream_position,  Prev: mpg-ref-statistics,  Up: mpg-bpr

11.3.212 `stream_code/2'
------------------------

Synopsis
--------

`stream_code(-STREAM, +CSTREAM)'

   `stream_code(+STREAM, -CSTREAM)'

   Converts between Prolog representation, STREAM, and C
representation, CSTREAM, of a stream.

Arguments
---------

STREAM
     "stream_object"

     A valid Prolog stream.

CSTREAM
     "integer"

     Representing an `SP_stream *' pointer.

Description
-----------

At least one argument must be ground.  `stream_code/2' is used when
there are input/output related operations performed on the same stream
in both Prolog code and foreign code.  The CSTREAM value can be used as
the stream argument to any of the SP_* functions taking a stream
argument.

Exceptions
----------

`instantiation_error'
     Both STREAM and CSTREAM unbound.

``type_error''
     STREAM or CSTREAM is not a stream type or CSTREAM is not an
     integer type.

``existence_error''
     STREAM is syntactically valid but does not name an open stream or
     CSTREAM is of integer type but does not name a pointer to a stream.

See Also
--------

*Note Prolog Streams::.


File: sicstus.info,  Node: mpg-ref-stream_position,  Next: mpg-ref-stream_position_data,  Prev: mpg-ref-stream_code,  Up: mpg-bpr

11.3.213 `stream_position/2'
----------------------------

Synopsis
--------

`stream_position(+STREAM, -POSITION)'

   True when POSITION represents the current position of STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     An open stream.

POSITION
     "term"

     Stream position object representing the current position of STREAM.

Description
-----------

Byte, character, and line counts and line position determine the
position of the pointer in the stream.  Such information is found by
using `byte_count/2', `character_count/2', `line_count/2' and
`line_position/2'.  A stream position object packages this information
as a single Prolog terms.  You can retrieve this information from a
stream position object using `stream_position_data/3'.  Do not rely on
the form of this object in any other way.

   Standard term comparison of two stream position objects for the same
stream will work as one expects.  When SP1 and SP2 refer to positions
in the same stream, `SP1 @< SP2' if and only if SP1 is before SP2 in
the stream.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

Examples
--------

See Also
--------

*Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-stream_position_data,  Next: mpg-ref-stream_property,  Prev: mpg-ref-stream_position,  Up: mpg-bpr

11.3.214 `stream_position_data/3'
---------------------------------

Synopsis
--------

stream_position_data(?FIELD, ?POSITION, ?VALUE)

   VALUE is the value of the FIELD field of stream position object
POSITION.

Arguments
---------

FIELD
     "one of `[byte_count,line_count,character_count,line_position]'"

     Note that `byte_count' is meaningful only for binary streams and
     that the other values are meaningful only for text streams.

POSITION
     "term"

     Stream position object representing the current position of STREAM.

VALUE
     "integer"

Backtracking
------------

Can be used to backtrack over the fields.

See Also
--------

*Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-stream_property,  Next: mpg-ref-sub_atom,  Prev: mpg-ref-stream_position_data,  Up: mpg-bpr

11.3.215 `stream_property/2'  "[ISO]"
-------------------------------------

Synopsis
--------

stream_property(?STREAM, ?PROPERTY))

   Stream STREAM has stream property PROPERTY.

Arguments
---------

STREAM
     "stream_object"

PROPERTY
     "term"

     A stream property, one of the following:

    `file_name(F)'
          F is the file name associated with the STREAM.

    `mode(M)'
          STREAM has been opened in mode M.

    `input'
          STREAM is an input stream. Note that both `input' and
          `output' stream properties are set for bidirectional streams.

    `output'
          STREAM is an output stream. Note that both `input' and
          `output' stream properties are set for bidirectional streams.

    `alias(A)'
          STREAM has an alias A.

    `position(P)'
          P is a term representing the current stream position of
          STREAM.  Only guaranteed to be available if the stream has
          been opened with the `open/4' option `reposition(true)'.

          Same as `stream_position(Stream, P)' except that the latter
          can be called on any stream, regardless of the value of the
          `reposition/1' `open/4' option.

    `end_of_stream(E)'
          E describes the position of the input stream STREAM, with
          respect to the end of stream. If not all characters have been
          read, or if peeking ahead to determine this fact would block,
          then E is unified with `not'; otherwise, (all characters
          read) but no end of stream indicator (-1 or `end_of_file')
          was reported yet, then E is unified with `at'; otherwise, E
          is unified with `past'.

    `eof_action(A)'
          A is the end-of-file action applicable to STREAM, cf. the
          `eof_action' option of `open/4'.

    `type(T)'
          STREAM is of type T, one of `text', `binary', cf. the `type'
          option of `open/4'.

    `encoding(CS)'
          STREAM is a text stream with encoding CS, cf. the `encoding'
          option of `open/4'. Note that the encoding used may be
          different from the `encoding' option passed to `open/4' if a
          byte order mark or other information was used to determine
          the real encoding of the file, cf. the `encoding_signature'
          option of `open/4'.

    `eol(EOL)'
          STREAM is a text stream with end of line convention EOL, cf.
          the `eol' option of `open/4'.

    `encoding_signature(ES)'
          If STREAM is a text stream then ES is determined as follows:

          If the file contents was used to determine the character
          encoding then ES will be true.  Typically this is the result
          of opening, in mode `read', a text file that contains a byte
          order mark or some other information that lets `open/[3,4]'
          determine a suitable encoding, cf. the `encoding_signature'
          option of `open/4'.

          Otherwise if the stream is open in direction output then ES
          will be as specified when the file was opened.

    `reposition(REPOSITION)'
          REPOSITION is true if it is possible to set the position of
          the stream with `set_stream_position/2', cf. the `reposition'
          option of `open/4'.


     Most streams have only a subset of these properties set.

     More properties may be added in the future.


Backtracking
------------

Can be used to backtrack over all currently open streams, including the
standard input/output/error streams, and all their properties.  *Note
ref-iou-sfh-bos::.

Exceptions
----------

`domain_error'
     STREAM is not a valid stream object, or PROPERTY is not a valid
     stream property.

See Also
--------

*Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-sub_atom,  Next: mpg-ref-tell,  Prev: mpg-ref-stream_property,  Up: mpg-bpr

11.3.216 `sub_atom/5'  "[ISO]"
------------------------------

Synopsis
--------

`sub_atom(+ATOM,-BEFORE,-LENGTH,-AFTER,-SUBATOM)'

   The characters of SUBATOM form a sublist of the characters of ATOM,
such that the number of characters preceding SUBATOM is BEFORE, the
number of characters after SUBATOM is AFTER, and the length of SUBATOM
is LENGTH.

Arguments
---------

ATOM
     "atom", must be nonvar

     The atom from which a part is selected.

BEFORE
     "integer"

     The number of characters preceding SUBATOM.

LENGTH
     "integer"

     The number of characters of SUBATOM.

AFTER
     "integer"

     The number of characters following SUBATOM.

SUBATOM
     "atom"

     The selected part of ATOM.

Description
-----------

Capable of nondeterminately enumerating all sub-atoms and their all
possible placements, e.g.:

     | ?- sub_atom(abrakadabra, Before, _, After, ab).

     After = 9,
     Before = 0 ? ;

     After = 2,
     Before = 7 ? ;

     no

Exceptions
----------

`instantiation_error'
     ATOM is uninstantiated.

`type_error'
     ATOM is not an atom.  BEFORE, LENGTH, or AFTER, if instantiated,
     is not an integer.  SUBATOM, if instantiated, is not an atom.

`domain_error'
     BEFORE, LENGTH, or AFTER, if instantiated, is negative.


See Also
--------

`atom_length/2', `atom_concat/3'.


File: sicstus.info,  Node: mpg-ref-tell,  Next: mpg-ref-telling,  Prev: mpg-ref-sub_atom,  Up: mpg-bpr

11.3.217 `tell/1'
-----------------

Synopsis
--------

`tell(+FILEORSTREAM)'

   Makes file FILEORSTREAM the current output stream.

Arguments
---------

FILEORSTREAM
     "file_spec" or "stream_object", must be ground

Description
-----------

If there is an open output stream associated with FILEORSTREAM, and
that stream was opened by `tell/1', then it is made the current output
stream.  Otherwise, the specified file is opened for output in text
mode with default options and made the current output stream.

   Different file names (that is, names that do not unify) represent
different streams (even if they correspond to the same file).
Therefore, assuming `food' and `./food' represent the same file, the
following sequence will open two streams, both connected to the same
file.

     tell(food)
     ...
     tell('./food')

   It is important to remember to close streams when you have finished
with them.  Use `told/0' or `close/[1,2]'.

Exceptions
----------

`instantiation_error'
     FILEORSTREAM is not instantiated enough.

`existence_error'
     FILEORSTREAM not currently open for output, and the `fileerrors'
     Prolog flag is `on'.

`domain_error'
     FILEORSTREAM is neither a filename nor a stream.

See Also
--------

`told/0', `open/[3,4]', `current_output/1', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-telling,  Next: mpg-ref-term_expansion,  Prev: mpg-ref-tell,  Up: mpg-bpr

11.3.218 `telling/1'
--------------------

Synopsis
--------

`telling(-FILEORSTREAM)'

   Unifies FILEORSTREAM with the current output stream or file.

Arguments
---------

FILEORSTREAM
     "file_spec" or "stream_object"

Description
-----------

Exactly the same as `current_output(FILEORSTREAM)', except that
FILEORSTREAM will be unified with a filename if the current output
stream was opened by `tell/1' (*Note ref-iou-sfh::).

   Can be used to verify that `FileNameOrStream' is still the current
output stream as follows:

     % nonvar(FileNameOrStream),
     tell(FileNameOrStream),
     ...
     telling(FileNameOrStream)

   If the current output stream has not been changed (or if changed,
then restored), the above sequence will succeed for all file names and
all stream objects opened by `open/[3,4]'.  However, it will fail for
all stream objects opened by `tell/1' (since only filename access to
streams opened by `tell/1' is supported).  This includes the stream
object `user_output' (since the standard output stream is assumed to be
opened by `tell/1', and so `telling/1' would return `user' in this
case).

   If FILEORSTREAM is instantiated to a value that is not the
identifier of the current output stream, `telling(FILEORSTREAM)' simply
fails.

   Can be followed by `tell/1' to ensure that a section of code leaves
the current output unchanged:

     % var(OldFileNameOrStream),
     telling(OldFileNameOrStream),
     ...
     tell(OldFileNameOrStream)

   The above is analogous to its stream-object-based counterpart,

     % var(OldStream),
     current_output(OldStream),
     ...
     set_output(OldStream)

   Both of these sequences will always succeed regardless of whether
the current output stream was opened by `tell/1' or `open/[3,4]'.

See Also
--------

`tell/1', `open/[3,4]', `current_input/1', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-term_equal_to,  Next: mpg-ref-not_equal_to,  Prev: mpg-ref-not_greater_than,  Up: mpg-bpr

11.3.219 `== /2'  "[ISO]"
-------------------------

Synopsis
--------

+TERM1 `==' +TERM2

   Succeeds if TERM1 and TERM2 are _identical terms_.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

Examples
--------

For example, the query

     | ?- X == Y.

fails (answers `no') because X and Y are distinct uninstantiated
variables.  However, the query

     | ?- X = Y, X == Y.

succeeds because the first goal unifies the two. variables

See Also
--------

*Note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_expansion,  Next: mpg-ref-throw,  Prev: mpg-ref-telling,  Up: mpg-bpr

11.3.220 `term_expansion/6'  "[hook]"
-------------------------------------

Synopsis
--------

`:- multifile user:term_expansion/6.'

   `user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2,
-TOKENS2)'

   Overrides or complements the standard transformations to be done by
`expand_term/2'.

Arguments
---------

TERM1
     "term"

     Term to transform.

LAYOUT1
     "term"

     Layout term of TERM1.

TOKENS1
     "list of atom"

TERM2
     "term"

     Transformed term.

LAYOUT2
     "term"

     Layout term of TERM2.

TOKENS2
     "list of atom"

Description
-----------

`expand_term/2' calls this hook predicate first; if it succeeds, the
standard grammar rule expansion is not tried.

   TOKENS1 is a list of atoms, each atom uniquely identifying an
expansion.  It is used to look up what expansions have already been
applied to the clause or goal. The tokens are defined by the user, and
should simply be added to the input list, before expansions recursively
are applied. This token list can for instance be used to avoid cyclic
expansions. The token `dcg' is reserved and denotes grammar rule
expansion. TOKENS2 should be unified with [TOKEN|TOKENS1].

   LAYOUT1 and LAYOUT2 are for supporting source-linked debugging in
the context of clause expansion.  The predicate should construct a
suitable LAYOUT2 compatible with TERM2 that contains the line number
information from LAYOUT1. If source-linked debugging of TERM2 is not
important, LAYOUT2 should be `[]'.

   A clause of this predicate should conform to the following template,
where CONVERT(TERM1,TERM2,LAYOUT1,LAYOUT2) should be a goal that
performs the actual transformation.  TOKEN should be the atom uniquely
identifying this particular transformation rule. TOKENS2 should be
unified with [TOKEN|TOKENS1].

     user:term_expansion(Term1, Lay1, Tokens1, Term2, Lay2, [TOKEN|Tokens1]) :-
     	nonmember(TOKEN, Tokens1),
     	CONVERT(TERM1, LAY1, TERM2, LAY2), !.

   This hook predicate may return a list of terms rather than a single
term.  Each of the terms in the list is then treated as a separate
clause.

   This hook predicate may also be used to transform queries entered at
the terminal in response to the `| ?- ' prompt.  In this case, it will
be called with TERM1 = `?-(QUERY)' and should succeed with TERM2 =
`?-(EXPANDEDQUERY)'.

   For accessing aspects of the load context, e.g. the name of the file
being compiled, the predicate `prolog_load_context/2' (*note
ref-lps-lco::) can be used.

Exceptions
----------

Exceptions are treated as failures, except an error message is printed
also.

See Also
--------

*Note ref-lod-exp::.


File: sicstus.info,  Node: mpg-ref-term_greater_than,  Next: mpg-ref-term_not_less_than,  Prev: mpg-ref-term_not_greater_than,  Up: mpg-bpr

11.3.221 `@> /2'  "[ISO]"
-------------------------

Synopsis
--------

+TERM1 `@>' +TERM2

   Succeeds if TERM1 is _after_ TERM2 in the standard order.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

See Also
--------

*Note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_less_than,  Next: mpg-ref-term_not_greater_than,  Prev: mpg-ref-term_unify_decided,  Up: mpg-bpr

11.3.222 `@< /2'  "[ISO]"
-------------------------

Synopsis
--------

+TERM1 `@<' +TERM2

   Succeeds if TERM1 is _before_ TERM2 in the standard order.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

See Also
--------

*Note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_not_equal_to,  Next: mpg-ref-exists,  Prev: mpg-ref-not_unifiable,  Up: mpg-bpr

11.3.223 `\== /2'  "[ISO]"
--------------------------

Synopsis
--------

+TERM1 `\==' +TERM2

   Succeeds if TERM1 and TERM2 are _non-identical terms_.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

See Also
--------

*Note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_not_greater_than,  Next: mpg-ref-term_greater_than,  Prev: mpg-ref-term_less_than,  Up: mpg-bpr

11.3.224 `@=< /2'  "[ISO]"
--------------------------

Synopsis
--------

+TERM1 `@=<' +TERM2

   Succeeds if TERM1 is _not after_ TERM2 in the standard order.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

See Also
--------

*Note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_not_less_than,  Next: mpg-ref-not_unifiable,  Prev: mpg-ref-term_greater_than,  Up: mpg-bpr

11.3.225 `@>= /2'  "[ISO]"
--------------------------

Synopsis
--------

+TERM1 `@>=' +TERM2

   Succeeds if TERM1 is _not before_ TERM2 in the standard order.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

See Also
--------

*Note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-term_unify_decided,  Next: mpg-ref-term_less_than,  Prev: mpg-ref-not_less_than,  Up: mpg-bpr

11.3.226 `?= /2'
----------------

Synopsis
--------

`?=(+TERM1,+TERM2)'

   Succeeds if TERM1 and TERM2 are _identical terms_, or if they are
syntactically non-unifiable.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

Comments
--------

Succeeds if and only if `dif(TERM1,TERM2)' does not block.

See Also
--------

*Note ref-lte-met-usu::.


File: sicstus.info,  Node: mpg-ref-throw,  Next: mpg-ref-told,  Prev: mpg-ref-term_expansion,  Up: mpg-bpr

11.3.227 `throw/1'  "[ISO]"
---------------------------

Synopsis
--------

`throw(+EXCEPTION)'

   same as

   `raise_exception(EXCEPTION)'

Arguments
---------

EXCEPTION
     "term", must be nonvar

Exceptions
----------

`instantiation_error'
     EXCEPTION is unbound.

See Also
--------

*Note ref-ere::.


File: sicstus.info,  Node: mpg-ref-told,  Next: mpg-ref-trace,  Prev: mpg-ref-throw,  Up: mpg-bpr

11.3.228 `told/0'
-----------------

Synopsis
--------

`told'

   Closes the current output stream.

Description
-----------

Current output stream is set to be `user_output'; that is, the user's
terminal.

   Always succeeds

Exceptions
----------

Examples
--------

See Also
--------

`tell/1', `close/[1,2]', `current_output/1', *Note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-trace,  Next: mpg-ref-trimcore,  Prev: mpg-ref-told,  Up: mpg-bpr

11.3.229 `trace/0'  "[development]"
-----------------------------------

Synopsis
--------

`trace'

   Turns on the debugger in trace mode.

Description
-----------

The debugger will start showing goals as soon as the first call is
reached, and it will stop to allow you to interact as soon as it
reaches a leashed port (see `leash/1').  Setting the debugger to trace
mode means that every time you type a query, the debugger will start by
creeping.

   The effect of this predicate can also be achieved by typing the
letter `t' after a `^C' interrupt (*note Execution::).

See Also
--------

*Note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-trimcore,  Next: mpg-ref-true,  Prev: mpg-ref-trace,  Up: mpg-bpr

11.3.230 `trimcore/0'
---------------------

Synopsis
--------

`trimcore'

   Force reclamation of memory in all of Prolog's data areas.

Description
-----------

Trims the stacks, reclaims any dead clauses and predicates,
defragmentizes Prolog's free memory, and attempts to return any unused
memory to the operating system.  It is called automatically at every
top-level query, except the stacks are not trimmed then.

See Also
--------

*Note ref-mgc::.


File: sicstus.info,  Node: mpg-ref-true,  Next: mpg-ref-unify_with_occurs_check,  Prev: mpg-ref-trimcore,  Up: mpg-bpr

11.3.231 `true/0'  "[ISO]"
--------------------------

Synopsis
--------

`true'

   Always succeeds.

See Also
--------

*Note ref-sem::.


File: sicstus.info,  Node: mpg-ref-unify,  Next: mpg-ref-univ,  Prev: mpg-ref-less_than,  Up: mpg-bpr

11.3.232 `= /2'  "[ISO]"
------------------------

Synopsis
--------

+TERM1 `=' +TERM2

   _unifies_ TERM1 and TERM2.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

Description
-----------

This is defined as if by the clause `Z = Z.'.

   If `=/2' is not able to unify TERM1 and TERM2, it will simply fail.

See Also
--------

*Note Glossary::, *Note ref-sem-occ::.


File: sicstus.info,  Node: mpg-ref-unify_with_occurs_check,  Next: mpg-ref-unknown,  Prev: mpg-ref-true,  Up: mpg-bpr

11.3.233 `unify_with_occurs_check/2'  "[ISO]"
---------------------------------------------

Synopsis
--------

`unify_with_occurs_check(+TERM1, +TERM2)'

   TERM1 and TERM2 unify to a finite (acyclic) term.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

Description
-----------

Runs in almost linear time.

See Also
--------

*Note Glossary::.


File: sicstus.info,  Node: mpg-ref-univ,  Next: mpg-ref-equal_to,  Prev: mpg-ref-unify,  Up: mpg-bpr

11.3.234 `=.. /2'  "[ISO]"
--------------------------

Synopsis
--------

+TERM `=..' -LIST

   -TERM `=..' +LIST

   Unifies LIST with a list whose head is the atom corresponding to the
principal functor of TERM and whose tail is a list of the arguments of
TERM.

Arguments
---------

TERM
     "term" any term

LIST
     "list of term" and not empty

Description
-----------

If TERM is uninstantiated, then LIST must be instantiated either to a
proper list whose head is an atom, or to a list of length 1 whose head
is a number.

   This predicate is not strictly necessary, since its functionality can
be provided by `arg/3' and `functor/3', and using the latter two is
usually more efficient.

Examples
--------

     | ?- product(0, n, n-1) =.. L.

     L = [product,0,n,n-1]

     | ?- n-1 =.. L.

     L = [-,n,1]

     | ?- product =.. L.

     L = [product]

Exceptions
----------

`instantiation_error'
     TERM is instantiated and LIST has an uninstantiated tail.

`type_error'
     LIST is not a proper list, or the head of LIST is not atomic, or
     the head of LIST is a number and the tail of LIST is not empty.

`domain_error'
     LIST is the empty list.

`representation_error'
     TERM is uninstantiated and LIST is longer than 256.

See Also
--------

`functor/3', `arg/3', *Note ref-lte-act::.


File: sicstus.info,  Node: mpg-ref-unknown,  Next: mpg-ref-unknown_predicate_handler,  Prev: mpg-ref-unify_with_occurs_check,  Up: mpg-bpr

11.3.235 `unknown/2'  "[development]"
-------------------------------------

Synopsis
--------

`unknown(-OLDACTION, +NEWACTION)'

   Unifies OLDACTION with the current action on unknown procedures, and
then sets the current action to NEWACTION.

Arguments
---------

OLDACTION
     "one of `[error,fail,trace,warning]'"

NEWACTION
     "one of `[error,fail,trace,warning]'", must be nonvar

Description
-----------

This action determines what happens when an undefined predicate is
called, and `user:unknown_predicate_handler/3' does not handle the
goal, by accessing the `unknown' Prolog flag:

`trace'
     Causes calls to undefined predicates to be reported and the
     debugger to be entered at the earliest opportunity.

`fail'
     Causes calls to such predicates to fail.

`warning'
     Causes calls to such predicates to display a warning message and
     then fail.

`error'
     Causes calls to such predicates to raise an exception (the
     default).  *Note ref-ere::.
   
   Note that:

     | ?- unknown(ACTION, ACTION).

just returns ACTION without changing it.

   Procedures that are known to be dynamic just fail when there are no
clauses for them.

Exceptions
----------

`instantiation_error'
`type_error'
`domain_error'
     Invalid NEWACTION.

See Also
--------

*Note Undefined Predicates::, *Note ref-ere::.


File: sicstus.info,  Node: mpg-ref-unknown_predicate_handler,  Next: mpg-ref-update_mutable,  Prev: mpg-ref-unknown,  Up: mpg-bpr

11.3.236 `unknown_predicate_handler/3'  "[hook]"
------------------------------------------------

Synopsis
--------

`:- multifile user:unknown_predicate_handler/3.'

   `user:unknown_predicate_handler(+GOAL, +MODULE, -NEWGOAL)'

   User definable hook to trap calls to unknown predicates.

Arguments
---------

GOAL
     "callable"

     The goal to trap.

MODULE
     "atom"

     Any atom that is a current module

NEWGOAL
     "callable"

     The goal to call instead.

Description
-----------

When Prolog comes across a call to an unknown predicate, Prolog makes a
call to `user:unknown_predicate_handler/3' with the first two arguments
bound. GOAL is bound to the call to the undefined predicate and MODULE
is the module in which that predicate is supposed to be defined. If the
call to `user:unknown_predicate_handler/3' succeeds, then Prolog
replaces the call to the undefined predicate with the call to
MODULE:NEWGOAL. Otherwise, the action taken is governed by the
`unknown' Prolog flag. *Note ref-lps-flg::.  

Exceptions
----------

Exceptions are treated as failures, except an error message is printed.

Examples
--------

The following clause gives the same behaviour as setting
`unknown(_,fail)':

     unknown_predicate_handler(_, _, fail).

   The following clause causes calls to undefined predicates whose names
begin with `xyz_' in module `m' to be trapped to `my_handler/1' in
module `n'.  Predicates with names not beginning with this character
sequence are not affected.

     unknown_predicate_handler(G, m, n:my_handler(G)) :-
         functor(G,N,_),
         atom_concat(xyz_, _, N).

See Also
--------

*Note Undefined Predicates::, *Note ref-ere::.


File: sicstus.info,  Node: mpg-ref-update_mutable,  Next: mpg-ref-use_module,  Prev: mpg-ref-unknown_predicate_handler,  Up: mpg-bpr

11.3.237 `update_mutable/2'
---------------------------

Synopsis
--------

`update_mutable(+DATUM, +MUTABLE)'

   Updates the current value of the mutable term MUTABLE to become
DATUM.

Arguments
---------

DATUM
     "term", must be nonvar

MUTABLE
     "mutable", must be nonvar

Exceptions
----------

`instantiation_error'
     DATUM or MUTABLE is uninstantiated.

`type_error'
     MUTABLE is not a mutable.


See Also
--------

*Note ref-lte-mut::.


File: sicstus.info,  Node: mpg-ref-use_module,  Next: mpg-ref-var,  Prev: mpg-ref-update_mutable,  Up: mpg-bpr

11.3.238 `use_module/[1,2,3]'
-----------------------------

Synopsis
--------

`use_module(+FILE)'

   Loads the module-file(s) FILE, if not already loaded and up-to-date
imports all exported predicates.

   `use_module(+FILE, +IMPORTS)'

   Loads module-file FILE, if not already loaded and up-to-date imports
according to IMPORTS.

   `use_module(+MODULE, -FILE, +IMPORTS)'

   MODULE is already loaded and up-to-date. Imports according to
IMPORTS.

   `use_module(-MODULE, +FILE, +IMPORTS)'

   MODULE has not been loaded, or is out-of-date. Loads MODULE from
FILE and imports according to IMPORTS.

Arguments
---------

:FILE
     "file_spec" or "list of file_spec", must be ground Any legal file
     specification.  Only `use_module/1' accepts a list of file
     specifications, file extensions optional.

IMPORTS
     "list of simple_pred_spec" or "one of `[all]'", must be ground
     Either a list of predicate specifications in the NAME/ARITY form
     to import into the calling module, or the atom `all', meaning all
     predicates exported by the module are to be imported.

MODULE
     "atom" The module name in FILE, or a variable, in which case the
     module name is returned.

Description
-----------

Loads each specified file except the previously loaded files that have
not been changed since last loaded.  All files should be module-files,
although this is not currently enforced.  All the exported predicates
of the modules are imported into the calling module (or module M if
specified).

   `use_module/2' imports only the predicates in IMPORTS when loading
FILE.

   `use_module/3' allows MODULE to be imported into another module
without requiring that its source file (FILE) be known, as long as the
MODULE already exists in the system.

   Generally, `use_module/3' is similar to `use_module/[1,2]', except
that if MODULE is already in the system, MODULE, or predicates from
MODULE, are simply imported into the calling module, and FILE is not
loaded again.  If MODULE does not already exist in the system, FILE is
loaded, and `use_module/3' behaves like `use_module/2', except that
MODULE is unified, after the file has been loaded, with the actual name
of the module in FILE.  If MODULE is a variable, FILE must exist, and
the module name in FILE is returned.

   Special case of `load_files/2' and is defined as
     use_module(File) :-
         load_files(File, [if(changed)]).

     use_module(File, Imports) :-
         load_files(File, [if(changed),imports(Imports)]).

   `use_module/1' is similar to `ensure_loaded/1' except that all files
must be module-files.

   An attempt to import a predicate may fail or require intervention by
the user because a predicate with the same name and arity has already
been defined in, or imported into, the loading module (or module M if
specified).  Details of what happens in the event of such a "name
clash" are given in *Note ref-mod-bas::.

   After loading the module-file, the source module will attempt to
import all the predicates in IMPORTS.  IMPORTS must be a list of
predicate specifications in NAME/ARITY form.  If any of the predicates
in IMPORTS are not public predicates, an error message is printed, but
the predicates are imported nonetheless.  This lack of strictness is
for convenience; if you forget to declare a predicate to be public, you
can supply the necessary declaration and reload its module, without
having to reload the module that has imported the predicate.

   While `use_module/1' may be more convenient at the top level,
`use_module/2' is recommended in files because it helps document the
interface between modules by making the list of imported predicates
explicit.

   For consistency, `use_module/2' has also been extended so that the
IMPORTS may be specified as the term `all', in which case it behaves
the same as `use_module/1', importing the entire module into the caller.

Exceptions
----------

`instantiation_error'
     FILE or IMPORTS is not ground.

`type_error'
     In FILE or IMPORTS.

`existence_error'
     A specified file does not exist.  If the `fileerrors' flag is
     `off', the predicate fails instead of raising this exception.

`permission_error'
     A specified file is protected.  If the `fileerrors' flag is `off',
     the predicate fails instead of raising this exception.

Examples
--------

See Also
--------

*Note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-var,  Next: mpg-ref-when,  Prev: mpg-ref-use_module,  Up: mpg-bpr

11.3.239 `var/1'  "[ISO]"
-------------------------

Synopsis
--------

`var(+TERM)'

   TERM is currently uninstantiated.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- var(foo(X,Y)).

     no
     | ?- var([X,Y]).

     no
     | ?- var(X).

     true ;

     no
     | ?- Term = foo(X,Y), var(Term).

     no

See Also
--------

*Note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-volatile,  Next: mpg-ref-and,  Prev: mpg-ref-spy,  Up: mpg-bpr

11.3.240 `(volatile)/1'  "[declaration]"
----------------------------------------

Synopsis
--------

`:- volatile +PREDSPECS'

   Declares PREDSPECS to be volatile.  Volatile predicates are not
saved by the `save_*' predicates.

Arguments
---------

:PREDSPECS
     "pred_spec_forest", must be ground

     A predicate specification, or a list of such, or a sequence of
     such separated by commas.

Exceptions
----------

`type_error'

`context_error'
     "declaration appeared in query"

See Also
--------

*Note Volatile Declarations::.


File: sicstus.info,  Node: mpg-ref-when,  Next: mpg-ref-write,  Prev: mpg-ref-var,  Up: mpg-bpr

11.3.241 `when/2'
-----------------

Synopsis
--------

`when(+CONDITION,+GOAL)'

   Blocks GOAL until the CONDITION is true.

Arguments
---------

CONDITION
     "callable", must be nonvar and one of:
    `nonvar(X)'
          False until X is nonvar.

    `ground(X)'
          False until X is ground.

    `?=(X,Y)'
          False while `dif(X,Y)' would block.

    `CONDITION,CONDITION'
          True if both conditions are true.

    `CONDITION;CONDITION'
          True if at least one condition is true.

:GOAL
     "callable", must be nonvar

Backtracking
------------

Depends on GOAL.

Examples
--------

     | ?- when(((nonvar(X);?=(X,Y)),ground(T)), process(X,Y,T)).

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*Note ref-sem-sec::.


File: sicstus.info,  Node: mpg-ref-write,  Next: mpg-ref-write_canonical,  Prev: mpg-ref-when,  Up: mpg-bpr

11.3.242 `write/[1,2]'  "[ISO]"
-------------------------------

Synopsis
--------

`write(+STREAM, +TERM)'

   `write(+TERM)'

   Writes TERM on the standard output stream, without quoting atoms.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

`write(Term)' is equivalent to:

     write_term(Term, [numbervars(true)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*Note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-write_canonical,  Next: mpg-ref-write_term,  Prev: mpg-ref-write,  Up: mpg-bpr

11.3.243 `write_canonical/[1,2]'  "[ISO]"
-----------------------------------------

Synopsis
--------

`write_canonical(+STREAM, +TERM)'

   `write_canonical(+TERM)'

   Writes TERM on the standard output stream, quoting atoms, without
operator notation, without treating `'$VAR'/1' terms specially.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

This predicate is provided so that TERM, if written to a file, can be
read back by `read/[1,2]' regardless of special characters in TERM or
prevailing operator declarations.

   `write_canonical(Term)' is equivalent to:

     write_term(Term, [quoted(true),ignore_ops(true),quoted_charset(portable)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

Examples
--------

To contrast `write/[1,2]' and `write_canonical/[1,2]':
     | ?- write({'A' + '$VAR'(0) + [a]}).

     {A+A+[a]}

     | ?- write_canonical({'A' + '$VAR'(0) + [a]}).

     {}(+(+('A','$VAR'(0)),.(a,[])))

See Also
--------

*Note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-write_term,  Next: mpg-ref-writeq,  Prev: mpg-ref-write_canonical,  Up: mpg-bpr

11.3.244 `write_term/[2,3]'  "[ISO,hookable]"
---------------------------------------------

Synopsis
--------

`write_term(+STREAM, +TERM, +OPTIONS)'

   `write_term(+TERM, +OPTIONS)'

   Writes TERM on the standard output stream, subject to +OPTIONS.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

OPTIONS
     "list of term", must be ground

     A list of zero or more of the following, where BOOLEAN must be
     `true' or `false' (`false' is the default).

    `quoted(BOOLEAN)'
          If selected, atoms and functors are quoted where necessary to
          make the result acceptable as input to `read/1'.
          `write_canonical/1', `writeq/1', and `portray_clause/1'
          select this.

          Any output produced by `write_term/2' with the option
          `quoted(true)' will be in Normal Form C, as defined by
          Unicode. *Note ref-syn-syn-tok:: for further details.

    `ignore_ops(BOOLEAN)'
          If selected, TERM is written in standard parenthesized
          notation instead of using operators.  `write_canonical/1' and
          `display/1' select this.

    `portrayed(BOOLEAN)'
          If selected, `user:portray/1' is called for each non-variable
          subterm.  `print/1' selects this.

    `numbervars(BOOLEAN)'
          If selected, terms of the form `'$VAR'(N)' where N is an
          integer >= 0, an atom, or a code-list, are treated specially
          (see `numbervars/3').  `print/1', `write/1', `writeq/1', and
          `portray_clause/1' select this.

    `cycles(BOOLEAN)'
          If selected, the potentially cyclic term is printed in finite
          `@/2' notation, as discussed above.

    `indented(BOOLEAN)'
          If selected, the term is printed with the same indentation as
          is used by `portray_clause/1' and `listing/[0,1]'.

    `max_depth(DEPTH)'
          Depth limit on printing.  DEPTH is an integer.  0 (the
          default) means no limit.

    `quoted_charset(CHARSET)'
          Only relevant if `quoted(true)' holds.  CHARSET should be a
          legal value of the `quoted_charset' Prolog flag, where it
          takes its default value from. `write_canonical/1' selects the
          value `portable'. *Note ref-lps-flg::.

    `float_format(SPEC)'
          How to print floats.  SPEC should be an atom of the form
          `~NC', like one of the `format/[2,3]' character sequences for
          printing floats.  The default is `~H'.

    `priority(PRIO)'
          The term is printed as if in the context of an associative
          operator of precedence PRIO, where PRIO is an integer.  The
          default is 1200.  *Note ref-syn-ops::.

Description
-----------

This predicate subsumes the predicates that output terms except
`portray_clause/[1,2]', which additionally prints a period and a
newline, and removes module prefixes that are redundant wrt. the
current type-in module.

   During debugging, goals are written out by this predicate with
options given by the `debugger_print_options' Prolog flag.

   Top-level variable bindings are written out by this predicate with
options given by the `toplevel_print_options' Prolog flag.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

`instantiation_error'
`type_error'
`domain_error'
     in OPTIONS.

Examples
--------

How certain options affect the output of `write_term/2':
     | ?- write_term('a b', [quoted(true)]).
     'a b'

     | ?- write_term(a+b, [ignore_ops(true)]).
     +(a,b)

     | ?- write_term(f('$VAR'(2)),
                        [numbervars(true)].)
     f(C)

     | ?- write_term(f('$VAR'('C')),
                        [numbervars(true)]).

     f(C)

   If your intention is to name variables such as that generated by
`read_term/2' with the variable_names option then this can be done by
defining a predicate like:
     var_to_names([]) :- !.
     var_to_names([=(Name,Var)|RestofPairs]) :-
          ( var(Var) ->
               Var = '$VAR'(Name)
          ; true
          ),
          var_to_names(RestofPairs).

     | ?- read_term([variable_names(Names)], X),
          var_to_names(Names),
          write_term(X, [numbervars(true)]),
          nl,
          fail.
     |: a(X, Y).
     a(X, Y).

     no

See Also
--------

*Note ref-iou-tou::, `user:portray/1'.


File: sicstus.info,  Node: mpg-ref-writeq,  Next: mpg-ref-zip,  Prev: mpg-ref-write_term,  Up: mpg-bpr

11.3.245 `writeq/[1,2]'  "[ISO]"
--------------------------------

Synopsis
--------

`writeq(+STREAM, +TERM)'

   `writeq(+TERM)'

   Writes TERM on the standard output stream, quoting atoms.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

`writeq(Term)' is equivalent to:

     write_term(Term, [quoted(true),numbervars(true)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*Note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-zip,  Prev: mpg-ref-writeq,  Up: mpg-bpr

11.3.246 `zip/0'  "[development]"
---------------------------------

Synopsis
--------

`zip'

   Turns on the debugger in zip mode.

Description
-----------

`zip/0' turns the debugger on and sets it to zip mode.  Turning the
debugger on in zip mode means that it will stop at the next spypoint
encountered in the current execution.  Until the spypoint is reached,
it does not keep any information of the execution of the goal, and
hence you will not be able to see the ancestors of the goal when you
reach the spypoint.

   The effect of this predicate can also be achieved by typing the
letter `z' after a `^C' interrupt (*note Execution::).

See Also
--------

*Note Basic Debug::.


File: sicstus.info,  Node: C Reference Pages,  Next: Command Reference Pages,  Prev: Prolog Reference Pages,  Up: Top

12 C Reference Pages
********************

* Menu:

* cpg-rve::                             Return Values and Errors
* cpg-top::                             Topical List of C Functions
* cpg-bif::                             C Functions


File: sicstus.info,  Node: cpg-rve,  Next: cpg-top,  Up: C Reference Pages

12.1 Return Values and Errors
=============================

Many, but not all, C functions return one of the codes `SP_SUCCESS' for
success, `SP_FAILURE' for failure, `SP_ERROR' if an error condition
occurred, or if an uncaught exception was raised during a call from C
to Prolog.  If the value is `SP_ERROR', the macro `SP_errno' will
return a value (an integer) describing the error condition.

   The function `SP_error_message()' returns a pointer to the diagnostic
message corresponding to a specified error number.

   See *Note mpg-ref-ove:: for a description of the conventions
observed in the Reference Pages for Prolog predicates.  C function
Reference Pages differ primarily in the synopsis. Also, the Reference
Page for each C function documents its return values.

   The following function annotations are used in the Reference Pages:

"hook"
     The function is user defined and is called in some specific
     context.

"macro"
     The function is defined as a C macro.

"preinit"
     It is only meaningful to call the function before initializing the
     Prolog engine


File: sicstus.info,  Node: cpg-top,  Next: cpg-bif,  Prev: cpg-rve,  Up: C Reference Pages

12.2 Topical List of C Functions
================================

* Menu:

* cpg-top-err::                         C Errors
* cpg-top-cio::                         I/O
* cpg-top-exc::                         Exceptions
* cpg-top-fst::                         Files and Streams
* cpg-top-fin::                         Foreign Interface
* cpg-top-main::                        Initialization
* cpg-top-mem::                         Memory Management
* cpg-top-sig::                         Signal Handling
* cpg-top-tic::                         Terms in C
* cpg-top-typ::                         Type Tests


File: sicstus.info,  Node: cpg-top-err,  Next: cpg-top-cio,  Up: cpg-top

12.2.1 C Errors
---------------

`SP_error_message()'
     gets the corresponding error message from an error number obtained
     from `SP_error'


File: sicstus.info,  Node: cpg-top-cio,  Next: cpg-top-exc,  Prev: cpg-top-err,  Up: cpg-top

12.2.2 I/O
----------

`SP_get_byte()'
     gets a byte from a Prolog binary input stream

`SP_get_code()'
     gets a character code from a Prolog input text stream

`SP_unget_byte()'
`SP_unget_code()'
     Ungets a byte or character, respectively.

`SP_fprintf()'
`SP_printf()'
     prints formatted output on a Prolog output text stream

`SP_put_byte()'
`SP_put_bytes()'
     Writes one or more bytes to a Prolog output binary stream.

`SP_put_code()'
`SP_put_codes()'
`SP_put_encoded_string()'
     Writes one or more characters to a Prolog output text stream.



File: sicstus.info,  Node: cpg-top-exc,  Next: cpg-top-fst,  Prev: cpg-top-cio,  Up: cpg-top

12.2.3 Exceptions
-----------------

`SP_exception_term()'
     fetches the Prolog term representing the most recently raised
     exception

`SP_fail()'
     propagates failure to Prolog

`SP_on_fault()  "[macro]"'
     provide a scope for faults

`SP_raise_exception()'
     propagates an exception to Prolog

`SP_raise_fault()'
     raise a fault


File: sicstus.info,  Node: cpg-top-fst,  Next: cpg-top-fin,  Prev: cpg-top-exc,  Up: cpg-top

12.2.4 Files and Streams
------------------------

`SP_fopen()'
     opens a file as a Prolog stream

`SP_fclose()'
     closes a Prolog stream

`SP_flush_output()'
     flushes output on a Prolog output stream

`SP_load()'
     same as `load_files/1'

`SP_create_stream()'
     makes a new Prolog stream

`SP_restore()'
     same as `restore/1'

`SP_set_user_stream_hook()  "[preinit]"'
`SP_set_user_stream_post_hook()  "[preinit]"'
     provide hooks for setting up standard streams


File: sicstus.info,  Node: cpg-top-fin,  Next: cpg-top-main,  Prev: cpg-top-fst,  Up: cpg-top

12.2.5 Foreign Interface
------------------------

`SP_atom_from_string()'
     returns the encoded string representing a Prolog atom

`SP_atom_length()'
     returns the length of the encoded string representing a Prolog atom

`SP_close_query()'
     closes a Prolog query opened from C by `SP_open_query()'

`SP_cons_functor()'
`SP_cons_functor_array()'
     creates a Prolog compound term from C

`SP_cons_list()'
     creates a Prolog list from C

`SP_cut_query()'
     terminates a nondeterminate Prolog query opened from C

`SP_define_c_predicate()'
     defines a Prolog predicate linked to a C function

`SP_exception_term()'
     returns the Prolog term to C corresponding to the most recent
     Prolog error

`SP_get_address()'
     fetches an integer representing a pointer in an SP_term_ref

`SP_get_arg()'
     fetches a specified argument of a compound term in an SP_term_ref

`SP_get_atom()'
     fetches an atom from an SP_term_ref

`SP_get_current_dir()'
     obtain name of current working directory

`SP_get_float()'
     fetches a floating point number from an SP_term_ref

`SP_get_functor()'
     fetches the name and arity of a term in an SP_term_ref

`SP_get_integer()'
     fetches an integer in an SP_term_ref

`SP_get_integer()'
     fetches an arbitrarily sized integer in an SP_term_ref

`SP_get_list()'
     fetches the head and tail of a list in an SP_term_ref

`SP_get_list_codes()'
     fetches a code-list in an SP_term_ref

`SP_get_list_n_codes()'
     fetches the first part of a code-list in an SP_term_ref

`SP_get_list_n_bytes()'
     fetches the first part of a byte-list in an SP_term_ref

`SP_get_number_codes()'
     fetches a number encoded as a code-list in an SP_term_ref

`SP_get_string()'
     fetches the encoded string representing a Prolog atom in an
     SP_term_ref

`SP_next_solution()'
     gets the next solution, if any, to an open Prolog query

`SP_open_query()'
     opens a Prolog query from C

`SP_pred()'
     fetches an identifier for a Prolog predicate

`SP_predicate()'
     fetches an identifier a Prolog predicate

`SP_put_address()'
     assigns a pointer to an SP_term_ref

`SP_put_atom()'
     assigns an atom to an SP_term_ref

`SP_put_float()'
     assigns a floating point number to an SP_term_ref

`SP_put_functor()'
     assigns a new compound term to an SP_term_ref

`SP_put_integer()'
     assigns an integer to an SP_term_ref

`SP_put_integer_bytes()'
     assigns an arbitrarily sized integer to an SP_term_ref

`SP_put_list()'
     assigns a new list to an SP_term_ref

`SP_put_list_codes()'
     assigns a code-list to an SP_term_ref

`SP_put_list_n_codes()'
     assigns the first part of a code-list to an SP_term_ref

`SP_put_list_n_bytes()'
     assigns the first part of a byte-list to an SP_term_ref

`SP_put_number_codes()'
     assigns a number encoded as a code-list to an SP_term_ref

`SP_put_string()'
     assigns the atom represented by an encoded string to an SP_term_ref

`SP_put_term()'
     assigns the value of an SP_term_ref to another SP_term_ref

`SP_put_variable()'
     assigns a Prolog variable to an SP_term_ref

`SP_query()'
     makes a determinate query to a Prolog predicate, committing to the
     solution

`SP_query_cut_fail()'
     makes a determinate query to a Prolog predicate for side-effects
     only

`SP_read_from_string()'
     assigns a Prolog term read from a string to an SP_term_ref

`SP_set_current_dir()'
     set name of current working directory

`SP_string_from_atom()'
     returns a null-terminated string corresponding to a Prolog atom


File: sicstus.info,  Node: cpg-top-main,  Next: cpg-top-mem,  Prev: cpg-top-fin,  Up: cpg-top

12.2.6 Initialization
---------------------

`SP_deinitialize()'
     shuts down the Prolog engine

`SP_force_interactive()  "[preinit]"'
     consider standard streams to be interactive streams, even if they
     appear not to be TTY streams

`SP_initialize()  "[macro]"'
     initializes the Prolog engine

`SP_set_memalloc_hooks()  "[preinit]"'
     provide the memory management bottom layer

`SP_set_user_stream_hook()  "[preinit]"'
`SP_set_user_stream_post_hook()  "[preinit]"'
     provide hooks for setting up standard streams

`SU_initialize()  "[hook]"'
     called before initializing the Prolog engine in applications built
     with `--userhook'


File: sicstus.info,  Node: cpg-top-mem,  Next: cpg-top-sig,  Prev: cpg-top-main,  Up: cpg-top

12.2.7 Memory Management
------------------------

`SP_calloc()'
     Allocates memory for an array of elements, and clears the
     allocated memory.

`SP_foreign_stash()  "[macro]"'
     provide a memory location unique to the current foreign resource
     instance

`SP_free()'
     Deallocates a piece of memory.

`SP_malloc()'
     Allocates a piece of memory.

`SP_mutex_lock()'
     Locks a mutex.

`SP_mutex_unlock()'
     Unlocks a mutex.

`SP_realloc()'
     Changes the size of an allocated piece of memory.

`SP_register_atom()'
     prevents an atom from being discarded by atom garbage collection
     even if not referenced by Prolog code

`SP_set_memalloc_hooks()  "[preinit]"'
     provide the memory management bottom layer

`SP_strdup()'
     Makes a copy of a string in allocated memory.

`SP_unregister_atom()'
     enables an atom to be discarded during atom garbage collection if
     not referenced by Prolog code



File: sicstus.info,  Node: cpg-top-sig,  Next: cpg-top-tic,  Prev: cpg-top-mem,  Up: cpg-top

12.2.8 Signal Handling
----------------------

`SP_signal()'
     install a signal handler

`SP_event()'
     Schedules a function for execution in the main thread in contexts
     where queries cannot be issued.


File: sicstus.info,  Node: cpg-top-tic,  Next: cpg-top-typ,  Prev: cpg-top-sig,  Up: cpg-top

12.2.9 Terms in C
-----------------

`SP_compare()'
     compares two terms using Prolog's standard term order

`SP_new_term_ref()'
     returns an SP_term_ref, which can be used to hold a Prolog term in
     C

`SP_unify()'
     unifies two Prolog terms


File: sicstus.info,  Node: cpg-top-typ,  Prev: cpg-top-tic,  Up: cpg-top

12.2.10 Type Tests
------------------

`SP_is_atom()'
     tests whether an SP_term_ref contains an atom

`SP_is_atomic()'
     tests whether an SP_term_ref contains an atomic term

`SP_is_compound()'
     tests whether an SP_term_ref contains a compound term

`SP_is_float()'
     tests whether an SP_term_ref contains a floating point number

`SP_is_integer()'
     tests whether an SP_term_ref contains a Prolog integer

`SP_is_list()'
     tests whether an SP_term_ref contains a list

`SP_is_number()'
     tests whether an SP_term_ref contains an integer or a floating
     point number

`SP_is_variable()'
     tests whether an SP_term_ref contains a Prolog variable

`SP_term_type()'
     returns the type of the term in an SP_term_ref


File: sicstus.info,  Node: cpg-bif,  Prev: cpg-top,  Up: C Reference Pages

12.3 API Functions
==================

The following reference pages, alphabetically arranged, describe the
SICStus Prolog API functions.

* Menu:

* cpg-ref-SP_atom_from_string:: SP_atom_from_string()
* cpg-ref-SP_atom_length:: SP_atom_length()
* cpg-ref-SP_calloc:: SP_calloc()
* cpg-ref-SP_close_query:: SP_close_query()
* cpg-ref-SP_compare:: SP_compare()
* cpg-ref-SP_cons_functor:: SP_cons_functor()
* cpg-ref-SP_cons_functor_array:: SP_cons_functor_array()
* cpg-ref-SP_cons_list:: SP_cons_list()
* cpg-ref-SP_create_stream:: SP_create_stream()
* cpg-ref-SP_cut_query:: SP_cut_query()
* cpg-ref-SP_define_c_predicate:: SP_define_c_predicate()
* cpg-ref-SP_deinitialize:: SP_deinitialize()
* cpg-ref-SP_error_message:: SP_error_message()
* cpg-ref-SP_event:: SP_event()
* cpg-ref-SP_exception_term:: SP_exception_term()
* cpg-ref-SP_expand_file_name:: SP_expand_file_name()
* cpg-ref-SP_fail:: SP_fail()
* cpg-ref-SP_fclose:: SP_fclose()
* cpg-ref-SP_flush_output:: SP_flush_output()
* cpg-ref-SP_fopen:: SP_fopen()
* cpg-ref-SP_foreign_stash:: SP_foreign_stash()
* cpg-ref-SP_fprintf:: SP_fprintf()
* cpg-ref-SP_free:: SP_free()
* cpg-ref-SP_get_address:: SP_get_address()
* cpg-ref-SP_get_arg:: SP_get_arg()
* cpg-ref-SP_get_atom:: SP_get_atom()
* cpg-ref-SP_get_byte:: SP_get_byte()
* cpg-ref-SP_get_code:: SP_get_code()
* cpg-ref-SP_get_current_dir:: SP_get_current_dir()
* cpg-ref-SP_get_float:: SP_get_float()
* cpg-ref-SP_get_functor:: SP_get_functor()
* cpg-ref-SP_get_integer:: SP_get_integer()
* cpg-ref-SP_get_integer_bytes:: SP_get_integer_bytes()
* cpg-ref-SP_get_list:: SP_get_list()
* cpg-ref-SP_get_list_codes:: SP_get_list_codes()
* cpg-ref-SP_get_list_n_bytes:: SP_get_list_n_bytes()
* cpg-ref-SP_get_list_n_codes:: SP_get_list_n_codes()
* cpg-ref-SP_get_number_codes:: SP_get_number_codes()
* cpg-ref-SP_get_stream_counts:: SP_get_stream_counts()
* cpg-ref-SP_get_stream_user_data:: SP_get_stream_user_data()
* cpg-ref-SP_get_string:: SP_get_string()
* cpg-ref-SP_initialize:: SP_initialize()
* cpg-ref-SP_is_atom:: SP_is_atom()
* cpg-ref-SP_is_atomic:: SP_is_atomic()
* cpg-ref-SP_is_compound:: SP_is_compound()
* cpg-ref-SP_is_float:: SP_is_float()
* cpg-ref-SP_is_integer:: SP_is_integer()
* cpg-ref-SP_is_list:: SP_is_list()
* cpg-ref-SP_is_number:: SP_is_number()
* cpg-ref-SP_is_variable:: SP_is_variable()
* cpg-ref-SP_load:: SP_load()
* cpg-ref-SP_malloc:: SP_malloc()
* cpg-ref-SP_mutex_lock:: SP_mutex_lock()
* cpg-ref-SP_mutex_unlock:: SP_mutex_unlock()
* cpg-ref-SP_new_term_ref:: SP_new_term_ref()
* cpg-ref-SP_next_solution:: SP_next_solution()
* cpg-ref-SP_next_stream:: SP_next_stream()
* cpg-ref-SP_open_query:: SP_open_query()
* cpg-ref-SP_pred:: SP_pred()
* cpg-ref-SP_predicate:: SP_predicate()
* cpg-ref-SP_printf:: SP_printf()
* cpg-ref-SP_put_address:: SP_put_address()
* cpg-ref-SP_put_atom:: SP_put_atom()
* cpg-ref-SP_put_byte:: SP_put_byte()
* cpg-ref-SP_put_bytes:: SP_put_bytes()
* cpg-ref-SP_put_code:: SP_put_code()
* cpg-ref-SP_put_codes:: SP_put_codes()
* cpg-ref-SP_put_encoded_string:: SP_put_encoded_string()
* cpg-ref-SP_put_float:: SP_put_float()
* cpg-ref-SP_put_functor:: SP_put_functor()
* cpg-ref-SP_put_integer:: SP_put_integer()
* cpg-ref-SP_put_integer_bytes:: SP_put_integer_bytes()
* cpg-ref-SP_put_list:: SP_put_list()
* cpg-ref-SP_put_list_codes:: SP_put_list_codes()
* cpg-ref-SP_put_list_n_bytes:: SP_put_list_n_bytes()
* cpg-ref-SP_put_list_n_codes:: SP_put_list_n_codes()
* cpg-ref-SP_put_number_codes:: SP_put_number_codes()
* cpg-ref-SP_put_string:: SP_put_string()
* cpg-ref-SP_put_term:: SP_put_term()
* cpg-ref-SP_put_variable:: SP_put_variable()
* cpg-ref-SP_query:: SP_query()
* cpg-ref-SP_query_cut_fail:: SP_query_cut_fail()
* cpg-ref-SP_raise_exception:: SP_raise_exception()
* cpg-ref-SP_read_from_string:: SP_read_from_string()
* cpg-ref-SP_realloc:: SP_realloc()
* cpg-ref-SP_register_atom:: SP_register_atom()
* cpg-ref-SP_restore:: SP_restore()
* cpg-ref-SP_set_current_dir:: SP_set_current_dir()
* cpg-ref-SP_set_memalloc_hooks:: SP_set_memalloc_hooks()
* cpg-ref-SP_set_user_stream_hook:: SP_set_user_stream_hook()
* cpg-ref-SP_set_user_stream_post_hook:: SP_set_user_stream_post_hook()
* cpg-ref-SP_signal:: SP_signal()
* cpg-ref-SP_strdup:: SP_strdup()
* cpg-ref-SP_string_from_atom:: SP_string_from_atom()
* cpg-ref-SP_term_type:: SP_term_type()
* cpg-ref-SP_unget_byte:: SP_unget_byte()
* cpg-ref-SP_unget_code:: SP_unget_code()
* cpg-ref-SP_unify:: SP_unify()
* cpg-ref-SP_unregister_atom:: SP_unregister_atom()
* cpg-ref-SU_initialize:: SU_initialize()
* cpg-ref-user_close:: user_close()
* cpg-ref-user_flush_output:: user_flush_output()
* cpg-ref-user_read:: user_read()
* cpg-ref-user_write:: user_write()


File: sicstus.info,  Node: cpg-ref-SP_atom_from_string,  Next: cpg-ref-SP_atom_length,  Up: cpg-bif

12.3.1 `SP_atom_from_string()'
------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_atom
     SP_atom_from_string(char const *str);

Finds the Prolog atom whose characters are encoded by `str'.

Arguments
---------

STR
     The characters comprising the atom.

Return Value
------------

The SP_atom, if `str' is a valid internal character encoding, and 0
otherwise.

See Also
--------

*Note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SP_atom_length,  Next: cpg-ref-SP_calloc,  Prev: cpg-ref-SP_atom_from_string,  Up: cpg-bif

12.3.2 `SP_atom_length()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_atom_length(SP_atom atom);

Obtains the length of the encoded string representing a Prolog atom.

Arguments
---------

ATOM
     The atom to inspect.

Return Value
------------

The length if `atom' is valid, and 0 otherwise.

Description
-----------

Same as `strlen(SP_string_from_atom(a)', but runs in O(1) time.

See Also
--------

*Note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SP_calloc,  Next: cpg-ref-SP_close_query,  Prev: cpg-ref-SP_atom_length,  Up: cpg-bif

12.3.3 `SP_calloc()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_calloc(size_t nmemb,
               size_t size);

Allocates a block of at least `size * nemb'. The first `size * nmemb'
bytes are set to zero.

Arguments
---------

NMEMB
     How many items to allocate.

SIZE
     Size of each item.

Return Value
------------

The pointer, if allocation was successful, otherwise `NULL'.

See Also
--------

*Note OS Memory Management::.


File: sicstus.info,  Node: cpg-ref-SP_close_query,  Next: cpg-ref-SP_compare,  Prev: cpg-ref-SP_calloc,  Up: cpg-bif

12.3.4 `SP_close_query()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_close_query(SP_qid query);

Discard the current solution to the given query, and close it.

Arguments
---------

QUERY
     The query, created by `SP_open_query()'.

Return Value
------------

`SP_SUCCESS' for success, `SP_ERROR' if an error condition occurred.

Description
-----------

This will discard the choices created since the corresponding
`SP_open_query()', and then backtrack into the query, throwing away any
current solution, like the goal `!, fail'.  The given argument does not
have to be the innermost open query; any open queries in its scope will
also be closed.

See Also
--------

*Note Finding Multiple Solutions of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_compare,  Next: cpg-ref-SP_cons_functor,  Prev: cpg-ref-SP_close_query,  Up: cpg-bif

12.3.5 `SP_compare()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_compare(SP_term_ref x,
                SP_term_ref y)

Compares two terms.

Arguments
---------

X
     The one term to compare

Y
     The other term to compare

Return Value
------------

-1 if `x' @< `y', 0 if `x' == `y', and 1 if `x' @> `y'.

See Also
--------

*Note ref-lte-cte::, *Note Unifying and Comparing Terms::.


File: sicstus.info,  Node: cpg-ref-SP_cons_functor,  Next: cpg-ref-SP_cons_functor_array,  Prev: cpg-ref-SP_compare,  Up: cpg-bif

12.3.6 `SP_cons_functor()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cons_functor(SP_term_ref term,
                     SP_atom name,
                     int arity,
                     SP_term_ref arg, ...);

Assigns to `term' a reference to a compound term whose arguments are
the values of `arg'....  If `arity' is 0, assigns the Prolog atom whose
canonical representation is `name'.  This is similar to calling `=../2'
with the first argument unbound and the second argument bound.

Arguments
---------

TERM
     The SP_term_ref to be assigned

NAME
     The name of the functor

ARITY
     The arity of the functor

ARG ...
     The arguments

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_cons_functor_array,  Next: cpg-ref-SP_cons_list,  Prev: cpg-ref-SP_cons_functor,  Up: cpg-bif

12.3.7 `SP_cons_functor_array()'
--------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cons_functor_array(SP_term_ref term,
     		      SP_atom name,
     		      int arity,
     		      SP_term_ref *arg);

Assigns to `term' a reference to a compound term whose arguments are
the elements of `arg'.  If `arity' is 0, assigns the Prolog atom whose
canonical representation is `name'.  This is similar to calling `=../2'
with the first argument unbound and the second argument bound.

Arguments
---------

TERM
     The SP_term_ref to be assigned

NAME
     The name of the functor

ARITY
     The arity of the functor

ARG
     The argument array

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_cons_list,  Next: cpg-ref-SP_create_stream,  Prev: cpg-ref-SP_cons_functor_array,  Up: cpg-bif

12.3.8 `SP_cons_list()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cons_list(SP_term_ref term,
                  SP_term_ref head,
                  SP_term_ref tail);

Assigns to `term' a reference to a Prolog list whose head and tail are
the values of `head' and `tail'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

HEAD
     The head of the new list

TAIL
     The tail of the new list

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_create_stream,  Next: cpg-ref-SP_cut_query,  Prev: cpg-ref-SP_cons_list,  Up: cpg-bif

12.3.9 `SP_create_stream()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_create_stream(
        void *user_data,
        void const *user_class,
        spio_t_simple_device_read *user_read,
        spio_t_simple_device_write *user_write,
        spio_t_simple_device_flush_output *user_flush_output,
        spio_t_simple_device_seek *user_seek,
        spio_t_simple_device_close *user_close,
        spio_t_simple_device_interrupt *user_interrupt,
        spio_t_simple_device_ioctl *user_ioctl,
        spio_t_bits create_stream_options,
        SP_stream **pstream);

Create a Prolog stream that will call user defined functions to perform
stream operations.

Arguments
---------

USER_DATA
     This is a pointer to arbitrary user specified data. It is passed to
     all user defined stream methods. It must not be `NULL'.

USER_CLASS
     Arbitrary pointer. This is used with `SP_get_stream_user_data()',
     which see.

USER_READ
     If non-NULL then this is an input stream.  *Note
     cpg-ref-user_read:: for details.

USER_WRITE
     If non-NULL then this is an output stream.  *Note
     cpg-ref-user_write:: for details.

     Note that both `user_read' and `user_write' can be specified,
     signifying a bidirectional stream.

USER_FLUSH_OUTPUT
     Will be called to flush output on the stream. Ignored if
     `user_write' is `NULL'. Can be `NULL' if the stream need not be
     flushed, e.g. if `user_write' always ensures that any output
     reaches its destination immediately.  *Note
     cpg-ref-user_flush_output:: for details.

USER_SEEK
     Reserved, should be `NULL'.

USER_CLOSE
     Closes the stream.  *Note cpg-ref-user_close:: for details.

USER_INTERRUPT
     Reserved, should be `NULL'.

USER_IOCTL
     Reserved, should be `NULL'.

ARGS
     Reserved, should be `NULL'.

CREATE_STREAM_OPTIONS
     The following bits can be set:

    `SP_CREATE_STREAM_OPTION_BINARY'
          This is a binary stream. The `user_read' and `user_write'
          methods transfer bytes.

    `SP_CREATE_STREAM_OPTION_TEXT'
          This is a TEXT stream. The `user_read' and `user_write'
          methods transfer wide characters.

    `SP_CREATE_STREAM_OPTION_AUTOFLUSH'
          After writing to this stream prolog predicates will do a
          `flush_output/1'. In essence this ensures that the stream
          behaves as if it were unbuffered.

    `SP_CREATE_STREAM_OPTION_INTERACTIVE'
          Treat this stream as an interactive stream. Implies
          `SP_CREATE_STREAM_OPTION_AUTOFLUSH'.

    `SP_CREATE_STREAM_OPTION_EOF_ON_EOF'
    `SP_CREATE_STREAM_OPTION_RESET_ON_EOF'
          These correspond to the `open/4' options `eof_action(eof)'
          and `eof_action(reset)' respectively. The default is to give
          an error if reading after reaching end of file.

     Exactly one of `SP_CREATE_STREAM_OPTION_BINARY' and
     `SP_CREATE_STREAM_OPTION_TEXT' must be set.

PSTREAM
     This is assigned to the created SICStus stream on success. It
     should be closed with `SP_fclose()' or `close/[1,2]'.


Return Value
------------

On success, `*pstream' is assigned, and `SPIO_S_NOERR' or some other
success code is returned. You should use the `SPIO_FAILED()' macro to
determine if the return value signifies failure or success.

See Also
--------

*Note Defining a New Stream::.


File: sicstus.info,  Node: cpg-ref-SP_cut_query,  Next: cpg-ref-SP_define_c_predicate,  Prev: cpg-ref-SP_create_stream,  Up: cpg-bif

12.3.10 `SP_cut_query()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cut_query(SP_qid query);

Commit to the current solution to the given query, and close it.

Arguments
---------

QUERY
     The query, created by `SP_open_query()'.

Return Value
------------

`SP_SUCCESS' for success, `SP_FAILURE' for failure, `SP_ERROR' if an
error condition occurred.

Description
-----------

This will discard the choices created since the corresponding
`SP_open_query()', like the goal `!'.  The current solution is retained
in the arguments until backtracking into any enclosing query.  The
given argument does not have to be the innermost open query; any open
queries in its scope will also be cut.

See Also
--------

*Note Finding Multiple Solutions of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_define_c_predicate,  Next: cpg-ref-SP_deinitialize,  Prev: cpg-ref-SP_cut_query,  Up: cpg-bif

12.3.11 `SP_define_c_predicate()'
---------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     typedef int
     SP_CPredFun(SP_term_ref goal,
                 void *stash);

     int
     SP_define_c_predicate(char *name,
                           int arity,
                           char *module,
                           SP_CPredFun *proc,
                           void *stash);

Defines a Prolog predicate such that when the Prolog predicate is
called it will call a C function with a term corresponding to the
Prolog goal.

Arguments
---------

NAME
     The predicate name.

ARITY
     The predicate arity.

MODULE
     The predicate module name.

PROC
     The function.

STASH
     See below.

Return Value
------------

Nonzero on success, and 0 otherwise.

Description
-----------

The Prolog predicate MODULE:NAME/ARITY will be defined (the module
MODULE must already exist). The `stash' argument can be anything and is
simply passed as the second argument to the C function PROC.

   The C function should return `SP_SUCCESS' for success and
`SP_FAILURE' for failure. The C function may also call `SP_fail()' or
`SP_raise_exception()' in which case the return value will be ignored.

Examples
--------

Here is an end-to-end example of the above:

                                                          _% square.pl_
     foreign_resource(square, [init(square_init)]).

     :- load_foreign_resource(square).

                                                          _// square.c_
     #include <sicstus/sicstus.h>

     static int square_it(SP_term_ref goal, void *stash)
     {
       long arg1;
       SP_term_ref tmp = SP_new_term_ref();
       SP_term_ref square_term = SP_new_term_ref();
       long the_square;

       // goal will be a term like square(42,X)
       SP_get_arg(1,goal,tmp); // extract first arg
       if (!SP_get_integer(tmp,&arg1))
         return SP_FAILURE;   // type check first arg

       SP_put_integer(square_term, arg1*arg1);
       SP_get_arg(2,goal,tmp); // extract second arg

       // Unify output argument.
          SP_put_integer(tmp,...) would *not* work!
       return (SP_unify(tmp, square_term) ? SP_SUCCESS : SP_FAILURE);
     }

     void square_init(int when)
     {
       (void)when;                   // unused
       // Install square_it as user:square/2
       SP_define_c_predicate("square", 2, "user", square_it, NULL);
     }

                                                           _# terminal_
     % splfr square.pl square.c
     % sicstus -f -l square
     % compiling /home/matsc/tmp/square.pl...
     %  loading foreign resource /home/matsc/tmp/square.so in module user
     % compiled /home/matsc/tmp/square.pl in module user, 0 msec 816 bytes
     SICStus 4.0.2 ...
     Licensed to SICS
     | ?- square(4711, X).
     X = 22193521 ?
     yes
     | ?- square(not_an_int, X).
     no

See Also
--------

*Note Calling C from Prolog::.


File: sicstus.info,  Node: cpg-ref-SP_deinitialize,  Next: cpg-ref-SP_error_message,  Prev: cpg-ref-SP_define_c_predicate,  Up: cpg-bif

12.3.12 `SP_deinitialize()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void
     SP_deinitialize(void);

Shuts down the Prolog engine.

Description
-----------

`SP_deinitialize()' will make a best effort to restore the system to
the state it was in at the time of calling `SP_initialize()'. This
involves unloading foreign resources, shutting down the emulator, and
deallocating memory used by Prolog.

   `SP_deinitialize()' is idempotent i.e. it is a no-op unless SICStus
has actually been initialized.

See Also
--------

*Note Initializing the Prolog Engine::.


File: sicstus.info,  Node: cpg-ref-SP_error_message,  Next: cpg-ref-SP_event,  Prev: cpg-ref-SP_deinitialize,  Up: cpg-bif

12.3.13 `SP_error_message()'
----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>
     char const *
     SP_error_message(int errnum);

Obtains a pointer to the diagnostic message corresponding to a
specified error number.

Arguments
---------

ERRNUM
     The error number.

Return Value
------------

A pointer to the diagnostic message.

See Also
--------

*Note CPL Notes::.


File: sicstus.info,  Node: cpg-ref-SP_event,  Next: cpg-ref-SP_exception_term,  Prev: cpg-ref-SP_error_message,  Up: cpg-bif

12.3.14 `SP_event()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_event(int (*func)(void*), void *arg)

Schedules a function for execution in the main thread in contexts where
queries cannot be issued.

Arguments
---------

FUNC
     The function to schedule for execution.

ARG
     Its argument.

Return Value
------------

Nonzero on success, and 0 otherwise.

Description
-----------

If you wish to call Prolog back from a signal handler that has been
installed with `SP_signal' or a thread other than the thread that
called `SP_initialize()', that is, the "main thread", you cannot use
`SP_query()' etc. directly.  The call to Prolog has to be delayed until
such time that the Prolog execution can accept an interrupt and the
call has to be performed from the main thread (the Prolog execution
thread).  This function serves this purpose, and installs `func' to be
called from Prolog (in the main thread) when the execution can accept a
callback.

   A queue of functions, with corresponding arguments, is maintained;
that is, if several calls to `SP_event()' occur before Prolog can
accept an interrupt, the functions are queued and executed in turn at
the next possible opportunity. A `func' installed with `SP_event()'
will not be called until SICStus is actually running. One way of
ensuring that all pending functions installed with `SP_event()' are run
is to call, from the main thread, some dummy goal, such as,

     SP_query_cut_fail(SP_predicate("true",0,"user"));

   While `SP_event()' is safe to call from any thread, it is not safe
to call from arbitrary signal handlers. If you want to call
`SP_event()' when a signal is delivered, you need to install your
signal handler with `SP_signal()'.

   Note that `SP_event()' is one of the _very_ few functions in the
SICStus API that can safely be called from another thread than the main
thread.

   Depending on the value returned from `func', the interrupted Prolog
execution will just continue (`SP_SUCCESS') or backtrack (`SP_FAILURE'
or `SP_ERROR').  An exception raised by `func', using
`SP_raise_exception()', will be processed in the interrupted Prolog
execution. If `func' calls `SP_fail()' or `SP_raise_exception()' the
return value from `func' is ignored and handled as if `func' returned
`SP_FAILURE' or `SP_ERROR', respectively.  In case of failure or
exception, the event queue is flushed.

   It is generally not robust to let `func' raise an exception or fail.
The reason is that not all Prolog code is written such that it
gracefully handles being interrupted. If you want to interrupt some
long-running Prolog code, it is better to let your code test a flag in
some part of your code that is executed repeatedly.

Examples
--------

How to install the predicate `user:event_pred/1' as the signal handler
for `SIGUSR1' and `SIGUSR2' signals.

   The function `signal_init()' installs the function
`signal_handler()' as the primary signal handler for the signals
`SIGUSR1' and `SIGUSR2'.  That function invokes the predicate as the
actual signal handler, passing the signal number as an argument to the
predicate.

     SP_pred_ref event_pred;

     static int signal_event(void *handle)
     {
       int signal_no = (int) handle;
       SP_term_ref x=SP_new_term_ref();
       int rc;

       SP_put_integer(x, signal_no); // Should not give an error
       rc = SP_query(event_pred, x);
       if (rc == SP_ERROR && SP_exception_term(x))
       SP_raise_exception(x);        // Propagate any raised exception
       return rc;
     }

     static void signal_handler(int signal_no)
     {
       SP_event(signal_event, (void *)signal_no);
     }

     void signal_init(void)
     {
       event_pred = SP_predicate("prolog_handler",1,"user");

       SP_signal(SIGUSR1, signal_handler);
       SP_signal(SIGUSR2, signal_handler);
     }

See Also
--------

*Note Calling Prolog Asynchronously::, `SP_signal()', `SP_fail()',
`SP_raise_exception()'.


File: sicstus.info,  Node: cpg-ref-SP_exception_term,  Next: cpg-ref-SP_expand_file_name,  Prev: cpg-ref-SP_event,  Up: cpg-bif

12.3.15 `SP_exception_term()'
-----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_exception_term(SP_term_ref term);

Retracts the current pending exception term, if it exists, and assigns
it to `term'.

Arguments
---------

TERM
     The SP_term_ref to assign.

Return Value
------------

1 if an execption term was retracted and assigned, and 0 otherwise.

See Also
--------

*Note Exception Handling in C::.


File: sicstus.info,  Node: cpg-ref-SP_expand_file_name,  Next: cpg-ref-SP_fail,  Prev: cpg-ref-SP_exception_term,  Up: cpg-bif

12.3.16 `SP_expand_file_name()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_expand_file_name(
        char const *relpath,
        char const *cwd,
        spio_t_bits options,
        char **pabspath);

Expand a file name into an absolute path.

Arguments
---------

RELPATH
     The relative path to expand. It should be an encoded string. The
     path is subject to syntactic rewriting, as if by
     `absolute_file_name/2'.

CWD
     If the `relpath' is a relative path, it is expanded relative to
     `cwd', unless `cwd' is `NULL'. If `cwd' is `NULL', a relative
     `relpath' is expanded relative to the SICStus working directory
     (as returned by `SP_get_current_dir()').

OPTIONS
     The following option bits can be set:

    `SP_EXPAND_FILE_NAME_OPTION_DIR'
          The `relpath' is expanded as a directory, i.e.  `*pabspath'
          will be slash terminated.

    `SP_EXPAND_FILE_NAME_OPTION_NO_CWD'
          An error is returned if the `relpath' is not an absolute path
          after syntactic rewriting.

    `SP_EXPAND_FILE_NAME_OPTION_NO_ENV'
          Do not expand environment variables during syntactic
          rewriting.

    `SP_EXPAND_FILE_NAME_OPTION_NO_HOME'
          Do not expand `~' and `~user' during syntactic rewriting.

    `SP_EXPAND_FILE_NAME_OPTION_ROOT_SLASH'
          If the expanded value would refer to the root directory,
          return a slash terminated absolute path, as if
          `SP_EXPAND_FILE_NAME_OPTION_DIR' had been set. By default, an
          error is returned if the expanded absolute path would refer
          to a root directory and `SP_EXPAND_FILE_NAME_OPTION_DIR' is
          not set.

    `SP_EXPAND_FILE_NAME_OPTION_ROOT_DOT'
          If the expanded value would refer to the root directory,
          return an absolute path terminated with `/.'. By default, an
          error is returned if the expanded absolute path would refer
          to a root directory and `SP_EXPAND_FILE_NAME_OPTION_DIR' is
          not set.

PABSPATH
     On success, `*pabspath' is set to the expanded path. This value is
     allocated with `SP_malloc()' and should be freed with `SP_free()'.

Return Value
------------

On success, `*pabspath' is set to the expanded path and `SPIO_S_NOERR'
or some other success code is returned.

   On failure, an error code is returned.

See Also
--------

*Note cpg-ref-SP_get_current_dir::.  *Note ref-fdi-syn::, for a
description of syntactic rewriting.  *Note OS File System::.


File: sicstus.info,  Node: cpg-ref-SP_fail,  Next: cpg-ref-SP_fclose,  Prev: cpg-ref-SP_expand_file_name,  Up: cpg-bif

12.3.17 `SP_fail()'
-------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void
     SP_fail(SP_term_ref term);

Fails in the scope of Prolog calling C.

Arguments
---------

TERM
     The SP_term_ref whose value will be the exception term.

Description
-----------

This function is normally used in the context of a call from Prolog to
C, and will cause Prolog to backtrack on return from the call.

See Also
--------

*Note Exception Handling in C::.


File: sicstus.info,  Node: cpg-ref-SP_fclose,  Next: cpg-ref-SP_flush_output,  Prev: cpg-ref-SP_fail,  Up: cpg-bif

12.3.18 `SP_fclose()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_fclose(
       SP_stream *stream,
       spio_t_bits close_options);

Close the stream.

Arguments
---------

STREAM
     The stream to close unless the `SP_FCLOSE_OPTION_USER_STREAMS' is
     set, see below.

CLOSE_OPTIONS
     The following bits can be set:

    `SP_FCLOSE_OPTION_READ'
    `SP_FCLOSE_OPTION_WRITE'
          Close the specified directions. If neither of these options is
          specified, the stream is closed in all opened directions, i.e.
          as if both options were specified. If the stream is not
          opened in a direction specified by an option, that option is
          ignored.

          Note that it is possible to close only one direction of a
          bidirectional stream. The return value will tell whether the
          stream is still open; see below.

    `SP_FCLOSE_OPTION_FORCE'
          Close the specified direction forcibly, i.e. without flushing
          buffers etc.  This also ensures that the close finishes
          "quickly", i.e. does not block.

    `SP_FCLOSE_OPTION_NONBLOCKING'
          You should avoid using this option.

          Pass non-blocking option to lower level routines, including
          the call to `SP_flush_output()' that is issued when
          non-forcibly closing write direction.

          One possible use for this option is to perform a "best effort"
          close, which falls back to using `SP_FCLOSE_OPTION_FORCE'
          only if ordinary close would block.

    `SP_FCLOSE_OPTION_USER_STREAMS'
          In this case the STREAM should not be a stream but instead be
          the `user_class' of a user defined stream. When this option is
          passed, all currently opened streams of that class is closed,
          using the remaining option flags. E.g. to close all user
          defined streams of class my_class in the read direction only
          do:
          `SP_fclose((SP_stream*)my_class,SP_FCLOSE_OPTION_USER_STREAMS|SP_FCLOSE_OPTION_READ)'.

Return Value
------------

On success, all specified directions has been closed. Since some
direction may still be open, there are two possible return values on
success:

`SPIO_S_NOERR'
     The stream is still valid, some direction is still not closed.

`SPIO_S_DEALLOCATED'
     The stream has been deallocated and cannot be used further. All
     directions have been closed.

   On failure, returns a SPIO error code. Error codes with special
meaning for `SP_fclose()' are the same as for `SP_flush_output()', which
see.  Other error codes may also be returned.

See Also
--------

*Note cpg-ref-SP_flush_output::.  *Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_flush_output,  Next: cpg-ref-SP_fopen,  Prev: cpg-ref-SP_fclose,  Up: cpg-bif

12.3.19 `SP_flush_output()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_flush_output(
       SP_stream *stream,
       spio_t_bits flush_options);

Ensure that all buffered data reaches its destination.

Arguments
---------

STREAM
     The stream to flush. This stream should be open for writing.

FLUSH_OPTIONS
     The following bits can be set:

    `SP_FLUSH_OUTPUT_OPTION_NONBLOCKING'
          If this is set, the function should return "quickly" or with
          a `SPIO_E_WOULD_BLOCK' code.

          Can return `SPIO_E_NOT_SUPPORTED' if the stream cannot support
          non-blocking flush.

    `SP_FLUSH_OUTPUT_OPTION_AUTOFLUSH'
          Only flush stream if it has AUTOFLUSH enabled.

Return Value
------------

On success, all buffered data should have been written and
`SPIO_S_NOERR' or some other success code returned.

   On failure, returns a SPIO error code. Error codes with special
meaning for `SP_flush_output()':

`SPIO_E_END_OF_FILE'
     Returned if it is not possible to write more data onto the stream,
     e.g. some underlying device has been closed.

`SPIO_E_WOULD_BLOCK'
     `SP_FLUSH_OUTPUT_OPTION_NONBLOCKING' was set but the operation
     would block.

`SPIO_E_NOT_SUPPORTED'
     Some unsupported option, e.g.
     `SP_FLUSH_OUTPUT_OPTION_NONBLOCKING',  was passed.

Other error codes may also be returned.

See Also
--------

*Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_fopen,  Next: cpg-ref-SP_foreign_stash,  Prev: cpg-ref-SP_flush_output,  Up: cpg-bif

12.3.20 `SP_fopen()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_fopen(
       char const *pathname,
       void *reserved,
       spio_t_bits options,
       SP_stream **pstream);

Opens a file and creates a SICStus stream reading and/or writing to it.

Arguments
---------

PATHNAME
     The path to the file as an encoded string.  It is expanded by
     `SP_expand_file_name()' unless the option
     `SP_FOPEN_OPTION_NOEXPAND' is specified, in which case the path
     must already have been expanded by `SP_expand_file_name()'.

RESERVED
     Reserved, should be `NULL'.

READ_OPTIONS
     The following bits can be set:

    `SP_FOPEN_OPTION_READ'
          Open the file for reading. The file must exist.

    `SP_FOPEN_OPTION_WRITE'
          Open the file for writing. The file is overwritten if it
          exists. The file is created if it does not exist.

    `SP_FOPEN_OPTION_APPEND'
          Open the file for writing but start writing at the end of the
          file if it exists. The file is created if it does not exist.

    `SP_FOPEN_OPTION_BINARY'
          Open the file as a binary (byte) stream.

    `SP_FOPEN_OPTION_TEXT'
          Open the file as a text stream. The default character encoding
          is "Latin 1" (i.e. the 8 bit subset of Unicode). The default
          end of line convention is OS specific.

    `SP_FOPEN_OPTION_AUTOFLUSH'
          After writing to this stream, Prolog predicates will do a
          `flush_output/1'. In essence this ensures that the stream
          behaves as if it were unbuffered.

    `SP_FOPEN_OPTION_INTERACTIVE'
          Treat this stream as an interactive stream. Implies
          SP_CREATE_STREAM_OPTION_AUTOFLUSH.

    `SP_FOPEN_OPTION_NOEXPAND'
          The `pathname' has already been expanded with
          `SP_expand_file_name()' or something similar. This implies
          that `pathname' is an absolute path. If this option is not
          specified, `pathname' is expanded with
          `SP_expand_file_name()' before use.

PSTREAM
     On successful return, `*pstream' will be set to the created stream.

Return Value
------------

On success, `*pstream' will be set to the created stream and
`SPIO_S_NOERR' or some other success code returned.

   On failure, some SPIO failure code will be returned. Error codes with
special meaning for `SP_fopen()':

`SPIO_E_FILE_NOT_FOUND'
     The file does not exist.

`SPIO_E_FILE_ACCESS'
     Insufficient permissions to open or create the file.

`SPIO_E_OPEN_ERROR'
     Generic error during open.

Other error codes may also be returned.

See Also
--------

*Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_foreign_stash,  Next: cpg-ref-SP_fprintf,  Prev: cpg-ref-SP_fopen,  Up: cpg-bif

12.3.21 `SP_foreign_stash()'  "[macro]"
---------------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_foreign_stash();

Obtains a storage location that is unique to the calling foreign
resource.

Return Value
------------

The location, initially set to `NULL'.

Description
-----------

A dynamic foreign resource that is used by multiple SICStus run-times
in the same process may need to maintain a global state that is kept
separate for each SICStus run-time. Each SICStus run-time maintains a
location (containing a `void*') for each foreign resource. A foreign
resource can then access this location to store any data that is
specific to the calling SICStus run-time.

   You can use `SP_foreign_stash()' to get access to a location, where
the foreign resource can store a `void*'. Typically this would be a
pointer to a C struct that holds all information that need to be stored
in global variables. This struct can be allocated and initialized by
the foreign resource init function, it should be deallocated by the
foreign resource deinit function.

   `SP_foreign_stash()' is only available for use in dynamic foreign
resources.

Examples
--------

The value returned by `SP_foreign_stash()' is only valid until the next
SICStus API call. The correct way to initialize the location pointed at
by `SP_foreign_stash()' is therefore:
     struct my_state {...};

     init_my_foreign_resource(...)
     {
        struct my_state *p = SP_malloc(sizeof(struct my_state));
        (*SP_foreign_stash()) = (void*)p;
     }

The following example is incorrect; `SP_malloc()' may be called between
the time `SP_foreign_stash()' is called and the time its return value
is used:
     // WRONG
     (*SP_foreign_stash()) = SP_malloc(sizeof(struct my_state));

See Also
--------

*Note OS Threads::.


File: sicstus.info,  Node: cpg-ref-SP_fprintf,  Next: cpg-ref-SP_free,  Prev: cpg-ref-SP_foreign_stash,  Up: cpg-bif

12.3.22 `SP_fprintf()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_fprintf(
        SP_stream *stream,
        char const *fmt, ...);

Formatted output on the Prolog stream `stream'.

Arguments
---------

STREAM
     The stream. Must be a text stream open for output.

FMT
     The format string. This uses the same syntax as the C library
     `printf' functions.

...
     The data to format.

Return Value
------------

On success, all data has been written and `SPIO_S_NOERR' or some other
success code returned.

   On failure, returns an error code without transferring any data.
Error codes with special meaning for `SP_fprintf()':

`SPIO_E_PARAMETER_ERROR'
     The underlying C library function reported an error while
     formatting the string.

Other error codes may also be returned.

Description
-----------

First the formatting operation will be performed. The resulting string
will be assumed to be in internal encoding, and will then be output
using the `SP_put_encoded_string()' function. This means e.g. that the
`%c' printf conversion specification can only be used for ASCII
characters, and the strings included using a `%s' specification should
also be encoded strings.

See Also
--------

*Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_free,  Next: cpg-ref-SP_get_address,  Prev: cpg-ref-SP_fprintf,  Up: cpg-bif

12.3.23 `SP_free()'
-------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void
     SP_free(void *ptr);

Disposees of the block referenced by `ptr', which must have been
obtained by a call to `SP_malloc()' or `SP_realloc()', and must not
have been released by a call to `SP_free()' or `SP_realloc()'.

Arguments
---------

PTR
     Block to dispose of.

See Also
--------

*Note OS Memory Management::.


File: sicstus.info,  Node: cpg-ref-SP_get_address,  Next: cpg-ref-SP_get_arg,  Prev: cpg-ref-SP_free,  Up: cpg-bif

12.3.24 `SP_get_address()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_address(SP_term_ref term,
                    void **p);

Assigns to `*p' the pointer that corresponds to a Prolog integer

Arguments
---------

TERM
     The SP_term_ref holding the value

P
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_arg,  Next: cpg-ref-SP_get_atom,  Prev: cpg-ref-SP_get_address,  Up: cpg-bif

12.3.25 `SP_get_arg()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_arg(int i,
                SP_term_ref term,
                SP_term_ref arg);

Assigns to `arg' the `i':th argument of a compound term.  This is
similar to calling `arg/3'.

Arguments
---------

I
     The (one-based) argument number

TERM
     The SP_term_ref holding the compound term

ARG
     The SP_term_ref to be assigned

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_atom,  Next: cpg-ref-SP_get_byte,  Prev: cpg-ref-SP_get_arg,  Up: cpg-bif

12.3.26 `SP_get_atom()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_atom(SP_term_ref term,
                 SP_atom *a);

Assigns to `*a' the canonical representation of a Prolog atom

Arguments
---------

TERM
     The SP_term_ref holding the value

A
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_byte,  Next: cpg-ref-SP_get_code,  Prev: cpg-ref-SP_get_atom,  Up: cpg-bif

12.3.27 `SP_get_byte()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_get_byte(
       SP_stream *stream);

Read a byte from a binary stream.

Arguments
---------

STREAM
     The stream. Must be a binary stream open for input.

Return Value
------------

On success, the byte just read will be returned, cast to a
`spio_t_error_code'. The value returned on successful return will never
be negative.

   On failure, returns an error code, recognizable with
`SPIO_FAILED()'. Error codes are always negative.

Description
-----------

Note that `SP_get_byte()' is implemented as a macro and may evaluate
the `stream' argument more than once.

See Also
--------

*Note cpg-ref-SP_get_code::.  *Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_get_code,  Next: cpg-ref-SP_get_current_dir,  Prev: cpg-ref-SP_get_byte,  Up: cpg-bif

12.3.28 `SP_get_code()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_get_code(
       SP_stream *stream);

Read a character code from a text stream.

Arguments
---------

STREAM
     The stream. Must be a text stream open for input.

Return Value
------------

On success, the character just read will be returned, cast to a
`spio_t_error_code'. The value returned on successful return will never
be negative.

   On failure, returns an error code, recognizable with
`SPIO_FAILED()'. Error codes are always negative.

Description
-----------

Note that `SP_get_code()' is implemented as a macro and may evaluate
the `stream' argument more than once.

See Also
--------

*Note cpg-ref-SP_get_byte::.  *Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_get_current_dir,  Next: cpg-ref-SP_get_float,  Prev: cpg-ref-SP_get_code,  Up: cpg-bif

12.3.29 `SP_get_current_dir()'
------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     char *
     SP_get_current_dir(void);

Obtains an encoded string containing the absolute, slash (`/')
terminated, path to the current working directory. The return value is
allocated with `SP_malloc' and should be freed with `SP_free'.

Return Value
------------

The string on success and `NULL' on error.

See Also
--------

*Note cpg-ref-SP_set_current_dir::.  *Note OS File System::.


File: sicstus.info,  Node: cpg-ref-SP_get_float,  Next: cpg-ref-SP_get_functor,  Prev: cpg-ref-SP_get_current_dir,  Up: cpg-bif

12.3.30 `SP_get_float()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_float(SP_term_ref term,
                  double *f);

Assigns to `*f' the float that corresponds to a Prolog number.

Arguments
---------

TERM
     The SP_term_ref holding the value

F
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_functor,  Next: cpg-ref-SP_get_integer,  Prev: cpg-ref-SP_get_float,  Up: cpg-bif

12.3.31 `SP_get_functor()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_functor(SP_term_ref term,
                    SP_atom *name,
                    int *arity);

Assigns to `*name' and `*arity' the canonical representation and arity
of the principal functor of a Prolog compound term.  If the value of
`term' is an atom, then that atom is assigned to `*name' and 0 is
assigned to `*arity'.  This is similar to calling `functor/3' with the
first argument bound to a compound term or an atom and the second and
third arguments unbound.

Arguments
---------

TERM
     The SP_term_ref holding the value

NAME
     The location to assign to the functor name

ARITY
     The location to assign to the functor arity

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_integer,  Next: cpg-ref-SP_get_integer_bytes,  Prev: cpg-ref-SP_get_functor,  Up: cpg-bif

12.3.32 `SP_get_integer()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_integer(SP_term_ref term,
                    long *i);

Assigns to `*i' the integer that corresponds to a Prolog number. The
value must fit in `*i' for the operation to succeed.

Arguments
---------

TERM
     The SP_term_ref holding the value

I
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_integer_bytes,  Next: cpg-ref-SP_get_list,  Prev: cpg-ref-SP_get_integer,  Up: cpg-bif

12.3.33 `SP_get_integer_bytes()'
--------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_integer_bytes(SP_term_ref term,
                          void *buf,
                          size_t *pbuf_size,
                          int native);

Extracts from `term' an an arbitrarily sized integer.

Arguments
---------

TERM
     The SP_term_ref holding the integer

BUF
     The buffer receiving the integer

PBUF_SIZE
     Should point at the size of `buf'

NATIVE
     See the description below

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

Description
-----------

In the following, assume that the integer referred to by `term' requires
a minimum of SIZE bytes to store (in twos-complement representation).

  1. If `term' does not refer to a Prolog integer, zero is returned and
     the other arguments are ignored.

  2. If `*pbuf_size' is less than SIZE, then `*pbuf_size' is updated to
     SIZE and zero is returned. The fact that `*pbuf_size' has changed
     can be used to distinguish insufficient buffer size from other
     possible errors. By calling `SP_get_integer_bytes()' with
     `*pbuf_size' set to zero, you can determine the buffer size
     needed; in this case, `buf' is ignored.

  3. `*pbuf_size' is set to SIZE.

  4. If `native' is zero, `buf' is filled with the twos complement
     representation of the integer, with the least significant bytes
     stored at lower indices in `buf'. Note that all of `buf' is
     filled, even though only SIZE bytes was needed.

  5. If `native' is non-zero, `buf' is assumed to point at a native
     `*pbuf_size' byte integral type. On most platforms, native integer
     sizes of two (16-bit), four (32 bit) and eight (64 bytes) bytes are
     supported. Note that `*pbuf_size == 1', which would correspond to
     `signed char', is _not_ supported with `native'.

  6. If an unsupported size is used with `native', zero is returned.

Examples
--------

The following example gets a Prolog integer into a (presumably 64 bit)
`long long' C integer.
     {
       long long x; // C99, GCC supports this
       size_t sz = sizeof x;
       if (!SP_get_integer_bytes(tr, &x, &sz, 1)) // 1 for native
         .. error handling ..
       .. use x .. // sz may have decreased
     }

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_list,  Next: cpg-ref-SP_get_list_codes,  Prev: cpg-ref-SP_get_integer_bytes,  Up: cpg-bif

12.3.34 `SP_get_list()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_list(SP_term_ref term,
                 SP_term_ref head,
                 SP_term_ref tail);

Assigns to `head' and `tail' the head and tail of a Prolog list.

Arguments
---------

TERM
     The SP_term_ref holding the list

HEAD
     The SP_term_ref to be assigned the head

TAIL
     The SP_term_ref to be assigned the tail

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_list_codes,  Next: cpg-ref-SP_get_list_n_bytes,  Prev: cpg-ref-SP_get_list,  Up: cpg-bif

12.3.35 `SP_get_list_codes()'
-----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_list_codes(SP_term_ref term,
                       char const **s);

Assigns to `*s' a zero-terminated array containing an encoded string
that corresponds to the given Prolog code-list.  The array is subject
to reuse by other support functions, so if the value is going to be
used on a more than temporary basis, it must be moved elsewhere.

Arguments
---------

TERM
     The SP_term_ref holding the code-list

S
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_list_n_bytes,  Next: cpg-ref-SP_get_list_n_codes,  Prev: cpg-ref-SP_get_list_codes,  Up: cpg-bif

12.3.36 `SP_get_list_n_bytes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_list_n_bytes(SP_term_ref term,
                         SP_term_ref tail,
                         size_t n,
                         size_t *w,
                         unsigned char *s);

Copies into the byte array `s' the initial elements of `term', which
should hold a list of integers in the range [0,255], so that at most
`n' bytes are used.  The number of bytes actually written is assigned
to `*w'.  `tail' is set to the remainder of the list.  The array `s'
must have room for at least `n' bytes.

Arguments
---------

TERM
     The SP_term_ref holding the list

TAIL
     The SP_term_ref to be assigned the remainder of the list

N
     Max number of bytes to use

W
     Location to assign to number of bytes actually used

S
     The location to assign to the encoded string

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_list_n_codes,  Next: cpg-ref-SP_get_number_codes,  Prev: cpg-ref-SP_get_list_n_bytes,  Up: cpg-bif

12.3.37 `SP_get_list_n_codes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_list_n_codes(SP_term_ref term,
                         SP_term_ref tail,
                         size_t n,
                         size_t *w,
                         char *s);

Copies into `s' the encoded string representing the character codes in
the initial elements of list `term', so that at most `n' bytes are
used.  The number of bytes actually written is assigned to `*w'.
`tail' is set to the remainder of the list.  The array `s' must have
room for at least `n' bytes.

   *Please note*: The array `s' is never `NUL'-terminated. Any zero
character codes in the list `term' will be converted to the overlong
UTF-8 sequence `0xC0 0x80'.

Arguments
---------

TERM
     The SP_term_ref holding the code-list

TAIL
     The SP_term_ref to be assigned the remainder of the list

N
     Max number of bytes to use

W
     Location to assign to number of bytes actually used

S
     The location to assign to the encoded string

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_number_codes,  Next: cpg-ref-SP_get_stream_counts,  Prev: cpg-ref-SP_get_list_n_codes,  Up: cpg-bif

12.3.38 `SP_get_number_codes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_number_codes(SP_term_ref term,
                         char const **s);

Assigns to `*s' a zero-terminated array of characters corresponding to
the printed representation of a Prolog number.  The array is subject to
reuse by other support functions, so if the value is going to be used
on a more than temporary basis, it must be moved elsewhere.

Arguments
---------

TERM
     The SP_term_ref holding the number

S
     The location to assign to the array

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_stream_counts,  Next: cpg-ref-SP_get_stream_user_data,  Prev: cpg-ref-SP_get_number_codes,  Up: cpg-bif

12.3.39 `SP_get_stream_counts()'
--------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_get_stream_counts(
        SP_stream *stream,
        spio_t_offset *pitem_count,
        spio_t_offset *pnewline_count,
        spio_t_offset *pline_length,
        spio_t_bits options);

Obtain the stream counters.

Arguments
---------

STREAM
     The stream.

ITEM_COUNT
     On success, `*pitem_count' is assigned to the number of items read
     from an input-only or bidirectional stream or with the number of
     items written to a output-only stream.

     For binary streams, an "item" is a byte, for text streams it is a
     character.

PNEWLINE_COUNT
     On success, `*pnewline_count' is assigned to the number of
     newlines read from an input-only or bidirectional text stream or
     with the number of newlines written to a output-only text stream.

     For binary streams, `*pnewline_count' is left undefined.

PLINE_LENGTH
     On success, `*pline_length' is assigned to the number of
     characters read on the current line from an input-only or
     bidirectional text stream or with the characters written on the
     current line to a output-only text stream.

     For binary streams, `*pline_length' is left undefined.

OPTIONS
     The following bits can be set:

    `SP_GET_STREAM_COUNTS_OPTION_READ'
          Return the real input counts of a read-only or bidirectional
          stream.

    `SP_GET_STREAM_COUNTS_OPTION_WRITE'
          Return the real output counts of a write-only stream.

          Currently, the call will fail with `SPIO_E_NOT_SUPPORTED' if
          the stream is bidirectional and
          `SP_GET_STREAM_COUNTS_OPTION_WRITE' is specified. This is
          because there is only one set of counters for each stream and
          these are used to count in the input direction of
          bidirectional streams. This may be changed in a future
          release.

     At most one of `SP_GET_STREAM_COUNTS_OPTION_READ' and
     `SP_GET_STREAM_COUNTS_OPTION_WRITE' can be specified.  If neither
     is specified then default behaviour is as follows
        * If `stream' is interactive, a common set of counts shared by
          all interactive streams is returned.

        * If `stream' is write-only, the output counts are returned.

        * Otherwise, the `stream' is read-only or bidirectional and the
          input counts are returned.

Return Value
------------

On success, `SPIO_S_NOERR' or some other success code is returned.

   On failure, returns a SPIO error code. Error codes with special
meaning for `SP_get_stream_counts()':

`SPIO_E_NOT_READ'
     `SP_GET_STREAM_COUNTS_OPTION_READ' was specified but `stream' is
     not an input stream.

`SPIO_E_NOT_WRITE'
     `SP_GET_STREAM_COUNTS_OPTION_WRITE' was specified but `stream' is
     not an output stream.

`SPIO_E_NOT_SUPPORTED'
     `SP_GET_STREAM_COUNTS_OPTION_WRITE' was specified but `stream' is
     a bidirectional stream.

Description
-----------

There is only one set of counters for each stream. For a bidirectional
stream, these counters only count in the input direction and the output
direction does not affect the counts.

   There is a common set of stream counters for all interactive
streams. By default, these will be returned if `stream' is interactive
instead of the real counts. This behaviour can be changed with the
`options' argument, see above.

See Also
--------

*Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_get_stream_user_data,  Next: cpg-ref-SP_get_string,  Prev: cpg-ref-SP_get_stream_counts,  Up: cpg-bif

12.3.40 `SP_get_stream_user_data()'
-----------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_get_stream_user_data(
        SP_stream *stream,
        void const *user_class,
        void **puser_data);

Get the user data of a user defined stream of a particular class.

Arguments
---------

STREAM
     An arbitrary stream. It is legal, and often useful, to call
     `SP_get_stream_user_data()' on a stream even if it is not known
     whether the stream is in fact a user defined stream of a particular
     class.

PUSER_DATA
     On success, `*puser_data' will be set to the `user_data' value
     used when the stream was created.

Return Value
------------

On success, `*puser_data' is assigned and `SPIO_S_NOERR' or some other
success code is returned.

   On failure, e.g. if the stream was not created with this
`user_class', an error code is returned.

Description
-----------

This function is used in order to recognize streams of a particular
type (or "class"). At the same time as it verifies the type of stream
it also returns the `user_data' which gives the caller a handle to the
internal state of the user defined stream.

   The following sample illustrates how all streams of a particular
class can be found and closed. This function mimics the behavior of the
`SP_FCLOSE_OPTION_USER_STREAMS' option to `SP_fclose', see *Note
cpg-ref-SP_fclose::.

     spio_t_error_code close_streams(void const *user_class, int force)
     {
       spio_t_error_code ecode = SPIO_E_ERROR;
       SP_stream *stream;
       SP_stream *next_stream;
       void *user_data;
       spio_t_bits fclose_options = 0;

       if (force) fclose_options |= SP_FCLOSE_OPTION_FORCE;

       stream = NULL;           /* means start of list of stream */
       do
         {
           /* Note: We need to do this before closing stream */
           ecode = SP_next_stream(stream, &next_stream);
           if (SPIO_FAILED(ecode)) goto barf;

           if (stream != NULL)
             {
               if (SPIO_SUCCEEDED(SP_get_stream_user_data(stream, user_class, &user_data)))
                 {
                   /* This is the right class of stream, close it */
                   ecode = SP_fclose(stream, fclose_options);
                   if (SPIO_FAILED(ecode))
                     {
                       if (!force) goto barf; /* ignore error if force */
                     }
                 }
             }
           stream = next_stream;
         }
       while (stream != NULL);

       return SPIO_S_NOERR;

      barf:
       return ecode;
     }

See Also
--------

*Note cpg-ref-SP_create_stream::.  *Note Defining a New Stream::.


File: sicstus.info,  Node: cpg-ref-SP_get_string,  Next: cpg-ref-SP_initialize,  Prev: cpg-ref-SP_get_stream_user_data,  Up: cpg-bif

12.3.41 `SP_get_string()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_string(SP_term_ref term,
                   char const **s);

Assigns to `*s' a pointer to the encoded string representing the name
of a Prolog atom.  This string must _not_ be modified by the calling
function.

Arguments
---------

TERM
     The SP_term_ref holding the value

S
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_initialize,  Next: cpg-ref-SP_is_atom,  Prev: cpg-ref-SP_get_string,  Up: cpg-bif

12.3.42 `SP_initialize()'  "[macro]"
------------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_initialize(int argc,
     	      char **argv,
     	      void *reserved);

Initializes the Prolog engine.

Arguments
---------

ARGC
     The number of elements of the `argv' vector.

ARGV
     A vector of strings that can be accessed by `prolog_flag(argv,X)'.

RESERVED
     Should be `NULL'

Return Value
------------

`SP_SUCCESS' if initialization was successful.  If initialization was
successful, further calls to `SP_initialize()' will be no-ops (and
return `SP_SUCCESS').

Description
-----------

This must be done before any interface functions are called, except
those annotated as "[preinit]".  The function will allocate data areas
used by Prolog, initialize command line arguments so that they can be
accessed by the `argv' Prolog flag, and load the Runtime Library.

See Also
--------

*Note Initializing the Prolog Engine::.


File: sicstus.info,  Node: cpg-ref-SP_is_atom,  Next: cpg-ref-SP_is_atomic,  Prev: cpg-ref-SP_initialize,  Up: cpg-bif

12.3.43 `SP_is_atom()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_atom(SP_term_ref term);

Determines whether the value of `term' is a Prolog atom.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a atom and 0 otherwise.

See Also
--------

*Note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_atomic,  Next: cpg-ref-SP_is_compound,  Prev: cpg-ref-SP_is_atom,  Up: cpg-bif

12.3.44 `SP_is_atomic()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_atomic(SP_term_ref term);

Determines whether the value of `term' is a Prolog atomic term.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is an atomic term and 0 otherwise.

See Also
--------

*Note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_compound,  Next: cpg-ref-SP_is_float,  Prev: cpg-ref-SP_is_atomic,  Up: cpg-bif

12.3.45 `SP_is_compound()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_compound(SP_term_ref term);

Determines whether the value of `term' is a Prolog compound term.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a compound term and 0 otherwise.

See Also
--------

*Note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_float,  Next: cpg-ref-SP_is_integer,  Prev: cpg-ref-SP_is_compound,  Up: cpg-bif

12.3.46 `SP_is_float()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_float(SP_term_ref term);

Determines whether the value of `term' is a Prolog float.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a float and 0 otherwise.

See Also
--------

*Note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_integer,  Next: cpg-ref-SP_is_list,  Prev: cpg-ref-SP_is_float,  Up: cpg-bif

12.3.47 `SP_is_integer()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_integer(SP_term_ref term);

Determines whether the value of `term' is a Prolog integer.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a integer and 0 otherwise.

See Also
--------

*Note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_list,  Next: cpg-ref-SP_is_number,  Prev: cpg-ref-SP_is_integer,  Up: cpg-bif

12.3.48 `SP_is_list()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_list(SP_term_ref term);

Determines whether the value of `term' is a Prolog list cell, i.e. a
compound term with functor `./2'.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a list and 0 otherwise.

See Also
--------

*Note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_number,  Next: cpg-ref-SP_is_variable,  Prev: cpg-ref-SP_is_list,  Up: cpg-bif

12.3.49 `SP_is_number()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_number(SP_term_ref term);

Determines whether the value of `term' is a Prolog number.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a number and 0 otherwise.

See Also
--------

*Note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_variable,  Next: cpg-ref-SP_load,  Prev: cpg-ref-SP_is_number,  Up: cpg-bif

12.3.50 `SP_is_variable()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_variable(SP_term_ref term);

Determines whether the value of `term' is a Prolog variable.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a variable and 0 otherwise.

See Also
--------

*Note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_load,  Next: cpg-ref-SP_malloc,  Prev: cpg-ref-SP_is_variable,  Up: cpg-bif

12.3.51 `SP_load()'
-------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_load(char const *filename);

Calls `load_files/1'.

Arguments
---------

FILENAME
     The file name, which is treated as a Prolog atom.

Return Value
------------

See `SP_query_cut_fail()'.

See Also
--------

*Note Loading Prolog Code::.


File: sicstus.info,  Node: cpg-ref-SP_malloc,  Next: cpg-ref-SP_mutex_lock,  Prev: cpg-ref-SP_load,  Up: cpg-bif

12.3.52 `SP_malloc()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_malloc(size_t size);

Allocates a block of at least `size' bytes.

Arguments
---------

SIZE
     Requested number of bytes.

Return Value
------------

`NULL' on failure, the pointer otherwise.

See Also
--------

*Note OS Memory Management::.


File: sicstus.info,  Node: cpg-ref-SP_mutex_lock,  Next: cpg-ref-SP_mutex_unlock,  Prev: cpg-ref-SP_malloc,  Up: cpg-bif

12.3.53 `SP_mutex_lock()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     static SP_mutex volatile MUTEX = SP_MUTEX_INITIALIZER;

     int
     SP_mutex_lock(SP_mutex *pmx);

Locks the mutex.

Return Value
------------

Zero on error, non-zero on success.

Examples
--------

     static SP_mutex volatile my_mutex = SP_MUTEX_INITIALIZER;
     // only access this counter with my_mutex locked
     int volatile protected_counter = 0;

     // returns the new value of protected_counter
     int increment_the_counter(void)
     {
       int new_value;

       if(SP_mutex_lock(&my_mutex) == 0) goto error_handling;
       // No other thread can update protected_counter here
       new_value = protected_counter+1;
       protected_counter = new_value;
       if (SP_mutex_unlock(&my_mutex) == 0) goto error_handling;
       return new_value;

     error_handling:
       ...
     }

See Also
--------

*Note OS Threads::.


File: sicstus.info,  Node: cpg-ref-SP_mutex_unlock,  Next: cpg-ref-SP_new_term_ref,  Prev: cpg-ref-SP_mutex_lock,  Up: cpg-bif

12.3.54 `SP_mutex_unlock()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     static SP_mutex volatile MUTEX = SP_MUTEX_INITIALIZER;

     int
     SP_mutex_unlock(SP_mutex *pmx);

Unlocks the mutex.

Return Value
------------

Zero on error, non-zero on success.

Description
-----------

The number of unlocks must match the number of locks and only the
thread that performed the lock can unlock the mutex.

Examples
--------

See the example of `SP_mutex_lock()'.

See Also
--------

*Note OS Threads::.


File: sicstus.info,  Node: cpg-ref-SP_new_term_ref,  Next: cpg-ref-SP_next_solution,  Prev: cpg-ref-SP_mutex_unlock,  Up: cpg-bif

12.3.55 `SP_new_term_ref()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_term_ref
     SP_new_term_ref(void);

Creates a new SP_term_ref.

Return Value
------------

The new SP_term_ref.

See Also
--------

*Note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SP_next_solution,  Next: cpg-ref-SP_next_stream,  Prev: cpg-ref-SP_new_term_ref,  Up: cpg-bif

12.3.56 `SP_next_solution()'
----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_next_solution(SP_qid query);

Look for the next solution to the given query.

Arguments
---------

QUERY
     The query, created by `SP_open_query()'.

Return Value
------------

`SP_SUCCESS' for success, `SP_FAILURE' for failure, `SP_ERROR' if an
error condition occurred.

Description
-----------

This will cause the Prolog engine to backtrack over any current
solution of an open query and look for a new one.  The given argument
must be the innermost query that is still open, i.e. it must not have
been terminated explicitly by `SP_close_query()' or `SP_cut_query()'.
Only when the return value is `SP_SUCCESS' are the values in the query
arguments valid, and will remain so until backtracking into this query
or an enclosing one.

See Also
--------

*Note Finding Multiple Solutions of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_next_stream,  Next: cpg-ref-SP_open_query,  Prev: cpg-ref-SP_next_solution,  Up: cpg-bif

12.3.57 `SP_next_stream()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_next_stream(SP_stream *stream, SP_stream **pnext);

Iterate through all Prolog streams.

Arguments
---------

STREAM
     If this is `NULL' then `*pnext' is set to the first stream in the
     list of streams. If this is non-`NULL' then the stream following
     STREAM in the list of streams is returned in `*pnext'.

PNEXT
     The returned stream is returned in `*pnext'.

Return Value
------------

On success, `*pnext' is assigned, and `SPIO_S_NOERR' or some other
success code is returned. You should use the `SPIO_FAILED()' macro to
determine if the return value signifies failure or success.

   When `stream' is the last stream `*pnext' is set to `NULL'.

   This function can be used to iterate over all Prolog streams. One way
to use this is together with `SP_get_stream_user_data' to find all
currently open user defined streams of a particular type.

See Also
--------

*Note SICStus Streams::.


File: sicstus.info,  Node: cpg-ref-SP_open_query,  Next: cpg-ref-SP_pred,  Prev: cpg-ref-SP_next_stream,  Up: cpg-bif

12.3.58 `SP_open_query()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_qid
     SP_open_query(SP_pred_ref predicate,
                   SP_term_ref arg1,
                   ...);

Sets up a query for use by `SP_next_solution()', `SP_close_query()',
`SP_cut_query()'.

Arguments
---------

PREDICATE
     The predicate to call.

ARG1...
     The arguments to pass.

Return Value
------------

The query identifier if successful, otherwise 0,

Description
-----------

Note that if a new query is opened while another is already open, the
new query must be terminated before exploring the solutions of the old
one.  That is, queries must be strictly nested.

See Also
--------

*Note Finding Multiple Solutions of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_pred,  Next: cpg-ref-SP_predicate,  Prev: cpg-ref-SP_open_query,  Up: cpg-bif

12.3.59 `SP_pred()'
-------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_pred_ref
     SP_pred(SP_atom name_atom,
     	long arity,
     	SP_atom module_atom);

Returns a pointer to the predicate definition.

Arguments
---------

NAME_ATOM
     Predicate name.

ARITY
     Arity.

MODULE_ATOM
     Module name.

Return Value
------------

The reference if the predicate is found, `NULL' otherwise with error
code `PRED_NOT_FOUND'.

Description
-----------

Faster than `SP_predicate()'.

See Also
--------

*Note Calling Prolog from C::.


File: sicstus.info,  Node: cpg-ref-SP_predicate,  Next: cpg-ref-SP_printf,  Prev: cpg-ref-SP_pred,  Up: cpg-bif

12.3.60 `SP_predicate()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_pred_ref
     SP_predicate(char *name_string,
     	     long arity,
     	     char *module_string);

Returns a pointer to the predicate definition.

Arguments
---------

NAME_STRING
     Predicate name.

ARITY
     Arity.

MODULE_STRING
     Module name, optional. `NULL' and `""' (the empty string) both
     denote the type-in module (*note ref-mod-tyi::).

Return Value
------------

The reference if the predicate is found, `NULL' otherwise with error
code `PRED_NOT_FOUND' or, if one of the string arguments are malformed,
`INV_STRING'.

Description
-----------

Slower than `SP_pred()'.

See Also
--------

*Note Calling Prolog from C::.


File: sicstus.info,  Node: cpg-ref-SP_printf,  Next: cpg-ref-SP_put_address,  Prev: cpg-ref-SP_predicate,  Up: cpg-bif

12.3.61 `SP_printf()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_printf(
        char const *fmt,
        ...);

Same as `SP_fprintf(SP_stdout, fmt, ...)'.

See Also
--------

*Note cpg-ref-SP_fprintf::.


File: sicstus.info,  Node: cpg-ref-SP_put_address,  Next: cpg-ref-SP_put_atom,  Prev: cpg-ref-SP_printf,  Up: cpg-bif

12.3.62 `SP_put_address()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_address(SP_term_ref term,
                    void *pointer);

Assigns to `term' a reference to a Prolog integer representing a
pointer.

Arguments
---------

TERM
     The SP_term_ref to be assigned

POINTER
     The pointer

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_atom,  Next: cpg-ref-SP_put_byte,  Prev: cpg-ref-SP_put_address,  Up: cpg-bif

12.3.63 `SP_put_atom()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_atom(SP_term_ref term,
                 SP_atom atom);

Assigns to `term' a reference to a Prolog atom.

Arguments
---------

TERM
     The SP_term_ref to be assigned

ATOM
     The atom

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_byte,  Next: cpg-ref-SP_put_bytes,  Prev: cpg-ref-SP_put_atom,  Up: cpg-bif

12.3.64 `SP_put_byte()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_put_byte(
       SP_stream *stream,
       int item);

Write a byte to a binary stream.

Arguments
---------

STREAM
     The stream. Must be a binary stream open for output.

Return Value
------------

On success, the written byte will be returned, cast to a
`spio_t_error_code'. The value returned on successful return will never
be negative.

   On failure, returns an error code, recognizable with
`SPIO_FAILED()'. Error codes are always negative.

Description
-----------

Note that `SP_put_byte()' is implemented as a macro and may evaluate
the arguments more than once. For the same reason, no error checking is
performed on the arguments.

See Also
--------

*Note cpg-ref-SP_put_code::.  *Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_put_bytes,  Next: cpg-ref-SP_put_code,  Prev: cpg-ref-SP_put_byte,  Up: cpg-bif

12.3.65 `SP_put_bytes()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_put_bytes(
       SP_stream *stream,
       spio_t_uint8 const *bytes,
       size_t byte_count,
       spio_t_bits options);

Write several bytes to a binary stream.

Arguments
---------

STREAM
     The stream. Must be a binary stream open for output.

BYTES
     A pointer to the data to write.

BYTE_COUNT
     The number of bytes to write.

OPTIONS
     The following bits can be set:

    `SP_PUT_BYTES_OPTION_NONBLOCKING'
          Write the bytes without blocking.

Return Value
------------

On success, all data has been written and `SPIO_S_NOERR' or some other
success code returned.

   On failure, returns an error code without transferring any data.
Error codes with special meaning for `SP_put_bytes()':

`SPIO_E_WOULD_BLOCK'
     `SP_PUT_BYTES_OPTION_NONBLOCKING' was set but the operation would
     block.

Other error codes may also be returned.

See Also
--------

*Note cpg-ref-SP_put_byte::.  *Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_put_code,  Next: cpg-ref-SP_put_codes,  Prev: cpg-ref-SP_put_bytes,  Up: cpg-bif

12.3.66 `SP_put_code()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_put_code(
       SP_stream *stream,
       int item);

Write a character code to a text stream.

Arguments
---------

STREAM
     The stream. Must be a text stream open for output.

Return Value
------------

On success, the written character will be returned, cast to a
`spio_t_error_code'. The value returned on successful return will never
be negative.

   On failure, returns an error code, recognizable with
`SPIO_FAILED()'. Error codes are always negative.

Description
-----------

Note that `SP_put_code()' is implemented as a macro and may evaluate
the arguments more than once. For the same reason, no error checking is
performed on the arguments.

See Also
--------

*Note cpg-ref-SP_put_byte::.  *Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_put_codes,  Next: cpg-ref-SP_put_encoded_string,  Prev: cpg-ref-SP_put_code,  Up: cpg-bif

12.3.67 `SP_put_codes()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_put_codes(
       SP_stream *stream,
       spio_t_wchar const *codes,
       size_t code_count,
       spio_t_bits options);

Write several codes to a text stream.

Arguments
---------

STREAM
     The stream. Must be a text stream open for output.

CODES
     A pointer to the data to write.

CODE_COUNT
     The number of character codes to write. Note that this is the
     number of character codes, not the number of bytes.

OPTIONS
     The following bits can be set:

    `SP_PUT_CODES_OPTION_NONBLOCKING'
          Write the codes without blocking.

Return Value
------------

On success, all data has been written and `SPIO_S_NOERR' or some other
success code returned.

   On failure, returns an error code without transferring any data.
Error codes with special meaning for `SP_put_codes()':

`SPIO_E_WOULD_BLOCK'
     `SP_PUT_CODES_OPTION_NONBLOCKING' was set but the operation would
     block.

Other error codes may also be returned.

See Also
--------

*Note cpg-ref-SP_put_code::.  *Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_put_encoded_string,  Next: cpg-ref-SP_put_float,  Prev: cpg-ref-SP_put_codes,  Up: cpg-bif

12.3.68 `SP_put_encoded_string()'
---------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_put_encoded_string(
       SP_stream *stream,
       spio_t_wchar const *encoded_string,
       spio_t_bits options);

Write an encoded string to a text stream.

Arguments
---------

STREAM
     The stream. Must be a text stream open for output.

ENCODED_STRING
     An encoded string to write.

OPTIONS
     The following bits can be set:

    `SP_PUT_ENCODED_STRING_OPTION_NONBLOCKING'
          Write the string without blocking.

Return Value
------------

On success, all data has been written and `SPIO_S_NOERR' or some other
success code returned.

   On failure, returns an error code without transferring any data.
Error codes with special meaning for `SP_put_encoded_string()':

`SPIO_E_WOULD_BLOCK'
     `SP_PUT_ENCODED_STRING_OPTION_NONBLOCKING' was set but the
     operation would block.

Other error codes may also be returned.

See Also
--------

*Note cpg-ref-SP_put_codes::.  *Note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_put_float,  Next: cpg-ref-SP_put_functor,  Prev: cpg-ref-SP_put_encoded_string,  Up: cpg-bif

12.3.69 `SP_put_float()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_float(SP_term_ref term,
                  double f);

Assigns to `term' a reference to a float.

Arguments
---------

TERM
     The SP_term_ref to be assigned

F
     The float

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_functor,  Next: cpg-ref-SP_put_integer,  Prev: cpg-ref-SP_put_float,  Up: cpg-bif

12.3.70 `SP_put_functor()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_functor(SP_term_ref term,
                    SP_atom name,
                    int arity);

Assigns to `term' a reference to a compound term with all the arguments
unbound variables.  If `arity' is 0, assigns the Prolog atom whose
canonical representation is `name'.  This is similar to calling
`functor/3' with the first argument unbound and the second and third
arguments bound to an atom and an integer, respectively.

Arguments
---------

TERM
     The SP_term_ref to be assigned

NAME
     The name of the functor

ARITY
     The arity of the functor

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_integer,  Next: cpg-ref-SP_put_integer_bytes,  Prev: cpg-ref-SP_put_functor,  Up: cpg-bif

12.3.71 `SP_put_integer()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_integer(SP_term_ref term,
                    long i);

Assigns to `term' a reference to an integer.

Arguments
---------

TERM
     The SP_term_ref to be assigned

I
     The integer

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_integer_bytes,  Next: cpg-ref-SP_put_list,  Prev: cpg-ref-SP_put_integer,  Up: cpg-bif

12.3.72 `SP_put_integer_bytes()'
--------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_integer_bytes(SP_term_ref term,
                          void *buf,
                          size_t buf_size,
                          int native);

Assigns to `term' a reference to an arbitrarily sized integer.

Arguments
---------

TERM
     The SP_term_ref to be assigned

BUF
        * If `native' is zero, `buf' consists of the `buf_size' bytes
          of the twos complement representation of the integer. Less
          significant bytes are at lower indices.

        * If `native' is nonzero, `buf' is a pointer to the native
          `buf_size' bytes integer type.

BUF_SIZE
     The size of `buf'

NATIVE
     See above.  Supported native sizes typically include two, four and
     eight (64bit) bytes.

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_list,  Next: cpg-ref-SP_put_list_codes,  Prev: cpg-ref-SP_put_integer_bytes,  Up: cpg-bif

12.3.73 `SP_put_list()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_list(SP_term_ref term);

Assigns to `term' a reference to a Prolog list whose head and tail are
both unbound variables.

Arguments
---------

TERM
     The SP_term_ref to be assigned

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_list_codes,  Next: cpg-ref-SP_put_list_n_bytes,  Prev: cpg-ref-SP_put_list,  Up: cpg-bif

12.3.74 `SP_put_list_codes()'
-----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_list_codes(SP_term_ref term,
                       SP_term_ref tail,
                       char const *s);

Assigns to `term' a Prolog code-list represented by the encoded string
`s', prepended to the value of `tail'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

TAIL
     The tail of the code-list

S
     The string to convert

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_list_n_bytes,  Next: cpg-ref-SP_put_list_n_codes,  Prev: cpg-ref-SP_put_list_codes,  Up: cpg-bif

12.3.75 `SP_put_list_n_bytes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_list_n_bytes(SP_term_ref term,
                         SP_term_ref tail,
                         size_t n,
                         unsigned char const *s);

Assigns to `term' a list of integers represented by the first `n'
elements of the byte array `s', prepended to the value of `tail'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

TAIL
     The tail of the list

N
     The number of bytes of `s' to convert

S
     The byte array to convert

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_list_n_codes,  Next: cpg-ref-SP_put_number_codes,  Prev: cpg-ref-SP_put_list_n_bytes,  Up: cpg-bif

12.3.76 `SP_put_list_n_codes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_list_n_codes(SP_term_ref term,
                         SP_term_ref tail,
                         size_t n,
                         char const *s);

Assigns to `term' a Prolog code-list represented by the first `n'
*bytes* of the encoded string `s', prepended to the value of `tail'.

   *Please note*: Some characters may be encoded using more than one
byte so the number of characters may be less than `n'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

TAIL
     The tail of the code-list

N
     The number of character codes of `s' to convert

S
     The string to convert

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_number_codes,  Next: cpg-ref-SP_put_string,  Prev: cpg-ref-SP_put_list_n_codes,  Up: cpg-bif

12.3.77 `SP_put_number_codes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_number_codes(SP_term_ref term,
                         char const *s);

Assigns to `term' a reference to a Prolog number obtained by parsing
`s'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

S
     The string to parse

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_string,  Next: cpg-ref-SP_put_term,  Prev: cpg-ref-SP_put_number_codes,  Up: cpg-bif

12.3.78 `SP_put_string()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_string(SP_term_ref term,
                   char const *string);

Assigns to `term' a reference to a Prolog atom.

Arguments
---------

TERM
     The SP_term_ref to be assigned

STRING
     The string corresponding to the atom

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_term,  Next: cpg-ref-SP_put_variable,  Prev: cpg-ref-SP_put_string,  Up: cpg-bif

12.3.79 `SP_put_term()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_term(SP_term_ref to,
                 SP_term_ref from);

Assigns to `to' the value of `from'.

Arguments
---------

TO
     The SP_term_ref to be assigned

FROM
     The SP_term_ref whose value is accessed

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_variable,  Next: cpg-ref-SP_query,  Prev: cpg-ref-SP_put_term,  Up: cpg-bif

12.3.80 `SP_put_variable()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_variable(SP_term_ref term);

Assigns to `term' a reference to a new unbound Prolog variable.

Arguments
---------

TERM
     The SP_term_ref to be assigned

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*Note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_query,  Next: cpg-ref-SP_query_cut_fail,  Prev: cpg-ref-SP_put_variable,  Up: cpg-bif

12.3.81 `SP_query()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_query(SP_pred_ref predicate,
              SP_term_ref arg1,
              ...);

Calls a predicate, committing to its first solution.

Arguments
---------

PREDICATE
     The predicate to call.

ARG1...
     The arguments to pass.

Return Value
------------

`SP_SUCCESS' if the goal succeeded, `SP_FAILURE' if it failed, and
`SP_ERROR' if an error condition occurred.

Description
-----------

Use this if you are only interested in the first solution is to call
the function `SP_query()'.  It will create a goal from the predicate
definition and the arguments, call it, and commit to the first solution
found, if any.  If it returns `SP_SUCCESS', values in the query
arguments valid, and will remain so until backtracking into any
enclosing query.

See Also
--------

*Note Finding One Solution of a Call::.

