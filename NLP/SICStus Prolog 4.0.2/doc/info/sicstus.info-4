This is info/sicstus.info, produced by makeinfo version 4.8 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 6 November 2007.


File: sicstus.info,  Node: lib-lists,  Next: lib-logarr,  Prev: lib-heaps,  Up: The Prolog Library

10.11 List Operations--`library(lists)'
=======================================

This library module provides operations on lists.  Exported predicates:

`select(?ELEMENT, ?SET, ?RESIDUE)'
     is true when SET is a list, ELEMENT occurs in SET, and RESIDUE is
     everything in SET except ELEMENT (things stay in the same order).

`selectchk(+ELEMENT, +SET, ?RESIDUE)'
     is to `select/3' what `memberchk/2' is to `member/2'.  That is, it
     locates the first occurrence of ELEMENT in SET, and deletes it,
     giving RESIDUE.  It is steadfast in RESIDUE.

`append(+LISTOFLISTS, -LIST)'
     is true when LISTOFLISTS is a list [L1,...,LN] of lists, LIST is a
     list, and appending L1, ..., LN together yields LIST.  The
     LISTOFLISTS _must_ be a proper list.  Additionally, either LIST
     should be a proper list, or each of L1, ..., LN should be a proper
     list.  The behaviour on non-lists is undefined.  LISTOFLISTS must
     be proper because for any given solution, infinitely many more can
     be obtained by inserting nils ([]) into LISTOFLIST.

`append(?PREFIX, ?TAIL1, ?LIST1, ?TAIL2, ?LIST2)'
     is true when `append(PREFIX, TAIL1, LIST1)' and `append(PREFIX,
     TAIL2, LIST2)' are both true.  You could call `append/3' twice,
     but that is order- dependent.  This will terminate if PREFIX is a
     proper list or if either LIST1 or LIST2 is a proper list.

`correspond(?X, ?XLIST, ?YLIST, ?Y)'
     is true when XLIST and YLIST are lists, X is an element of XLIST,
     Y is an element of YLIST, and X and Y are in similar places in
     their lists.  No relation is implied between other elements of
     XLIST and YLIST.  For a similar predicate without the cut, see
     `select/4'.

`delete(+LIST, +KILL, -RESIDUE)'
     is true when LIST is a list, in which KILL may or may not occur,
     and RESIDUE is a copy of LIST with all elements equal to KILL
     deleted.  To extract a single copy of KILL, use `select(KILL,
     LIST, RESIDUE)'.  If LIST is not proper, `delete/3' will _fail_.
     KILL and the elements of LIST should be sufficiently instantiated
     for `\=' to be sound.

`delete(+LIST, +KILL, +COUNT, -RESIDUE)'
     is true when LIST is a list, in which KILL may or may not occur,
     and COUNT is a non-negative integer, and RESIDUE is a copy of LIST
     with the first COUNT elements equal to KILL deleted.  If LIST has
     fewer than COUNT elements equal to COUNT, all of them are deleted.
     If LIST is not proper, `delete/4' may _fail_.  KILL and the
     elements of LIST should be sufficiently instantiated for `\=' to
     be sound.

`is_list(+LIST)'
     succeeds when LIST is a proper list.  That is, LIST is nil ([]) or
     a cons cell ([HEAD|TAIL]) whose TAIL is a proper list.  A
     variable, or a list whose final tail is a variable, will fail this
     test.

`keys_and_values(?[K1-V1,...,KN-VN], ?[K1,...,KN], ?[V1,...,VN])'
     is true when its arguments look like the picture above.  It is
     meant for splitting a list of KEY-VALUE pairs (such as `keysort/2'
     wants and produces) into separate lists of KEYS and of VALUES.  It
     may just as well be used for building a list of pairs from a pair
     of lists.   In fact one usually wants just the keys or just the
     values, but you can supply `_' as the other argument.   For
     example, suppose you wanted to sort a list without having
     duplicates removed.  You could do
              keys_and_values(RawPairs, RawKeys, _),
              keysort(RawPairs, OrdPairs),
              keys_and_values(OrdPairs, OrdKeys, _).

`last(+LIST, -LAST)'
     is true when LIST is a LIST and LAST is its last element.  This
     could be defined as
              last(L, X) :- append(_, [X], L).

`nextto(?X, ?Y, +LIST)'
     is true when X and Y appear side-by-side in LIST.  It could be
     written as
              nextto(X, Y, List) :- append(_, [X,Y|_], List).
     It may be used to enumerate successive pairs from the list.  LIST
     should be proper, otherwise `nextto/3' will generate it.

`nth0(?N, ?LIST, ?ELEM)'
     is true when ELEM is the Nth member of LIST, counting the first as
     element 0.  That is, throw away the first N elements and unify ELEM
     with the next.  E.g. `nth0(0, [H|T], H)'.  Either N should be an
     integer, or LIST should be proper.

`nth1(?N, ?LIST, ?ELEMENT)'
     is true when ELEM is the NTH member of LIST, counting the first as
     element 1.  That is, throw away the first N-1 elements and unify
     ELEM with the next element (the NTH).  E.g. `nth1(1, [H|T], H)'.
     This is just like `nth0/3' except that it counts from 1 instead of
     0.  Either N should be an integer, or LIST should be proper.

`nth0(?N, ?LIST, ?ELEM, ?REST)'
     unifies ELEM with the NTH element of LIST, counting from 0, and
     REST with the other elements.  It can be used to select the NTH
     element of LIST (yielding ELEM and REST), or to insert ELEM
     _before_ the NTH (counting from 0) element of REST, when it yields
     LIST, e.g.  `nth0(2, List, c, [a,b,d,e])' unifies LIST with
     `[a,b,c,d,e]'.  This can be seen as inserting ELEM _after_ the NTH
     element of REST if you count from 1 rather than 0.  Either N
     should be an integer, or LIST or REST should be proper.

`nth1(?N, ?LIST, ?ELEM, ?REST)'
     unifies ELEM with the NTH element of LIST, counting from 1, and
     REST with the other elements.  It can be used to select the NTH
     element of LIST (yielding ELEM and REST), or to insert ELEM
     _before_ the NTH (counting from 1) element of REST, when it yields
     LIST, e.g.  `nth1(2, List, b, [a,c,d,e])' unifies LIST with
     `[a,b,c,d,e]'.  Either N should be an integer, or LIST or REST
     should be proper.

`one_longer(?LONGER, ?SHORTER)'
     is true when
              length(Longer,N), length(Shorter,M), succ(M,N)
     for some integers M, N.  It was written to make `{nth0,nth1}/4'
     able to find the index, just as `same_length/2' is useful for
     making things invertible.

`perm(+LIST, ?PERM)'
     is true when LIST and PERM are permutations of each other.  The
     main use of `perm/2' is to generate permutations.  You should not
     use this predicate in new programs; use `permutation/2' instead.
     LIST must be a proper list.  PERM may be partly instantiated.

`permutation(?LIST, ?PERM)'
     is true when LIST and PERM are permuations of each other.  Unlike
     `perm/2', it will work even when LIST is not a proper list.  It
     even acts in a marginally sensible way when PERM isn't proper
     either, but it will still backtrack forever.  Be careful: this is
     quite efficient, but the number of permutations of an N-element
     list is N!, and even for a 7-element list that is 5040.

`perm2(?A,?B, ?C,?D)'
     is true when {A,B} = {C,D}.  It is very useful for writing pattern
     matchers over commutative operators.

`proper_length(+LIST, ?LENGTH)'
     succeeds when LIST is a proper list, binding LENGTH to its length.

`remove_dups(+LIST, ?PRUNED)'
     removes duplicated elements from LIST, which should be a proper
     list.  If LIST has non-ground elements, PRUNED may contain
     elements which unify; two elements will remain separate iff there
     is a substitution which makes them different.  E.g. [X,X] -> [X]
     but [X,Y] -> [X,Y].

`reverse(?LIST, ?REVERSED)'
     is true when LIST and REVERSED are lists with the same elements
     but in opposite orders.  Either LIST or REVERSED should be a
     proper list: given either argument the other can be found.  If
     both are incomplete `reverse/2' can backtrack forever trying ever
     longer lists.

`rev(+LIST, ?REVERSED)'
     is a version of `reverse/2' which only works one way around.  Its
     LIST argument must be a proper list whatever REVERSED is.  You
     should use `reverse/2' in new programs, though `rev/2' is faster
     when it is safe to use it.

`same_length(?LIST1, ?LIST2)'
     is true when LIST1 and LIST2 are both lists and have the same
     number of elements.  No relation between the values of their
     elements is implied.  It may be used to generate either list given
     the other, or indeed to generate two lists of the same length, in
     which case the arguments will be bound to lists of length 0, 1, 2,
     ...

`same_length(?LIST1, ?LIST2, ?LENGTH)'
     is true when LIST1 and LIST2 are both lists, LENGTH is a
     non-negative integer, and both LIST1 and LIST2 have exactly LENGTH
     elements.  No relation between the elements of the lists is
     implied.  If LENGTH is instantiated, or if either LIST1 or LIST2
     is bound to a proper list, same_length is determinate and
     terminating.

`select(?X, ?XLIST, ?Y, ?YLIST)'
     is true when X is the KTH member of XLIST and Y the KTH element of
     YLIST for some K, and apart from that XLIST and YLIST are the
     same.  You can use it to replace X by Y or vice versa.  Either
     XLIST or YLIST should be a proper list.

`selectchk(?X, +XLIST, ?Y, +YLIST)'
     is to `select/4' as `memberhck/2' is to `member/2'.  That is, it
     finds the first K such that X unifies with the KTH element of
     XLIST and Y with the KTH element of YLIST, and it commits to the
     bindings thus found.  If you have KEYS and VALUES in "parallel"
     lists, you can use this to find the VALUE associated with a
     particular KEY (much better methods exist).  Except for argument
     order, this is identical to `correspond/4', but `selectchk/4' is a
     member of a coherent family.  Note that the arguments are like the
     arguments of `memberchk/2', twice.

`shorter_list(?SHORT, ?LONG)'
     is true when SHORT is a list is strictly shorter than LONG.  LONG
     doesn't have to be a proper list provided it is long enough.  This
     can be used to generate lists shorter than LONG, lengths 0, 1, 2...
     will be tried, but backtracking will terminate with a list that is
     one element shorter than LONG.  It cannot be used to generate lists
     longer than SHORT, because it doesn't look at all the elements of
     the longer list.

`subseq(?SEQUENCE, ?SUBSEQUENCE, ?COMPLEMENT)'
     is true when SUBSEQUENCE and COMPLEMENT are both subsequences of
     the list SEQUENCE (the order of corresponding elements being
     preserved) and every element of SEQUENCE which is not in
     SUBSEQUENCE is in the COMPLEMENT and vice versa.  That is,
     `length(Sequence) = length(SubSequence)+length(Complement)', e.g.
     `subseq([1,2,3,4], [1,3,4], [2])'.  This was written to generate
     subsets and their complements together, but can also be used to
     interleave two lists in all possible ways.

`subseq0(+SEQUENCE, ?SUBSEQUENCE)'
     is true when SUBSEQUENCE is a subsequence of SEQUENCE, but may be
     SEQUENCE itself.   Thus `subseq0([a,b], [a,b])' is true as well as
     `subseq0([a,b], [a])'.  SEQUENCE must be a proper list, since
     there are infinitely many lists with a given SUBSEQUENCE.
          ?- setof(X, subseq0([a,b,c],X), Xs).
          Xs = [[],[a],[a,b],[a,b,c],[a,c],[b],[b,c],[c]]
          ?- bagof(X, subseq0([a,b,c,d],X), Xs).
          Xs = [[a,b,c,d],[b,c,d],[c,d],[d],[],[c],[b,d],[b],[b,c],[a,c,d],
                [a,d],[a],[a,c],[a,b,d],[a,b],[a,b,c]]

`subseq1(+SEQUENCE, ?SUBSEQUENCE)'
     is true when SUBSEQUENCE is a proper subsequence of SEQUENCE, that
     is it contains at least one element less.  SEQUENCE must be a
     proper list, as SUBSEQUENCE does not determine SEQUENCE.

`sumlist(+NUMBERS, ?TOTAL)'
     is true when NUMBERS is a list of integers, and TOTAL is their sum.

`transpose(?X, ?Y)'
     is true when X is a list of the form
     [[X11,...,X1M],...,[XN1,...,XNM]] and Y is its transpose, that is,
     Y = [[X11,...,XN1],...,[X1M,...,XNM]] We insist that both lists
     should have this rectangular form, so that the predicate can be
     invertible.  For the same reason, we reject empty arrays with M =
     0 or N = 0.

`append_length(?PREFIX, ?SUFFIX, ?LIST, ?LENGTH)'
     is true when
              append(Prefix, Suffix, List), length(Prefix, Length).
     The normal use of this is to split a LIST into a PREFIX of a given
     LENGTH and the corresponding SUFFIX, but it can be used any way
     around provided that     LENGTH is instantiated, or     PREFIX is
     a proper list, or     LIST   is a proper list.

`append_length(?SUFFIX, ?LIST, ?LENGTH)'
     is true when there exists a list PREFIX such that
     `append_length(PREFIX, SUFFIX, LIST, LENGTH)' is true.  When you
     don't want to know the PREFIX, you should call this predicate,
     because it doesn't construct the PREFIX argument, which
     `append_length/4' would do.

`prefix_length(?LIST, ?PREFIX, ?LENGTH)'
     is true when
              prefix(List, Prefix) &
              length(Prefix, Length).
     The normal use of this is to find the first LENGTH elements of a
     given LIST, but it can be used any way around provided that
     LENGTH is instantiated, or     PREFIX is a proper list, or
     LIST   is a proper list.  It is identical in effect to
     `append_length(Prefix, _, List, Length)'.

`proper_prefix_length(?LIST, ?PREFIX, ?LENGTH)'
     is true when
              proper_prefix(List, Prefix) &
              length(Prefix, Length).
     The normal use of this is to find the first LENGTH elements of a
     given LIST, but it can be used any way around provided that
     LENGTH is instantiated, or     PREFIX is a proper list, or
     LIST   is a proper list.  It is logically equivalent to
     `prefix(Prefix, List, Length), Length > 0'.

`suffix_length(+LIST, ?SUFFIX, ?LENGTH)'
     is true when
              suffix(List, Suffix) &
              length(Suffix, Length).
     The normal use of this is to return the last LENGTH elements of a
     given LIST.  For this to be sure of termination,     LIST must be
     a proper list.  If LENGTH is instantiated or SUFFIX is a proper
     list, this predicate is determinate.

`proper_suffix_length(+LIST, ?SUFFIX, ?LENGTH)'
     is true when
              proper_suffix(List, Suffix) &
              length(Suffix, Length).
     The normal use of this is to return the last LENGTH elements of a
     given LIST.  For this to be sure of termination,     LIST must be
     a proper list.  If LENGTH is instantiated or SUFFIX is a proper
     list, this predicate is determinate.

`rotate_list(+AMOUNT, ?LIST, ?ROTATED)'
     is true when LIST and ROTATED are lists of the same length, and
              append(Prefix, Suffix, List) &
              append(Suffix, Prefix, Rotated) &
              (   Amount >= 0 & length(Prefix, Amount)
              |   Amount =< 0 & length(Suffix, Amount)
              ).
     That is to say, LIST rotated LEFT by AMOUNT is ROTATED.   AMOUNT
     must already be instantiated.  As it is a strict input,  it must
     come first.

`rotate_list(?LIST, ?ROTATED)'
     is true when `rotate_list(1, List, Rotated)', but is a bit less
     heavy-handed.  `rotate_list(X, Y)' rotates X left  one place
     yielding Y.  `rotate_list(Y, X)' rotates X right one place
     yielding Y.  Either LIST or ROTATED should be a proper list.

`sublist(+WHOLE, ?PART, ?BEFORE, ?LENGTH, ?AFTER)'
     is true when
        * WHOLE is a list - it must be proper already

        * PART  is a list

        * WHOLE = ALPHA || PART || OMEGA

        * `length(ALPHA, BEFORE)'

        * `length(PART,  LENGTH)'

        * `length(OMEGA, AFTER)'

`cons(?HEAD, ?TAIL, ?LIST)'
     is true when HEAD is the head of LIST and TAIL is its tail.  i.e.
     `append([Head], Tail, List)'.   No restrictions.

`last(?FORE, ?LAST, ?LIST)'
     is true when LAST is the last element of LIST and FORE is the list
     of preceding elements, e.g. `append(Fore, [Last], List)'.  FORE or
     LAST should be proper.  It is expected that LIST will be proper
     and FORE unbound, but it will work in reverse too.

`head(?LIST, ?HEAD)'
     is true when LIST is a non-empty list and HEAD is its head.  A
     list has only one head.  No restrictions.

`tail(?LIST, ?TAIL)'
     is true when LIST is a non-empty list and TAIL is its tail.  A
     list has only one tail.  No restrictions.

`prefix(?LIST, ?PREFIX)'
     is true when LIST and PREFIX are lists and PREFIX is a prefix of
     LIST.  It terminates if either argument is proper, and has at most
     N+1 solutions.  Prefixes are enumerated in ascending order of
     length.

`proper_prefix(?LIST, ?PREFIX)'
     is true when LIST and PREFIX are lists and PREFIX is a proper
     prefix of LIST.  That is, PREFIX is a prefix of LIST but is not
     LIST itself.  It terminates if either argument is proper, and has
     at most N solutions.  Prefixes are enumerated in ascending order
     of length.

`suffix(?LIST, ?SUFFIX)'
     is true when LIST and SUFFIX are lists and SUFFIX is a suffix of
     LIST.  It terminates only if LIST is proper, and has at most N+1
     solutions.  Suffixes are enumerated in descending order of length.

`proper_suffix(?LIST, ?SUFFIX)'
     is true when LIST and SUFFIX are lists and SUFFIX is a proper
     suffix of LIST.  That is, SUFFIX is a suffix of LIST but is not
     LIST itself.  It terminates only if LIST is proper, and has at
     most N solutions.  Suffixes are enumerated in descending order of
     length.

`segment(?LIST, ?SEGMENT)'
     is true when LIST and SEGMENT are lists and SEGMENT is a segment
     of LIST.  That is, LIST = _ <> SEGMENT <> _ .  Terminates only if
     LIST is proper.  If SEGMENT is proper it enumerates all solutions.
     If neither argument is proper, it would have to diagonalise to
     find all solutions, but it doesn't, so it is then incomplete.  If
     SEGMENT is proper, it has at most N+1 solutions.  Otherwise, it
     has at most (1/2)(N+1)(N+2) solutions.

`proper_segment(?LIST, ?SEGMENT)'
     is true when LIST and SEGMENT are lists and SEGMENT is a proper
     segment of LIST.  It terminates only if LIST is proper.  The only
     solution of `segment/2' which is not a solution of
     `proper_segment/2' is `segment(List,List)'.  So `proper_segment/2'
     has one solution fewer.

`cumlist(:PRED, +[X1,...,XN], ?V0, ?[V1,...,VN])'
     maps a ternary predicate PRED down the list [X1,...,XN] just as
     `scanlist/4' does, and returns a list of the results.  It
     terminates when either list runs out.  If PRED is bidirectional,
     it may be used to derive [X1...XN] from V0 and [V1...VN], e.g.
     `cumlist(plus, [1,2,3,4], 0, /* -> */ [1,3,6,10])' and
     `cumlist(plus, [1,1,1,1], /* <- */ 0, [1,2,3,4])'.

`maplist(:PRED, +LIST)'
     succeeds when PRED(X) succeeds for each element X of LIST.

`maplist(:PRED, +OLDLIST, ?NEWLIST)'
     succeeds when PRED(OLD,NEW) succeeds for each corresponding OLD in
     OLDLIST, NEW in NEWLIST.  Either OLDLIST or NEWLIST should be a
     proper list.

`maplist(:PRED, +XS, ?YS, ?ZS)'
     is true when XS, YS, and ZS are lists of equal length, and PRED(X,
     Y, Z) is true for corresponding elements X of XS, Y of YS, and Z
     of ZS.  At least one of XS, YS, and ZS should be a proper list.

`map_product(Pred, Xs, Ys, PredOfProduct)'
     Just as `maplist(P, Xs, L)' is the analogue of Miranda's
              let L = [ P x | x <- Xs ]
     so `map_product(P, Xs, Ys, L)' is the analogue of Miranda's
              let L = [ P x y | x <- Xs; y <- Ys ]
     That is, if XS = [X1,...,XM], YS = [Y1,...,YN], and P(XI,YJ,ZIJ),
     L = [Z11,...,Z1N,Z21,...,Z2N,...,ZM1,...,ZMN].  It is as if we
     formed the cartesian product of XS and YS and applied P to the
     (XI,YJ) pairs.

`scanlist(:PRED, +LIST, ?V1, ?V)'
     maps a ternary relation PRED down a list.  If the list is
     [X1,X2,...,XN], the computation is PRED(X1,V1,V2), PRED(X2,V2,V3),
     ..., PRED(XN,VN,V) So if PRED is `plus/3', `scanlist(plus, List,
     0, V)' puts the sum of the list elements in V.  LIST should be a
     proper list.  Note that the order of the arguments passed to Pred
     is the same as the order of the arguments following Pred.  This
     also holds for scanlist/5 and scanlist/6, e.g.  scanlist(Pred, Xs,
     Ys, Zs, V1, V) calls Pred(X3,Y3,Z3,V3,V4).

`some(:PRED, +LIST)'
     succeeds when PRED(ELEM) succeeds for some ELEM in LIST.  It will
     try all ways of proving PRED for each ELEM, and will try each ELEM
     in the LIST.  `somechk/2' is to `some/2' as `memberchk/2' is to
     `member/2'.
              member(X,L)     <-> some(=(X), L).
              memberchk(X, L) <-> somechk(=(X), L).
              some(Pred,L)    <-> member(X, L), call(Pred,X).
     This acts on backtracking like member/2; List should be a proper
     list.

`some(:PRED, +[X1,...,XN], ?[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I.

`some(:PRED, +[X1,...,XN], ?[Y1,...,YN], ?[Z1,...,ZN])'
     is true when PRED(XI, YI, ZI) is true for some I.

`somechk(:PRED, +[X1,...,XN])'
     is true when PRED(XI) is true for some I, and it commits to the
     first solution it finds (like `memberchk/2').

`somechk(:PRED, +[X1,...,XN], ?[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I, and it commits to
     the first solution it finds (like `memberchk/2').

`somechk(:PRED, +[X1,...,XN], ?[Y1,...,YN], ?[Z1,...,ZN])'
     is true when PRED(XI, YI, ZN) is true for some I, and it commits to
     the first solution it finds (like `memberchk/2').

`convlist(:REWRITE, +OLDLIST, ?NEWLIST)'
     is a sort of hybrid of `maplist/3' and `include/3'.  Each element
     of NEWLIST is the image under REWRITE of some element of OLDLIST,
     and order is preserved, but elements of OLDLIST on which REWRITE
     is undefined (fails) are not represented.  Thus if `foo(K,X,Y) :-
     integer(X), Y is X+K.' then `convlist(foo(1), [1,a,0,joe(99),101],
     [2,1,102]).' OLDLIST should be a proper list.

`exclude(:PRED, +LIST, ?SUBLIST)'
     succeeds when SUBLIST is the SUBLIST of LIST containing all the
     elements for which PRED(ELEM) is _false_.  That is, it removes all
     the elements satisfying PRED.  LIST should be a proper list.

`exclude(:PRED, +XS, +YS, +ES)'
     is true when Es is the sublist of Xs containing all the elements Xi
     for which Pred(Xi, Yi) is *false*.  Xs should be a proper list, and
     Ys should be at least as long as Xs (it may be longer).

`exclude(:PRED, +XS, +YS, +ZS, +ES)'
     is true when ES is the sublist of XS containing all the elements XI
     for which PRED(XI, YI, ZI) is _false_.  XS should be a proper list,
     and YS and ZS should be at least as long as XS (they may be
     longer).

`include(:PRED, +LIST, ?SUBLIST)'
     succeeds when SUBLIST is the SUBLIST of LIST containing all the
     elements for which PRED(ELEM) is _true_.  That is, it retains all
     the elements satisfying PRED.  LIST should be a proper list.

`include(:PRED, +XS, +YS, +ES)'
     is true when ES is the sublist of XS containing all the elements XI
     for which PRED(XI, YI) is _true_.   XS should be a proper list, and
     YS should be at least as long as XS (it may be longer).

`include(:PRED, +XS, +YS, +ZS, +ES)'
     is true when ES is the sublist of XS containing all the elements XI
     for which PRED(XI, YI, ZI) is _false_.  XS should be a proper list,
     and YS and ZS should be at least as long as XS (they may be
     longer).

`partition(:PRED, +LIST, ?LESS, ?EQUAL, ?GREATER)'
     is a relative of `include/3' and `exclude/3' which has some
     pretensions to being logical.  For each X in LIST, we call
     PRED(X,R), and route X to LESS, EQUAL, or GREATER according as R
     is `<', `=', or `>' .

`group(:PRED, +LIST, ?FRONT, ?BACK)'
     is true when `append(Front, Back, List), maplist(Pred, Front)',
     and FRONT is as long as possible.

`group(:PRED, +KEY, +LIST, ?FRONT, ?BACK)'
     is true when `append(Front, Back, List), maplist(call(Pred,Key),
     Front)', and FRONT is as long as possible.  Strictly speaking we
     don't need it; `group(call(Pred,Key), List, Front, Back)' would do
     just as well.

`group(:PRED, +LIST, ?LISTOFLISTS)'
     is true when `append(ListOfLists, List)', each element of
     LISTOFLISTS has the form [HEAD|TAIL] such that `group(Pred, Head,
     Tail, Tail, [])', and each element of LISTOFLISTS is as long as
     possible.  For example, if you have a keysorted list, and define
     `same_key(K-_, K-_)', then `group(same_key, List, Buckets)' will
     divide LIST up into BUCKETS of pairs having the same key.

`ordered(+LIST)'
     is true when LIST is a list of terms [T1,T2,...,TN] such that for
     all K in 2..N TK-1 `<=' TK, i.e. T1 `<=' T2 `<=' T3 ...  The
     output of `keysort/2' is always ordered, and so is that of
     `sort/2'.  Beware: just because a list is ordered does not mean
     that it is the representation of an ordered set; it might contain
     duplicates.

`ordered(+P, +[T1,T2,...,TN])'
     is true when P(T1,T2) & P(T2,T3) & ...   That is, if you take P as
     a "comparison" predicate like `<=', the list is ordered.  This is
     good for generating prefixes of sequences, e.g. `L = [1,_,_,_,_],
     ordered(times(2), L)' yields `L = [1,2,4,8,16]'.

`max_member(?XMAX, +[X1,...,XN])'
     unifies XMAX with the maximum (in the sense of `<=') of X1,...,XN.
     If the list is empty, it fails quietly.

`min_member(?XMIN, +[X1,...,XN])'
     unifies XMIN with the minimum (in the sense of `<=') of X1,...,XN.
     If the list is empty, it fails quietly.

`max_member(:P, ?XMAX, +[X1,...,XN])'
     unifies XMAX with the maximum element of [X1,...,XN], as defined
     by the comparison predicate P, which should act like `<=' .

`min_member(:P, ?XMIN, +[X1,...,XN])'
     unifies XMIN with the minimum element of [X1,...,XN], as defined
     by the comparison predicate P, which should act like `<=' .

`select_min(?ELEMENT, +SET, ?RESIDUE)'
     unifies ELEMENT with the smallest (in the sense of `<=') element
     of SET, and RESIDUE with a list of all the other elements.

`select_min(:PRED, ?ELEMENT, +SET, ?RESIDUE)'
     find the least ELEMENT of SET, i.e. PRED(ELEMENT,X) for all X in
     SET.

`select_max(?ELEMENT, +SET, ?RESIDUE)'
     unifies ELEMENT with the (leftmost) maximum element of the SET,
     and RESIDUE to the other elements in the same order.

`select_max(:PRED, ?ELEMENT, +SET, ?RESIDUE)'
     find the greatest ELEMENT of SET, i.e. PRED(X,ELEMENT) for all X
     in SET.

`increasing_prefix(?SEQUENCE, ?PREFIX, ?TAIL)'
     is true when `append(Prefix, Tail, Sequence)' and PREFIX, together
     with the first element of TAIL, forms a monotone non-decreasing
     sequence, and no longer Prefix will do.  Pictorially,
          Sequence = [x1,...,xm,xm+1,...,xn]
          Prefix   = [x1,...,xm]
          Tail     = [xm+1,...,xn]
          x1 <= x2 <= ... <= xm <= xm+1
          not xm+1 <= xm+2
     This is perhaps a surprising definition; you might expect that the
     first element of TAIL would be included in PREFIX.  However, this
     way, it means that if Sequence is a strictly decreasing sequence,
     the PREFIX will come out empty.

`increasing_prefix(:ORDER, ?SEQUENCE, ?PREFIX, ?TAIL)'
     is the same as `increasing_prefix/3', except that it uses the
     binary relation ORDER in place of `<='.

`decreasing_prefix(?SEQUENCE, ?PREFIX, ?TAIL)'
`decreasing_prefix(:ORDER, ?SEQUENCE, ?PREFIX, ?TAIL)'
     is the same, except it looks for a decreasing prefix.  The order
     is the converse of the given order.  That is, where
     `increasing_prefix/[3,4]' check X(R)Y, these routines check Y(R)X.

`clumps(+ITEMS, -CLUMPS)'
     is true when CLUMPS is a list of lists such that
        * `append(Clumps, Items)'

        * for each CLUMP in CLUMPS, all the elements of CLUMP are
          identical (`==')
     ITEMS must be a proper list of terms for which sorting would have
     been sound.  In fact, it usually is the result of sorting.

`keyclumps(+PAIRS, ?CLUMPS)'
     is true when PAIRS is a list of pairs and CLUMPS a list of lists
     such that
        * `append(Clumps, Pairs)'

        * for each CLUMP in CLUMPS, all of the KEY-VALUE pairs in CLUMP
          have identical (`==') KEYS.
     PAIRS must be a proper list of pairs for which keysorting would
     have been sound.  In fact, it usually is the result of keysorting.

`clumped(+ITEMS, ?COUNTS)'
     is true when COUNTS is a list of ITEM-COUNT pairs such that if
     `clumps(Items, Clumps)', then each ITEM-COUNT pair in COUNTS
     corresponds to an element [ITEM/*1*/,...,ITEM/*COUNT*/] of CLUMPS.
     ITEMS must be a proper list of terms for which sorting would have
     been sound.  In fact, it usually is the result of sorting.

`keyclumped(+PAIRS, ?GROUPS)'
     is true when PAIRS is a list of KEY-ITEM pairs and GROUPS is a
     list of KEY-ITEMS pairs such that if `keyclumps(Pairs, Clumps)',
     then for each K-[I1,...,IN] pair in GROUPS there is a
     [K-I1,...,K-IN] clump in CLUMPS.  PAIRS must be a proper list of
     pairs for which keysorting would have been sound.  In fact, it
     usually is the result of keysorting.


File: sicstus.info,  Node: lib-logarr,  Next: lib-objects,  Prev: lib-lists,  Up: The Prolog Library

10.12 Array Operations--`library(logarr)'
=========================================

This libary module provides extendible arrays with logarithmic access
time.  *Please note:* the atom `$' is used to indicate an unset
element, and the functor `$/4' is used to indicate a subtree.  In
general, array elements whose principal function symbol is `$' will not
work.

   Exported predicates:

     new_array(-A)     returns a new empty array A.

`is_array(+A)'
     checks whether A is an array.

`alist(+ARRAY, -LIST)'
     returns a list of pairs INDEX-ELEMENT of all the elements of ARRAY
     that have been set.

`aref(+INDEX, +ARRAY, -ELEMENT)'
     unifies ELEMENT with ARRAY[INDEX], or fails if ARRAY[INDEX] has
     not been set.

`arefa(+INDEX, +ARRAY, -ELEMENT)'
     is as `aref/3', except that it unifies ELEMENT with a new array if
     ARRAY[INDEX] is undefined.  This is useful for multidimensional
     arrays implemented as arrays of arrays.

`arefl(+INDEX, +ARRAY, -ELEMENT)'
     is as `aref/3', except that ELEMENT appears as `[]' for undefined
     cells.

`aset(+INDEX, +ARRAY, +ELEMENT, -NEWARRAY)'
     unifies NEWARRAY with the result of setting ARRAY[INDEX] to
     ELEMENT.


File: sicstus.info,  Node: lib-objects,  Next: lib-ordsets,  Prev: lib-logarr,  Up: The Prolog Library

10.13 The Objects Package--`library(objects)'
=============================================

* Menu:

* obj-exp::                             Exported Predicates
* obj-glo::                             Glossary
* obj-bas::                             Introduction
* obj-scl::                             Simple Classes
* obj-inh::                             Inheritance
* obj-tcl::                             Term Classes
* obj-tech::                            Technical Details

   The SICStus Objects package enables programmers to write
object-oriented programs in SICStus Prolog. The objects in SICStus
Objects are modifiable data structures that provide a clean and
efficient alternative to storing data in the Prolog database.


File: sicstus.info,  Node: obj-bas,  Next: obj-scl,  Prev: obj-glo,  Up: lib-objects

10.13.1 Introduction
--------------------

* Menu:

* obj-bas-uobj::                        Using SICStus Objects
* obj-bas-def::                         Defining Classes
* obj-bas-ucl::                         Using Classes
* obj-bas-la::                          Looking Ahead

   The SICStus Objects package enables programmers to write
object-oriented programs in SICStus Prolog. The objects in SICStus
Objects are modifiable data structures that provide a clean and
efficient alternative to storing data in the Prolog database.

   This user's guide is neither an introduction to object-oriented
programming nor an introduction to SICStus Prolog. A number of small,
sample programs are described in this manual, and some larger programs
are in the `demo' directory.


File: sicstus.info,  Node: obj-bas-uobj,  Next: obj-bas-def,  Up: obj-bas

10.13.1.1 Using SICStus Objects
...............................

One of the basic ideas of object-oriented programming is the
encapsulation of data and procedures into objects. Each object belongs
to exactly one class, and an object is referred to as an instance of
its class. A class definition determines the following things for its
objects:

   * slots, where an object holds data

   * messages, the commands that can be sent to an object

   * methods, the procedures the object uses to respond to the messages

   All interaction with an object is by sending it messages. The command
to send a message to an object has the form

     OBJECT MESSAGEOP MESSAGE

where OBJECT is an object, MESSAGEOP is one of the message operators
(`<<', `>>', or `<-') and MESSAGE is a message defined for the object's
class.  Roughly speaking, the `>>' message operator is used for
extracting information from an object, `<<' is for storing information
into an object, and `<-' is for any other sort of operation.

   For example, using the point class defined in the next section, it
would be possible to give the following command, which demonstrates all
three message operators.

     | ?- create(point, PointObj),
          PointObj >> x(InitX),
          PointObj >> y(InitY),
          PointObj << x(2.71828),
          PointObj << y(3.14159),
          PointObj <- print(user_output),
          nl(user_output).

     (2.71828,3.14159)
     PointObj = point(23461854),
     InitX = 1.0,
     InitY = 2.0

   First it binds the variable `PointObj' to a newly created `point'
object. Then, the two get messages (sent with the `>>' operator) fetch
the initial values of the point's `x' and `y' slots, binding the
variables `InitX' and `InitY' to these values.  Next, the two put
messages (sent with the `<<' operator) assign new values to the
object's `x' and `y' slots. Finally, the send message (sent with the
`<-' operator) instructs the point object to print itself to the
`user_output' stream, followed by a newline.  Following the goal, we see
the point has been printed in a suitable form.  Following this, the
values of `PointObj', `InitX', and `InitY' are printed as usual for
goals entered at the Prolog prompt.

   Because this goal is issued at the Prolog prompt, the values of the
variables `PointObj', `InitX' and `InitY' are not retained after the
command is executed and their values are displayed, as with any goal
issued at the Prolog prompt.  However, the point object still exists,
and it retains the changes made to its slots. Hence, objects, like
clauses asserted to the Prolog database, are more persistent than
Prolog variables.

   Another basic idea of object-oriented programming is the notion of
inheritance. Rather than defining each class separately, a new class
can inherit the properties of a more general superclass. Or, it can be
further specialized by defining a new subclass, which inherits its
properties. (C++ uses the phrase "base class" where we use
"superclass." It also uses "derived class" where we use "subclass.")

   SICStus Objects uses term expansion to translate object-oriented
programs into ordinary Prolog. (This is the same technique that Prolog
uses for its DCG grammar rules.) As much as possible is done at compile
time. Class definitions are used to generate Prolog clauses that
implement the class's methods. Message commands are translated into
calls to those Prolog clauses.  And, inheritance is resolved at
translation time.

   SICStus Objects consists of two modules, `obj_decl' and `objects'.
The `obj_decl' module is used at compile time to translate the
object-oriented features of SICStus Objects. Any file that defines
classes or sends messages should include the command

     :- load_files(library(obj_decl),
                   [when(compile_time), if(changed)]).

   The `objects' module provides runtime support for SICStus Objects
programs. A file that sends messages or asks questions about what
classes are defined or to what class an object belongs should include
the command:

     :- use_module(library(objects)).

   You will probably include both in most files that define and use
classes.


File: sicstus.info,  Node: obj-bas-def,  Next: obj-bas-ucl,  Prev: obj-bas-uobj,  Up: obj-bas

10.13.1.2 Defining Classes
..........................

A class definition can restrict the values of any slot to a particular
C-style type. It can specify whether a slot is "private" (the default,
meaning that it cannot be accessed except by that methods of that
class), "protected" (like "private", except that the slot can also be
accessed by subclasses of the class), or "public" (meaning get and put
methods for the slot are generated automatically), and it can specify
an initial value. The class definition also may contain method clauses,
which determine how instances of the class will respond to messages.  A
class definition may also specify one or more superclasses and which
methods are to be inherited.

   The point object created in the previous example had two floating
point slots, named `x' and `y', with initial values of 1.0 and 2.0,
respectively. As we have seen, the `point' class also defined put and
get methods for `x' and `y', as well as a send method for printing the
object.  The put and get methods for `x' and `y' can be automatically
generated simply by declaring the slots `public', but the `print'
method must be explicitly written.  In addition, in order to be able to
create instances of this class, we must define a `create' method, as
explained in *Note obj-scl-meth::.  We also provide a second `create'
method, taking two arguments, allowing us to specify an `x' and `y'
value when we first create a point object.

     :- class point =
             [public x:float = 1.0,
              public y:float = 2.0].

     Self <- create.

     Self <- create(X, Y) :-
             Self << x(X),
             Self << y(Y).

     Self <- print(Stream) :-
             Self >> x(X),
             Self >> y(Y),
             format(Stream, '(~w,~w)', [X,Y]).

     :- end_class point.

   The variable name `Self' in these clauses is arbitrary--any variable
to the left of the message operator in the head of a method clause
refers to the instance of the class receiving the message.


File: sicstus.info,  Node: obj-bas-ucl,  Next: obj-bas-la,  Prev: obj-bas-def,  Up: obj-bas

10.13.1.3 Using Classes
.......................

Given this definition, the following command creates an instance of the
point class, assigning values to its `x' and `y' slots, and prints a
description of the point.

     | ?- create(point(3,4), PointObj),
          PointObj <- print(user_output).

   The print message prints `(3.0,4.0)'. The variable `PointObj' is
bound to a Prolog term of the form

     `point(ADDRESS)'

where ADDRESS is essentially a pointer to the object.

   In general, an object belonging to a class CLASSNAME will be
represented by a Prolog term of the form

     CLASSNAME(ADDRESS)

   The name CLASSNAME must be an atom. This manual refers to such a
term as if it were the object, not just a pointer to the object.  Users
are strongly discouraged from attempting to do pointer arithmetic with
the address.

   After execution of this command, the point object still exists, but
the variable `PointObj' can no longer be used to access it. So, while
objects resemble clauses asserted into the Prolog database in their
persistence, there is no automatic way to search for an object.
Objects are not automatically destroyed when they are no longer needed.
And, there is no automatic way to save an object from one Prolog
session to the next. It is the responsibility of the programmer to keep
track of objects, perhaps calling the `destroy/1' predicate for
particular objects that are no longer needed or asserting bookkeeping
facts into the Prolog database to keep track of important objects.


File: sicstus.info,  Node: obj-bas-la,  Prev: obj-bas-ucl,  Up: obj-bas

10.13.1.4 Looking Ahead
.......................

The next few sections of this manual describe the SICStus Objects
package in greater detail.  In particular, they describe how to define
classes, their methods and their slots, and how to reuse class
definitions via inheritance. Small sample programs and program
fragments are provided for most of the features described.

   Experienced Prolog programmers may choose to skip over these sections
and look at the sample programs in this package's demo directory,
referring to the reference pages as necessary. Everyone is encouraged
to experiment with the sample programs before writing their own
programs.


File: sicstus.info,  Node: obj-scl,  Next: obj-inh,  Prev: obj-bas,  Up: lib-objects

10.13.2 Simple Classes
----------------------

* Menu:

* obj-scl-scp::                         Scope of a Class Definition
* obj-scl-slt::                         Slots
* obj-scl-meth::                        Methods

   This section is about simple classes that inherit nothing--neither
slots nor methods--from more general superclasses. Everything about
these classes is given directly in their definitions, so they are the
best starting point for programming with SICStus Objects.

   The use of inheritance in defining classes is described in the next
section. Classes that inherit properties from superclasses are called
derived classes in some systems, such as C++. In general, the use of
inheritance extends the properties of the simple classes in this
section.


File: sicstus.info,  Node: obj-scl-scp,  Next: obj-scl-slt,  Up: obj-scl

10.13.2.1 Scope of a Class Definition
.....................................

A simple class definition begins with a statement of the form

     :- class CLASSNAME = [SLOTDEF, ...].

   The class's slots are described in the list of SLOTDEF terms. It is
possible, though not often useful, to define a class with no slots, by
specifying the empty list. In that case the `=' and the list may be
omitted.

   The class's methods are defined following the `class/1' directive,
by Prolog clauses. Most of this section is about defining and using
methods.

   The class definition ends with any of the following:

     :- end_class CLASSNAME.

or

     :- end_class.

or the next `class/1' directive or the end of the file. The CLASSNAME
argument to `end_class/1' must match the class name in the
corresponding `class/1' directive. It is not possible to nest one class
definition inside another.


File: sicstus.info,  Node: obj-scl-slt,  Next: obj-scl-meth,  Prev: obj-scl-scp,  Up: obj-scl

10.13.2.2 Slots
...............

A slot description has the form

     VISIBILITY SLOTNAME:SLOTTYPE = INITIALVALUE

where VISIBILITY and `= INITIALVALUE' are optional. Each slot of a
class must have a distinct name, given by the atom SLOTNAME. The
VISIBILITY, SLOTTYPE and INITIALVALUE parts of the slot description are
described separately.

Visibility
----------

A slot's visibility is either private, protected, or public. If its
visibility is not specified, the slot is private. The following example
shows all four possibilities:

     :- class example = [w:integer,
                         private   x:integer,
                         protected y:integer,
                         public    z:integer]

   Slot `z' is public, `y' is protected, and both `x' and `w' are
private.

   Direct access to private slots is strictly limited to the methods of
the class.  Any other access to such slots must be accomplished through
these methods.  Making slots private will allow you later to change how
you represent your class, adding and removing slots, without having to
change any code that uses your class.  You need only modify the methods
of the class to accomodate that change.  This is known as "information
hiding".

   Protected slots are much like private slots, except that they can
also be directly accessed by subclasses.  This means that if you wish to
modify the representation of your class, you will need to examine not
only the class itself, but also its subclasses.

   Public slots, in contrast, can be accessed from anywhere.  This is
accomplished through automatically generated get and put methods named
for the slot and taking one argument.  In the example above, our
`example' class would automatically support a get and put method named
`z/1'.  Note, however, that unlike other object oriented programming
languages that support them, public slots in SICStus Objects do not
violate information hiding.  This is because you may easily replace a
public slot with your own get and put methods of the same name.  In
this sense, a public slot is really only a protected slot with
automatically generated methods to fetch and store its contents.

   Within a method clause, any of the class's slots can be accessed via
the `fetch_slot/2' and `store_slot/2' predicates. These are the only
way to access private and protected slots. They may be used to define
get and put methods for the class, which provide controlled access to
the protected slots. But, they can only be used within the method
clauses for the class, and they can only refer to slots of the current
class and protected and public slots of superclasses.

   In the slot description, `public', `protected' and `private' are
used as prefix operators. The `obj_decl' module redefines the prefix
operator `public', as follows:

     :- op(600, fy, [public]).

   Unless you use the obsolete `public/1' directive in your Prolog
programs, this should cause no problems.

Types
-----

A slot's type restricts the kinds of values it may contain. The slot is
specified in the slot description by one of the following Prolog terms
with the corresponding meaning.  Most of these will be familiar, but
the last four, `address', `term', CLASS and `pointer(TYPE)', require
some additional explanation:

`integer'
     long signed integer

`integer_32'
     32-bit signed integer

`integer_16'
     16-bit signed integer

`integer_8'
     8-bit signed integer

`unsigned'
     long unsigned integer

`unsigned_32'
     32-bit unsigned integer

`unsigned_16'
     16-bit unsigned integer

`unsigned_8'
     8-bit unsigned integer

`float'
     64-bit floating point number

`float_32'
     32-bit floating point number

`atom'
     Prolog atom.

`address'
     Long address.  The address type is intended for use with foreign
     code.  A slot of this type might store an address returned from a
     foreign function. That address might, in turn, be used in calling
     another foreign function. Hence, most Prolog programmers can
     safely ignore this type.

`term'
     Prolog term.  The term type is for general Prolog terms. Such a
     slot can hold any of the other types. However, if you know a slot
     will be used to hold only values of a particular type, it is more
     efficient to specify that type in the class definition.

     Storing a term containing free variables is similar to asserting a
     clause containing free variables into the Prolog database. The
     free variables in the term are replaced with new variables in the
     stored copy. And, when you fetch the term from the slot, you are
     really fetching a copy of the term, again with new variables.

`CLASS'
     where CLASS is the name of a defined class.  The class type is for
     any object in a class defined with SICStus Objects. Such a slot
     holds an object of its class or one of that class's descendants,
     or the `null' object.

`pointer(TYPE)'
     where TYPE is an atom.  The pointer type is intended for use with
     the Structs Package.  It is similar to the `address' type, except
     that access to this slot yields, and update to this slot expects,
     a term of arity 1 whose functor is TYPE and whose argument is the
     address. Again, most Prolog programmers can safely ignore this
     type.


Initial Values
--------------

A slot description may optionally specify an initial value for the
slot. The initial value is the value of the slot in every instance of
the class, when the object is first created. The initial value must be
a constant of the correct type for the slot.

   If an initial value is not specified, a slot is initialized to a
value that depends on its type. All numbers are initialized to 0, of the
appropriate type. Atom and term slots are initialized to the empty atom
(`'''). Addresses and pointers are initialized to null pointers. And,
objects are initialized to the `null' object.

   More complicated initialization--not the same constant for every
instance of the class--must be performed by create methods, which are
described later.

The `null' object
-----------------

The `null' object is a special object that is not an instance of any
class, but that can be stored in a slot intended for any class of
object.  This is very much like the `NULL' pointer in C.  This is
useful when you do not yet have an object to store in a particular slot.

   In Prolog, the `null' is represented by the atom `null'.

   Note that because the `null' object is not really an object of any
class, you cannot determine its class with `class_of/2'.  Unless noted
otherwise, when we write of an "object" in this document, we do not
include the `null' object.


File: sicstus.info,  Node: obj-scl-meth,  Prev: obj-scl-slt,  Up: obj-scl

10.13.2.3 Methods
.................

Some methods are defined by method clauses, between the `class/1'
directive and the end of the class's definition. Others are generated
automatically. There are three kinds of messages in SICStus Objects,
distinguished by the message operator they occur with:

`>>'
     A get message, which is typically used to fetch values from an
     object's slots.

`<<'
     A put message, which is typically used to store values in an
     object's slots.

`<-'
     A send message, which is used for other operations on or involving
     an object.

   SICStus Objects automatically generates some get and put methods.
And, it expects particular message names with the send operator for
create and destroy methods. For the most part, however, you are free to
use any message operators and any message names that seem appropriate.

   A method clause has one of these message operators as the principal
functor of its head. Its first argument, written to the left of the
message operator, is a variable. By convention, we use the variable
`Self'. Its second argument, written to the right of the message
operator, is a term whose functor is the name of the message and whose
arguments are its arguments.

   For example, in the class whose definition begins as follows, a
0-argument send message named `increment' is defined. No parentheses are
needed in the clause head, because the precedence of the `<-' message
operator is lower than that of the `:-' operator.

     :- class counter = [public count:integer = 0].

     Self <- increment :-
             Self >> count (X0),
             X1 is X0 + 1,
             Self << count (X1).

   Its definition uses the automatically generated get and put methods
for the public slot `count'.

   It may look as though this technique is directly adding clauses to
the `>>/2', `<</2' and `<-/2' predicates, but the method clauses are
transformed by term expansion, at compile time.  However, the method
clauses have the effect of extending the definitions of those
predicates.

   Methods are defined by Prolog clauses, so it is possible for them to
fail, like Prolog predicates, and it is possible for them to be
nondeterminate, producing multiple answers, upon backtracking. The rest
of this section describes different kinds of methods.

Get and Put Methods
-------------------

Get and put methods are generated automatically for each of a class's
public slots. These are 1-argument messages, named after the slots.

   In the point class whose definition begins with

     :- class point =
             [public x:float=0,
              public y:float=0].

the get and put methods are automatically generated for the `x' and `y'
slots. If the class defines a `create/0' method, the command

     | ?- create(point, PointObj),
          PointObj >>  x(OldX),
          PointObj >>  y(OldY),
          PointObj <<  x(3.14159),
          PointObj <<  y(2.71828).

creates a point object and binds both `OldX' and `OldY' to 0.0E+00, its
initial slot values. Then, it changes the values of the `x' and `y'
slots to 3.14159 and 2.71828, respectively. The variable `PointObj' is
bound to the point object.

   It is possible, and sometimes quite useful, to create get and put
methods for slots that do not exist. For example, it is possible to add
a polar coordinate interface to the point class by defining get and put
methods for `r' and `theta', even though there are no `r' and `theta'
slots. The get methods might be defined as follows:

     Self >> r(R) :-
             Self >> x(X),
             Self >> y(Y),
             R2 is X*X + Y*Y,
             sqrt(R2, R).

     Self >> theta(T) :-
             Self >> x(X),
             Self >> y(Y),
             A is Y/X,
             atan(A, T).

   This assumes that `library(math)', which defines the `sqrt/2' and
`atan/2' predicates, has been loaded. The put methods are left as an
exercise.

   In the rational number class whose definition begins with

     :- class rational =
             [public num:integer,
              public denom:integer].

get and put methods are automatically generated for the `num' and
`denom' slots. It might be reasonable to add a get method for `float',
which would provide a floating point approximation to the rational in
response to that get message. This is left as an exercise.

   It is also possible to define get and put methods that take more than
one argument. For example, it would be useful to have a put method for
the point class that sets both slots of a point object. Such a method
could be defined by

     Self << point(X,Y) :-
             Self << x(X),
             Self << y(Y).

   Similarly, a 2-argument get method for the rational number class
might be defined as

     Self >> (N/D) :-
             Self >> num(N),
             Self >> denom(D).

   Note that the name of the put message is `(/)/2', and that the
parentheses are needed because of the relative precedences of the `>>'
and `/' operators.

   Put messages are used to store values in slots. Get messages,
however, may be used either to fetch a value from a slot or to test
whether a particular value is in a slot. For instance, the following
command tests whether the `do_something/2' predicate sets the point
object's `x' and `y' slots to 3.14159 and 2.71828, respectively.

     | ?- create(point, PointObj),
          do_something(PointObj),
          PointObj >> x(3.14159),
          PointObj >> y(2.71828).

   The `fetch_slot/2' predicate can similarly be used to test the value
of a slot.

   The effects of a put message (indeed, of any message) are not undone
upon backtracking. For example, the following command fails:

     | ?- create(point, PointObj),
          PointObj << x(3.14159),
          PointObj << y(2.71828),
          fail.

   But, it leaves behind a point object with `x' and `y' slots
containing the values 3.14159 and 2.71828, respectively. In this,
storing a value in an object's slot resembles storing a term in the
Prolog database with `assert/1'.

   Some care is required when storing Prolog terms containing unbound
variables in term slots.  For example, given the class definition that
begins with

     :- class prolog_term = [public p_term:term].

     Self <- create.

the following command would succeed:

     | ?- create(prolog_term, TermObj),
          TermObj << p_term(foo(X,Y)),
          X = a,
          Y = b,
          TermObj >> p_term(foo(c,d)).

   The reason is that the free variables in `foo(X,Y)' are renamed when
the term is stored in the `prolog_term' object's `p_term' slot. This is
similar to what happens when such a term is asserted to the Prolog
database:

     | ?- retractall(foo(_,_)),
          assert(foo(X,Y)),
          X = a,
          Y = b,
          foo(c,d).

   However, this goal would fail, because `c' and `d' cannot be unified:

     | ?- create(prolog_term, TermObj),
          TermObj << p_term(foo(X,X)),
          TermObj >> p_term(foo(c,d)).

Direct Slot Access
------------------

Get and put methods are not automatically generated for private and
protected slots. Those slots are accessed by the `fetch_slot/2' and
`store_slot/2' predicates, which may only appear in the body of a
method clause and which always operate on the object to which the
message is sent. It is not possible to access the slots of another
object with these predicates.

   You may declare a slot to be private or protected in order to limit
access to it. However, it is still possible, and frequently useful, to
define get and put methods for such a slot.

   For example, if numerator and denominator slots of the rational
number class were private rather than public, it would be possible to
define put methods to ensure that the denominator is never 0 and that
the numerator and denominator are relatively prime. The get methods
merely fetch slot values, but they need to be defined explicitly, since
the slots are private. The new definition of the rational number class
might start as follows:

     :- class rational =
             [num:integer=0,
              denom:integer=1].

     Self >> num(N) :-
             fetch_slot(num, N).

     Self >> denom(D) :-
             fetch_slot(denom, D).

     Self >> (N/D) :-
             Self >> num(N),
             Self >> denom(D).

   One of the put methods for the class might be

     Self << num(NO) :-
             fetch_slot(denom, DO)
             reduce(NO, DO, N, D),
             store_slot(num, N),
             store_slot(denom, D).

where the `reduce/4' predicate would be defined to divide `NO' and `DO'
by their greatest common divisor, producing `N' and `D', respectively.

   The definition of `reduce/4' and the remaining put methods is left
as an exercise.  The put methods should fail for any message that
attempts to set the denominator to 0.

Send Methods
------------

Messages that do something more than fetch or store slot values are
usually defined as send messages. While the choice of message operators
is (usually) up to the programmer, choosing them carefully enhances the
readability of a program.

   For example, print methods might be defined for the point and
rational number classes, respectively, as

     Self <- print(Stream) :-
             Self >> x(X),
             Self >> y(Y),
             format(Stream, "(~w,~w)", [X, Y]).

and

     Self <- print(Stream) :-
             fetch_slot(num, N),
             fetch_slot(denom, D),
             format(Stream, "~w/~w", [N, D]).

   These methods are used to access slot values. But, the fact that the
values are printed to an output stream makes it more reasonable to
define them as send messages than get messages.

   Frequently send methods modify slot values. For example, the point
class might have methods that flip points around the x and y axes,
respectively:

     Self <- flip_x :-
             Self >> y(Y0),
             Y1 is -1 * Y0,
             Self << y(Y1).

     Self <- flip_y :-
             Self >> x(X0),
             X1 is -1 * X0,
             Self << x(X1).

   And, the rational number class might have a method that swaps the
numerator and denominator of a rational number object. It fails if the
numerator is 0.

     Self <- invert :-
             fetch_slot(num, N)
             N =\= 0,
             fetch_slot(denom, D)
             store_slot(num, D),
             store_slot(denom, N).

   These methods modify slot values, but they do not simply store values
that are given in the message. Hence, it is more reasonable to use the
send operator.

   It is possible for a method to produce more than one answer. For
example, the class whose definition begins with

     :- class interval =
             [public lower:integer,
              public upper:integer].

might define a send method

     Self <- in_interval(X) :-
             Self >> lower(L),
             Self >> upper(U),
             between(L, U, X).

which uses the `between/3' predicate from `library(between)'. The
`in_interval' message will bind `X' to each integer, one at a time,
between the lower and upper slots, inclusive. It fails if asked for too
many answers.

   The rest of this section describes particular kinds of send messages.

Create and Destroy Methods
--------------------------

Objects are created with the `create/2' predicate. When you define a
class, you must specify all the ways that instances of the class can be
created. The simplest creation method is defined as

     Self <- create.

   If this method were defined for CLASS, the command

     | ?- create(CLASS, `Object').

would create an instance of CLASS and bind the variable `Object' to that
instance. All slots would receive their (possibly default) initial
values.

   More generally, if the definition for CLASS contains a create method

     Self <- create(ARGUMENTS) :-
             BODY.

the command

     | ?- create(CLASS(ARGUMENTS), OBJECT).

will create an instance of CLASS and execute the BODY of the create
method, using the specified ARGUMENTS. The variable OBJECT is bound to
the new instance.

   If a simple class definition has no create methods, it is impossible
create instances of the class. While the absence of create methods may
be a programmer error, that is not always the case. Abstract classes,
which are classes that cannot have instances, are often quite useful in
defining a class hierarchy.

   Create methods can be used to initialize slots in situations when
specifying initial slot values will not suffice. (Remember that initial
values must be specified as constants at compile time).  The simplest
case uses the arguments of the create message as initial slot values.
For example, the definition of the point class might contain the
following create method.

     Self <- create(X,Y) :-
             Self << x(X),
             Self << y(Y).

   If used as follows

     | ?- create(point(3.14159, 2.71828), PointObj),
          PointObj >> x(X),
          PointObj >> y(Y).

it would give `X' and `Y' the values of 3.14159 and 2.71828,
respectively.

   In some cases, the create method might compute the initial values.
The following (partial) class definition uses the `date/1' predicate
from `library(date)' to initialize its year, month and day slots.

     :- class date_stamp =
             [year:integer,
              month:integer,
              day:integer].

     Self <- create :-
             date(date(Year, Month, Day)),
             store_slot(year, Year),
             store_slot(month, Month),
             store_slot(day, Day).

   All three slots are private, so it will be necessary to define get
methods in order to retrieve the time information. If no put methods
are defined, however, the date cannot be modified after the
`date_stamp' object is created (unless some other method for this class
invokes `store_slot/2' itself).

   Create methods can do more than initialize slot values. Consider the
`named_point' class, whose definition begins as follows:

     :- class named_point =
             [public name:atom,
              public x:float=1,
              public y:float=0].

     Self <- create(Name, X, Y) :-
             Self << name(Name),
             Self << x(X),
             Self << y(Y),
             assert(name_point(Name, Self)).

   Not only does the `create/3' message initialize the slots of a new
`named_point' object, but it also adds a `name_point/2' fact to the
Prolog database, allowing each new object to be found by its name.
(This create method does not require the `named_point' object to have a
unique name. Defining a `uniq_named_point' class is left as an
exercise.)

   An object is destroyed with the `destroy/1' command. Unlike
`create/2', `destroy/1' does not require that you define a `destroy'
method for a class. However, `destroy/1' will send a destroy message
(with no arguments) to an object before it is destroyed, if a `destroy'
method is defined for the object's class.

   If a `named_point' object is ever destroyed, the address of the
object stored in this name `point/2' fact is no longer valid. Hence,
there should be a corresponding destroy method that retracts it.

     Self <- destroy :-
             Self >> name(Name),
             retract(name_point(Name, Self)).

   Similar create and destroy methods can be defined for objects that
allocate their own separate memory or that announce their existence to
foreign code.

Instance Methods
----------------

Instance methods allow each object in a class to have its own method
for handling a specified message. For example, in a push-button class
it would be convenient for each instance (each push-button) to have its
own method for responding to being pressed.

   The declaration

     :- instance_method NAME/ARITY, ....

   inside a class definition states that the message NAME/ARITY
supports instance methods. If the class definition defines a method for
this message, it will be treated as a default method for the message.

   The `define_method/3' predicate installs a method for an object of
the class, and the `undefine_method/3' predicate removes that method.

   Suppose that the `date_stamp' class, defined earlier, declared an
instance method to print the year of a `date_stamp' instance.

     :- instance_method print_year/1.

     Self <- print_year(Stream) :-
             Self >> year(Y0),
             Y1 is YO + 1970,
             format(Stream, "~d", [Y1]).

   The arithmetic is necessary because UNIX dates are based on January
1, 1970.

   If a particular `date_stamp' object's date were to be printed in
Roman numerals, it could be given a different `print_year' method, using
the `define_method/3' predicate.

     | ?- create(date_stamp, DateObj),
          define_method(DateObj,
     		   print_year(Stream),
     		   print_roman_year(Stream, DateObj)).

   If this `date_stamp' object is created in 1994, a `print_year'
message sent to it would print the current year as

     MCMXCIV

   Defining the predicate `print_roman_year/2' is left as an exercise.
It must be able to access the `year' slot of a `date_stamp' object.
Because it is not defined by a method clause within the class
definition, `print_roman_year/2' cannot use the `get_slot/2' predicate.

   None of `instance_method/1', `define_method/3', `undefine_method/3'
specify a message operator. Instance methods can only be defined for
send messages.


File: sicstus.info,  Node: obj-inh,  Next: obj-tcl,  Prev: obj-scl,  Up: lib-objects

10.13.3 Inheritance
-------------------

* Menu:

* obj-inh-sih::                         Single Inheritance
* obj-inh-mih::                         Multiple Inheritance
* obj-inh-ask::                         Asking About Classes and Objects

   This section describes the additional features (and the additional
complexity) of defining classes with inheritance in SICStus Objects.
Most of what was said about classes in the previous section remains
true in these examples.


File: sicstus.info,  Node: obj-inh-sih,  Next: obj-inh-mih,  Up: obj-inh

10.13.3.1 Single Inheritance
............................

The simplest case is when a new class inherits some properties (slots
and methods) from a single superclass. That superclass may, in turn, be
defined in terms of its superclass, etc. The new class, its superclass,
its superclass's superclass (if any) and so on are all ancestors of the
new class.

Class Definitions
-----------------

The definition of a class with a single superclass begins with a
`class/1' directive of the form

     :- class CLASSNAME = [SLOTDEF, ...] +  SUPERCLASS.

where the list of SLOTDEF descriptions may be empty. In that case, the
definition can simplified to

     :- class CLASSNAME = SUPERCLASS.

   The class SUPERCLASS must be a defined class when this definition is
given.

   In SICStus Objects, a subclass inherits all the slots of its
superclass. And, by default, it inherits all the methods of its
superclass. The remainder of this section describes what the programmer
can do to control this inheritance.

Slots
-----

A class's slots are a combination of those explicitly defined in its
slot description list and the slots it inherits from its superclass. In
SICStus Objects, a class inherits all the slots of its superclass. It
follows that a class inherits all the slots of all its ancestors.

   The programmer's control over inheritance of slots is limited. It is
not possible to rename an inherited slot, nor is it possible to change
its type, unless it is a class slot. It is possible to change a slot's
initial value. And, it is possible to effectively change a slot's
visibility.

   To change the initial value or the type (when allowed) of a slot,
include a new SLOTDEF in the list of slot descriptions for the class,
with the same slot name and a new type or initial value. The type of a
class slot can only be changed to a subclass of the type of the
superclass's slot. The new initial value must still be a constant of the
appropriate type.

   The `named_point' class, defined earlier, could have better been
defined from the point class, which began as follows:

     :- class point =
             [public x:float=0,
              public y:float=0].

   The definition of the `named_point' class would then begin with

     :- class named_point =
             [public name:atom,
              public x:float=1.0] + point.

   This `named_point' class has public slots named `name', `x' and `y',
with the same types and initial values as the earlier `named_point'
definition, which did not use inheritance.  This `named_point' class
also inherits all the methods of the `point' class, which saves us from
having to write them again (and maintain them).

   A slot that was private or protected in a superclass may be defined
as public. This will cause get and put methods to be generated in the
subclass. A slot that was public in a superclass may be defined as
protected or private, but this does not prevent it from inheriting the
get and put methods of the superclass. For that, the `uninherit/1'
directive, defined below, is needed.

Methods
-------

In SICStus Objects, by default, a class inherits all the methods of its
superclass. The programmer has more control over the inheritance of
methods than the inheritance of slots, however. In particular, methods
can be uninherited and they can be redefined.

   To prevent a method from being inherited, use the `uninherit/1'
directive. For example, suppose that the class `point' is defined as
before. That is, its definition begins as follows:

     :- class point =
             [public x:float=0,
              public y:float=0].

   Because both slots are public, a put method is automatically
generated for each, which allows their values to be changed.

   The definition of a new class `fixed_point' might begin as follows:

     :- class fixed_point = point.

     :- uninherit
             point << (x/l),
             point << (y/l).

     Self <- create(X, Y) :-
             store_slot(x, X),
             store_slot(y, Y).

   The parentheses are necessary because of the precedences of the `<<'
and `/' operators.

   Because the put methods from `point' are not inherited, no instance
of the `fixed_point' class can change its `x' and `y' values once
created--unless the class definition contains another method for doing
so. The get methods are inherited from `point', however.

   To redefine a method, simply include method clauses for its message
within a class's definition. The new method clauses replace, or shadow,
the inherited method clauses for this class.

   Another way to prevent the `x' and `y' slots of the `fixed_point'
class from being modified would be to shadow the put methods. For
example, they might be redefined as

     Self << x(_) :-
             format(user_error, "cannot modify x slot value.~n.", []),
             fail.

     Self << y(_) :-
             format(user_error, "cannot modify y slot value.~n", []),
             fail.

   Now attempts to modify the `x' or `y' values of a fixed point object
generate a specific error message and fail.  A more complicated version
would raise an appropriate exception.

Send Super
----------

Even when a superclass's method is shadowed or uninherited, it is
possible to use the superclass's method inside a method clause for the
new class. This makes it possible to define a "wrapper" for the
superclass's method, which invokes the superclass's method without
having to duplicate its code. This technique works with all message
types.

   Sending a message to a superclass is done with a command of the form

     `super' MESSAGEOP MESSAGE

where MESSAGEOP is one of the message operators (`<<', `>>' or `<-')
and MESSAGE is a message defined for the superclass.  A generalization
of this syntax may be used to specify which superclass to send the
message to.  This is discussed in *Note obj-inh-mih::.

   Sending a message to a class's superclass can only be done within a
message clause.


File: sicstus.info,  Node: obj-inh-mih,  Next: obj-inh-ask,  Prev: obj-inh-sih,  Up: obj-inh

10.13.3.2 Multiple Inheritance
..............................

It is possible for a class to be defined with more than one superclass.
Because the class inherits properties from multiple superclasses, this
is referred to as multiple inheritance.

   Multiple inheritance is a complex and controversial topic. What
should be done about conflicting slot or method definitions? (This is
sometimes called a "name clash.") What should be done about slots that
are inherited from two or more superclasses, but that originate with a
common ancestor class? (This is sometimes called "repeated
inheritance".) Different systems take different approaches.

   SICStus Objects supports multiple inheritance in a limited but still
useful way. It does not allow repeated inheritance, and it places all
the responsibility for resolving name clashes on the programmer. This
section describes the multiple inheritance features of SICStus Objects.

Class Definitions
-----------------

The definition of a class with multiple superclasses begins with a
`class/1' directive of the form

     :- class CLASSNAME = [SLOTDEF, ...] + SUPERCLASS + ....

   The list of slot descriptions and the superclasses to the right of
the `=' can appear in any order, without changing the class being
defined. In fact, the slot descriptions can be partitioned into more
than one list, without changing the class. However, it is best to adopt
a fairly simple style of writing class definition and use it
consistently.

   Just as the slot names in a list of slot descriptions must be
distinct, superclass names should not be repeated.

Slots
-----

In SICStus Objects, the programmer has no control over multiple
inheritance of slots. All slots from all superclasses are inherited.
And, the superclasses should have no slot names in common.

   As a consequence, in SICStus Objects no superclasses of a class
should have a common ancestor. The only exception would be the unusual
case where that common ancestor has no slots.

Methods
-------

By default, all methods are inherited from all superclasses. Any of the
superclasses' methods can be uninherited, as described earlier, by
using the `uninherit/1' directive.

   If the same message is defined for more than one superclass, however,
you must choose at most one method to inherit for the message. You may
choose none. You may do this by defining a new method for the message
(shadowing the superclasses' methods), or by using the `uninherit/1'
directive, or by using the `inherit/1' directive.

   The following is considered a classic example of multiple
inheritance.

     :- class toy.             % no slots in this class

     Self >> size(small).

     Self >> rolls(false).

     :- end_class toy.

     :- class truck.         % no slots in this class

     Self >> size(large).

     Self >> rolls(true).

     :- end_class truck.

   The idea expressed in these definitions is that most toys are small
and do not roll.  On the other hand, most trucks are large, but they do
roll. A toy truck shares one feature with each class, but we can hardly
expect a compiler to choose the correct one.

   The definition of a new class, toy_truck, might begin with

     :- class toy_truck = toy + truck.

   Rather than redefine the get methods for `size' and `rolls', we can
specify which to inherit in two ways. One way is positive, stating
which to inherit, and the other way is negative, stating which not to
inherit.

   The positive version would be

     :- inherit
             toy >> (size/1),
             truck >> (rolls/1).

   This is more convenient when a message is defined in several
superclasses, because all but the chosen method are uninherited. And,
it is probably easier to understand.

   The negative version would be

     :- uninherit
             toy >> (rolls/1),
             truck >> (size/1).

   The `toy_truck' class would exhibit the same behavior with either
definition.

   It is possible to define methods that access the shadowed or
uninherited methods of the superclasses, by sending the message to the
superclasses. In the case of multiple inheritance, however, it may be
necessary to specify which superclass to send the message to.

   The `toy_truck' class, for example, might define these methods:

     Self >> uninherited_size(S) :-
             super(truck) >> size(S).

     Self >> uninherited_rolls(R) :-
             super(toy) >> rolls(R).

   They provide access to the unchosen methods from `toy_truck''s
superclasses.

   While these examples with the toy_truck class are clearly "toy"
examples, the same techniques can be used in more realistic cases.

Abstract and Mixin Classes
--------------------------

While SICStus Objects only supports a limited form of multiple
inheritance, its facilities are sufficient for working with so-called
"mixin classes".

   The idea is to construct similar classes by first defining a class
that contains the things the desired classes have in common. Typically,
this will be an "abstract class", which will have no instances itself.
Then, provide the features that differentiate the desired classes with
a set of mixin classes

   Mixin classes that have nothing in common can safely be mixed
together, to build the desired classes. The mixin classes will usually
be abstract classes, also, because they are too specialized for their
instances to be useful on their own.

   The date_stamp class defined earlier would make a good mixin class. A
similar `time_stamp' class might be (partially) defined as follows:

     :- class time_stamp =
             [hour:integer,
              minute:integer,
              second:integer].

     Self <- create :-
             time(time(Hour, Minute, Second)),
             store_slot(hour, Hour),
             store_slot(minute, Minute),
             store_slot(second, Second).

   Another mixin class might be used to "register" objects in the Prolog
database.

     :- class registry = [name:atom].

     Self <- create(Name) :-
             Self << name(Name),
             assert(registered(Name, Self)).

     Self <- destroy :-
             Self >> name(Name),
             retract(registered(Name, Self)).

   The `registry' mixin class could have been used with the `point'
class to define the `named_point' class, which was an example from an
earlier section.

   The ability to send a message to an object's superclass is useful
when working with mixin classes. Suppose the definition of a new class
begins with

     :- NEWCLASS = OLDCLASS + date + time + registry.

where OLDCLASS is some previously defined class that lacks the features
provided by the `date', `time' and `registry' classes. (In fact, they
should not have any slot names in common.)  Then its create method can
be defined by

     Self <- create(Name) :-
             super(OldClass) <- create,
             super(date) <- create,
             super(time) <- create,
             super(registry) <- create(Name).

   This avoids the need to duplicate the code in the create methods of
OldClass and all three mixin classes.


File: sicstus.info,  Node: obj-inh-ask,  Prev: obj-inh-mih,  Up: obj-inh

10.13.3.3 Asking About Classes and Objects
..........................................

It is possible to determine, at run time, what classes are defined, how
they are related by inheritance, what class an object belongs to, etc.
This section describes the predicates used for those purposes. Most of
the predicates involve the class hierarchy, so they are properly
described in the section on inheritance. But, several can be useful
even in programs that use only simple classes.

   Most of these predicates come in pairs, where one predicate involves
one class or its direct superclasses, and the other predicate involves
all ancestors. For example, the `class_superclass/2' and
`class_ancestor/2' predicates connect a currently defined class to its
superclass(es) and to all its ancestors, respectively.

   In all of these predicates, the ancestors of a class include not only
superclasses and their ancestors, but also the class itself. A class
cannot be a superclass of itself, by the rules of defining classes.
However, it is convenient to consider every class an ancestor of
itself, because then we may say that every property of a class is
defined in one of its ancestors, without having to say "the class
itself or a superclass or a superclass of a superclass, etc."

Objects
-------

The `class_of/2' predicate is used to test whether an object is of a
particular type or to determine the type of an object. Similarly, the
`descendant_of/2' predicate relates an object to all ancestors of its
class. (Remember that the object's class is, itself, an ancestor class
of the object.)

   Both require the first argument (the object) to be instantiated. That
is, the predicates cannot be used to find objects of a given class. If
you need to search among all the objects of a class, you must provide a
way to do it. One way to do this is to assert a fact connecting the
class name to every object, when it is created. The named_point example
of the previous section took that idea a step further by allowing each
object to have a different name.

   The `pointer_object/2' predicate relates an object's address (a
pointer) to the object. Remember that an instance of CLASS is
represented by a term of the form

     CLASS(ADDRESS)

   The `pointer_object/2' predicate requires that one of its arguments
be instantiated, but it may be either one. Hence, just by knowing the
address of an object (which possibly was returned by a foreign
function) it is possible to determine the object's type.

   Most Prolog programmers can safely ignore the `pointer_object/2'
predicate, unless they are using SICStus Objects with foreign functions
or with the Structs package.

Classes
-------

The `current_class/1' predicate is used to ask whether a class is
currently defined or to get the names of all currently defined classes.

   The `class_superclass/2' predicate is used to test whether one class
is a superclass of another, or to find a class's superclasses, or to
find a class's subclasses, or to find all subclass-superclass pairs.
The `class_ancestor/2' predicate is used in the same ways for the
ancestor relation between currently defined classes.

   As an example, the following goal finds all the ancestors of each
currently defined class.

     | ?- setof(C-As,
     	   (current_class(C),
     	    setof(A, class_ancestor(C,A), As)),
     	   L).

   It binds `L' to a list of terms of the form CLASS-ANCESTORLIST, with
one term for each currently defined class.

   Arguably, this predicate violates the principle of information
hiding, by letting you ask about how a class is defined.  Therefore, you
should generally avoid it.  It may be useful, however, in debugging and
in building programmer support tools.

Messages
--------

The `message/4' predicate is used to ask whether a message is defined
for a class or to find what messages are defined for a class, etc. It
does not distinguish between messages whose methods are defined in the
class itself and those that are inherited from a superclass.

   The `direct_message/4' predicate is used to ask whether a message is
not only defined for a class, but whether the method for that message
is defined in the class itself. It can also be used to determine which
methods are defined in a class. This ability to look inside a class
definition makes `direct_message/4' an egregious violator of the
principle of information hiding.  Thus it, like `class_ancestor/2',
should mainly be confined to use in programmer support applications.

   Both `message/4' and `direct_message/4' take the message operator as
an argument, along with the class, message name and arity. Hence it is
possible to use these predicates to ask about get, put or send messages.

   It is not possible to ask about a class's slots, nor should it be.
However, it is possible (and quite reasonable) to ask about the get and
put messages that are defined for a class. For example, the following
goal finds all the 1-argument messages that are defined for both the
get and put message operators in the class CLASS.

     | ?- setof(Message,
     	   (message(CLASS, <<, Msg, 1),
     	    message(CLASS, >>, Msg, 1)),
     	   L).

   There may or may not be slots corresponding to these messages; that
detail is hidden in the definition of CLASS. However, it should be
possible to use CLASS as if the slots were there.

   As an example, recall the polar coordinate interface to the point
class, which defined get and put methods for `r' and `theta', even
though data was represented inside an object by rectangular coordinates
`x' and `y'.


File: sicstus.info,  Node: obj-tcl,  Next: obj-tech,  Prev: obj-inh,  Up: lib-objects

10.13.4 Term Classes
--------------------

* Menu:

* obj-tcl-stcl::                        Simple Term Classes
* obj-tcl-rtrm::                        Restricted Term Classes
* obj-tcl-tce::                         Specifying a Term Class Essence

   Sometimes it is convenient to be able to send messages to ordinary
Prolog terms as if they were objects.  Prolog terms are easier to
create than objects, and unlike objects, they are automatically garbage
collected (see *Note obj-tech-lim::).  Of course, unlike objects,
Prolog terms cannot be modified.  However, when a particular class of
objects never needs to be dynamically modified, and doesn't need to be
subclassed, it may be appropriate to define it as a "term class".

   A term class is defined much like an ordinary class:  it begins with
a `:- class' directive defining the class and its slots, follows with
clauses defining the methods for this class, and ends with an `:-
end_class' directive, the end of the file, or another `:- class'
directive.  The only difference is in the form of the `:- class'
directive introducing a term class definition.


File: sicstus.info,  Node: obj-tcl-stcl,  Next: obj-tcl-rtrm,  Up: obj-tcl

10.13.4.1 Simple Term Classes
.............................

The simplest sort of term class declaration has the following form:
     :- class CLASSNAME = term(TERM).

   This declares that any term that unifies with TERM is an instance of
class CLASSNAME.  For example, you might declare:
     :- class rgb_color = term(color(_Red,_Green,_Blue)).

     color(R,_G,_B) >> red(R).
     color(_R,G,_B) >> green(G).
     color(_R,_G,B) >> blue(B).

     :- end_class rgb_color.

   This would declare any term whose principal functor is `color' and
arity is three to be an object of class `rgb_color'.  Given this
declaration, entering the goal
     color(0.5, 0.1, 0.6) >> blue(B)

would bind `B' to 0.6.

   Note that you cannot use `create/2' to create a term class instance.
Since they are just ordinary terms, you can create them the same way
you'd create any ordinary Prolog term.  Similarly, you cannot modify an
existing term class instance.

   You may specify a term class as the type of a slot of an ordinary
class.  This is effectively the same as specifing the type to be
`term'.  In particular, fetching and storing term class slots is not
very efficient.  Also, the default value for slots of term class type
is `'''; this is because not enough is known about a simple term class
to determine a better default.  For an explanation of how to avoid
these pitfalls, see *Note obj-tcl-tce::.


File: sicstus.info,  Node: obj-tcl-rtrm,  Next: obj-tcl-tce,  Prev: obj-tcl-stcl,  Up: obj-tcl

10.13.4.2 Restricted Term Classes
.................................

The intention of the `rgb_color' class presented above is to represent a
color as a triple of floating point numbers between 0.0 and 1.0.  But
the above definition does not restrict the arguments of the `color'
term in any way:  _any_ `color/3' term is considered to be an instance
of the `rgb_color' class.

   The second form of term class declaration allows you to specify
constraints on instances of a term class.  The form of such a
declaration is as follows:
     :- class CLASSNAME = term(TERM, CONSTRAINT).

   This declares that any term that unifies with TERM and satisfies
CONSTRAINT is an instance of class CLASSNAME.  The CONSTRAINT term is
an ordinary Prolog goal, which will usually share variables with TERM.

   To extend our `rgb_color' class example so that only `color/3' terms
whose arguments are all floats between 0.0 and 1.0 are instances of
`rgb_color', we would instead begin the definition as follows:
     :- class rgb_color =
              term(color(Red,Green,Blue),
                   (float(Red),   Red >= 0.0,   Red =< 1.0,
                    float(Green), Green >= 0.0, Green =< 1.0,
                    float(Blue),  Blue >= 0.0,  Blue =< 1.0)).

   Note the parentheses around the constraint in this example.  Whenever
the constraint contains multiple goals separated by commas, you will
need to surround the goal with parentheses.

   With this definition of the `rgb_color' class, only `color/3' terms
whose arguments are all floating point numbers between 0 and 1
inclusive will be considered to be instances of `rgb_color'.


File: sicstus.info,  Node: obj-tcl-tce,  Prev: obj-tcl-rtrm,  Up: obj-tcl

10.13.4.3 Specifying a Term Class Essence
.........................................

As mentioned above, it is possible to specify a term class as the type
of a slot of some other object.  For example, we might declare

     :- class colored_rectangle = [
             public origin:point,
             public size:size,
             public color:rgb_color].

   This will store an `rgb_color' object (i.e., a `color/3' term) in
the `color' slot of each `colored_rectangle' object.  Unfortunately,
though, SICStus Objects cannot tell what is the best way to store a
term object, and therefore it stores it the same way it stores a slot
declared to be of `term' type: using the Prolog database.  This has all
the efficiency disadvantages of `term' slots.  In this case, however,
we know that all that really needs to be saved in order to save an
`rgb_color' object is the three arguments.  We also know that each of
these arguments is a floating point number, and because precision isn't
terribly critical in representating colors, each of these numbers can
be stored as a `float', rather than a `double'.  In effect, we know
that the _essence_ of a `rgb_color' object is these three numbers; if
we have them, we can easily construct the `color/3' term.  If we
provide this information in the declaration of the `rgb_color' class,
SICStus Objects can store instances of the `rgb_color' class as 3
separate floats, rather than as a term, significantly improving the
performance of creating or destroying a `colored_rectangle' object, as
well as accessing or modifying its `color' slot.

   The essence of a term class is specified with the following form of
`class' declaration:
     :- class CLASSNAME = term(TERM, CONSTRAINT, ESSENCE).

where ESSENCE is of the form
     [NAME1:TYPE1=i[Variable1], NAME2:TYPE2=i[Variable2], ...]

and each NAME is a distinct atom naming a slot, each TYPE is a slot
type as specified in *Note obj-scl-slt::, and each VARIABLE is an
unbound variable appering in TERM.  Providing a term essence not only
makes storage of terms in ordinary object slots more efficient, it also
gives a name to each "essential" slot of the term class.  This allows
you to use `fetch_slot' to fetch the slots of this class.

   To extend our `rgb_color' example, we might introduce the `rgb_color'
class with this declaration:
     :- class rgb_color =
              term(color(Red,Green,Blue),
                   (float(Red),   Red >= 0.0,   Red =< 1.0,
                    float(Green), Green >= 0.0, Green =< 1.0,
                    float(Blue),  Blue >= 0.0,  Blue =< 1.0),
                   [red:float=Red, green:float=Green, blue:float=Blue]).

   This declaration defines the `rgb_color' class exactly as the
example declaration of the previous section: every `color/3' term whose
arguments are all floating point numbers between 0.0 and 1.0 inclusive
are instances of `rgb_color'.  The difference is that with this
declaration, ordinary classes that have slots of type `rgb_color', such
as the `colored_rectangle' example above, will be stored more
efficiently, and their `rgb_color' slots will be accessed and modified
much more efficiently.  Also, it will be possible to use
`fetch_slot(red, Red)' in the methods of the `rgb_color' class to fetch
to red component of the message recipient, and similarly for `green'
and `blue'.


File: sicstus.info,  Node: obj-tech,  Prev: obj-tcl,  Up: lib-objects

10.13.5 Technical Details
-------------------------

* Menu:

* obj-tech-syn::                        Syntax of Class Definitions
* obj-tech-lim::                        Limitations

   This section will be expanded in future versions of SICStus Objects.
For now, it provides a BNF grammar for the syntax of class definitions
and a short list of some limitations of SICStus Objects.


File: sicstus.info,  Node: obj-tech-syn,  Next: obj-tech-lim,  Up: obj-tech

10.13.5.1 Syntax of Class Definitions
.....................................

The following BNF grammar gives a concise description of the syntax of
class definitions. It assumes an understanding of Prolog syntax for the
following items: "variable", "atom", "compound_term", and "constant".
Slot types, particularly the `address', `class' and `pointer' types,
were discussed in an earlier section.


CLASS_DEF          ::= CLASS_BEGIN { CLAUSE | METHOD } CLASS_END

CLASS_BEGIN        ::= `:- class' CLASS_NAME OPT_CLASS_SPEC `.'

OPT_CLASS_SPEC     ::= EMPTY | `=' CLASS_SPEC

CLASS_SPEC         ::= MULTI_PARENT_OR_SLOTS | TERM_CLASS_SPEC

CLAUSE             ::= HEAD OPT_BODY `.'

HEAD               ::= ATOM | COMPOUND_TERM `.'

METHOD             ::= MESSAGE_HEAD OPT_BODY `.'

MESSAGE_HEAD       ::= MESSAGE_GOAL

CLASS_END          ::= `:- end_class' OPT_CLASS_NAME `.'
                   | EMPTY /* if followed by CLASS_BEGIN or EOF */

MESSAGE            ::= ATOM | COMPOUND_TERM

MULTI_PARENT_OR_SLOTS::= PARENT_OR_SLOTS { `+' PARENT_OR_SLOTS }

PARENT_OR_SLOTS    ::= CLASS_NAME | `[]' | `[' SLOT_DEF {`,' SLOT_DEF }
                   `]'

SLOT_DEF           ::= OPT_VISIBILITY SLOT_NAME `:' SLOT_TYPE
                   OPT_INIT_VALUE

OPT_VISIBILITY     ::= EMPTY | `private' | `protected' | `public'

OPT_INIT_VALUE     ::= EMPTY | `=' CONSTANT

TERM_CLASS_SPEC    ::= `term('TERM OPT_GOAL_ESSENCE`)'

OPT_GOAL_ESSENCE   ::= EMPTY | `,' GOAL OPT_ESSENCE

OPT_ESSENCE        ::= EMPTY | `,' ESSENCE

ESSENCE            ::= `['  VARIABLE `:' SLOT_TYPE { `,' VARIABLE `:'
                   SLOT_TYPE } `]'

OPT_BODY           ::= EMPTY | `:-' BODY

BODY               ::= MESSAGE_OR_GOAL { `,' MESSAGE_OR_GOAL }

MESSAGE_OR_GOAL    ::= MESSAGE_GOAL | GOAL

MESSAGE_GOAL       ::= VARIABLE MESSAGE_OPERATOR MESSAGE

MESSAGE_OPERATOR   ::= `<<' | `>>' | `<-'

OPT_CLASS_NAME     ::= EMPTY | CLASS_NAME

CLASS_NAME         ::= ATOM

SLOT_NAME          ::= ATOM

SLOT_TYPE          ::= `integer'
                   | `short'
                   | `char'
                   | `unsigned_short'
                   | `unsigned_char'
                   | `float'
                   | `double'
                   | `atom'
                   | `address'
                   | `term'
                   | CLASS_NAME
                   | `pointer(ATOM)'



File: sicstus.info,  Node: obj-tech-lim,  Prev: obj-tech-syn,  Up: obj-tech

10.13.5.2 Limitations
.....................

This section summarizes the current limitations of SICStus Objects.

Debugging
---------

When you debug SICStus Objects programs that were compiled using the
`obj_decl' module, you are tracing the translated version of your code.
This includes all method clauses and (some) message sending commands.

   The source-level debugger cannot connect compiled SICStus Objects
code with the source code.

Garbage Collection
------------------

There is no garbage collection of objects. It is the responsibility of
the programmer to keep track of unused objects. In particular, avoid
doing the following:

     | ?- create(CLASS, OBJECT).

   Unless the create message for CLASS made some provision for finding
the new object again, it is now lost. It cannot be used, and it cannot
be destroyed.

Multiple Inheritance
--------------------

The provisions for multiple inheritance in this version of SICStus
Objects are limited. In particular, there is no control over the
inheritance of slots, which makes repeated inheritance impossible.
However, it does support the mixin style of multiple inheritance.

Persistence
-----------

While objects are more persistent than Prolog variables, there is no
automatic way to save objects from one execution of your program to the
next. Hence they are less persistent than the clauses in the Prolog
database.

   If you need to save a set of objects from one Prolog session to
another, copy the objects to the Prolog database as terms, and save
them to a QOF file. Then, after you reload the QOF file, rebuild the
objects. Keep in mind that addresses are not valid from one session to
another.

   In short, there is no way to avoid initializing objects at run time.


File: sicstus.info,  Node: obj-exp,  Next: obj-glo,  Up: lib-objects

10.13.6 Exported Predicates
---------------------------

* Menu:

* obj-exp-send::                        <-/2
* obj-exp-put::                         <</2
* obj-exp-get::                         >>/2
* obj-exp-class::                       class/1
* obj-exp-class_ancestor::              class_ancestor/2
* obj-exp-class_method::                class_method/1
* obj-exp-class_superclass::            class_superclass/2
* obj-exp-class_of::                    class_of/2
* obj-exp-create::                      create/2
* obj-exp-current_class::               current_class/1
* obj-exp-debug_message::               debug_message/0
* obj-exp-define_method::               define_method/3
* obj-exp-descendant_of::               descendant_of/2
* obj-exp-destroy::                     destroy/1
* obj-exp-direct_message::              direct_message/4
* obj-exp-end_class::                   end_class/[0,1]
* obj-exp-fetch_slot::                  fetch_slot/2
* obj-exp-inherit::                     inherit/1
* obj-exp-instance_method::             instance_method/1
* obj-exp-message::                     message/4
* obj-exp-nodebug_message::             nodebug_message/0
* obj-exp-pointer_object::              pointer_object/2
* obj-exp-store_slot::                  store_slot/2
* obj-exp-undefine_method::             undefine_method/3
* obj-exp-uninherit::                   uninherit/1

   The following reference pages, alphabetically arranged, describe the
exported SICStus Objects predicates.  They can be imported by an
embedded command:

     :- use_module(library(objects)).


File: sicstus.info,  Node: obj-exp-send,  Next: obj-exp-put,  Up: obj-exp

10.13.6.1 `<-/2'
................

Synopsis
--------

+OBJ `<-' +MESG

Arguments
---------

OBJ
     "object"

MESG
     "term"


Description
-----------

Sends MESG to OBJ. A send message. The class of OBJ must have a method
defined for this message.

   A clause with `<-/2' as the principal functor of its head is a
method definition clause. Such clauses only occur within the scope of a
class definition. They are expanded at compile time.

Exceptions
----------

`instantiation_error'
     either argument is unbound.

`domain_error'
     MESG is not "callable" or OBJ is not a valid object.

`existence_error'
     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an `existence_error' exception will only be
raised if the code that sends the message is compiled with debugging
enabled (see `debug_message'), or if the message is not determined at
compile-time.  In other circumstances, the message will simply fail.

   Calls to the `<-/2' predicate will be compiled into more efficient
code if the `obj_decl' module is loaded at compile time.

See Also
--------

`<</2', `>>/2', `direct_message/4', `message/4'


File: sicstus.info,  Node: obj-exp-put,  Next: obj-exp-get,  Prev: obj-exp-send,  Up: obj-exp

10.13.6.2 `<</2'
................

Synopsis
--------

+OBJ `<<' +ATT

Arguments
---------

OBJ
     "object"

ATT
     "term"


Description
-----------

Send a message to `Obj' to store the value of `Att' in the object. A
put message. `Att' must be an attribute that can be stored in objects
of `Obj''s class.

   A clause with `<</2' as the principal functor of its head is a
method definition clause. Such clauses only occur within the scope of a
class definition. They are expanded at compile time.

   Put methods are automatically generated for public slots.

Exceptions
----------

`instantiation_error'
     either argument is unbound.

`domain_error'
     MESG is not "callable" or OBJ is not a valid object.

`existence_error'
     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an `existence_error' exception will only be
raised if the code that sends the message is compiled with debugging
enabled (see `debug_message'), or if the message is not determined at
compile-time.  In other circumstances, the message will simply fail.

   Calls to the `<</2' predicate will be compiled into more efficient
code if the `obj_decl' module is loaded at compile time.

See Also
--------

`<-/2', `>>/2', `direct_message/4', `message/4', `store_slot/2'


File: sicstus.info,  Node: obj-exp-get,  Next: obj-exp-class,  Prev: obj-exp-put,  Up: obj-exp

10.13.6.3 `>>/2'
................

Synopsis
--------

+OBJ `>>' +-ATT

Arguments
---------

OBJ
     "object"

ATT
     "term"


Description
-----------

Send a message to OBJ that fetches the value of ATT from the object. A
get message. ATT must be an attribute to fetch from OBJ's class.

   A clause with `>>/2' as the principal functor of its head is a
method definition clause. Such clauses only occur within the scope of a
class definition. They are expanded at compile time.

   Get methods are automatically generated for public slots.

Exceptions
----------

`instantiation_error'
     either argument is unbound.

`domain_error'
     MESG is not "callable" or OBJ is not a valid object.

`existence_error'
     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an `existence_error' exception will only be
raised if the code that sends the message is compiled with debugging
enabled (see `debug_message'), or if the message is not determined at
compile-time.  In other circumstances, the message will simply fail.

   Calls to the `>>/2' predicate will be compiled into more efficient
code if the `obj_decl' module is loaded at compile time.

See Also
--------

`<-/2', `<</2', `direct_message/4', `message/4', `fetch_slot/2'


File: sicstus.info,  Node: obj-exp-class,  Next: obj-exp-class_ancestor,  Prev: obj-exp-get,  Up: obj-exp

10.13.6.4 `class/1' "declaration"
.................................

Synopsis
--------

`:- class CLASSNAME.'

   `:- class CLASSNAME = [SLOTDEF, ...].'

   `:- class CLASSNAME = SUPER.'

   `:- class CLASSNAME = [SLOTDEF, ...] + SUPER + ....'

   `:- class CLASSNAME = term(TERM).'

   `:- class CLASSNAME = term(TERM, GOAL).'

   `:- class CLASSNAME = term(TERM, GOAL, ESSENCE).'

Arguments
---------

CLASSNAME
     "atom"

SLOTDEF
     "term"

SUPER
     "atom"


Description
-----------

The definition of class CLASSNAME begins with this `class/1' directive
and ends with the next `class/1' directive, the next `end_class/[0,1]'
directive, or the end of the file, whichever comes first.  All clauses
that look like method definitions within the scope of the class
definition (that is, which have one of `<-/2', `<</2' or `>>/2' as the
principal functors of their heads) are considered method definitions of
the class.

   You may provide as many slot definitions (SLOTDEF) and superclasses
(SUPER) as you like. All superclasses must be previously defined
classes.

   A slot definition (SlotDef) has the form

     VISIBILITY SLOTNAME:TYPE = INITIALVALUE

where VISIBILITY and `= INITIALVALUE' are optional.

   VISIBILITY is either `public', `protected', or `private'. If it is
omitted, the slot is private.

   SLOTNAME must be an atom.

   SLOTTYPE must be one of the following:

`integer'
     long signed integer

`integer_32'
     32-bit signed integer

`integer_16'
     16-bit signed integer

`integer_8'
     8-bit signed integer

`unsigned'
     long unsigned integer

`unsigned_32'
     32-bit unsigned integer

`unsigned_16'
     16-bit unsigned integer

`unsigned_8'
     8-bit unsigned integer

`float'
     64-bit floating point number

`float_32'
     32-bit floating point number

`atom'
     Prolog atom.

`address'
     Long address.

`term'
     Prolog term.

`CLASS'
     Pointer to an instance of CLASS, which must be a previously
     defined class.

`pointer(TYPE)'
     Like `address', except that access to this slot yields, and update
     of this slot expects, a unary term whose functor is TYPE

   INITIALVALUE may be any constant appropriate for the slot's type.

   TERM, if specified, is any compound Prolog term.  Class declarations
of any of the last three forms introduce a "term class", which defines
any term that unifies with TERM as an instance of the class being
defined.

   GOAL, if specified, is any Prolog goal.  This goal may be used to
restrict which terms that unify with TERM will be considered to be
instance of the class being defined.  The default GOAL is `true'.
Other than when it is `true', GOAL will usually share variables with
TERM.

   ESSENCE, if specified, is a list of terms of the form
     VARIABLE:TYPE

where VARIABLE is a variable apprearing somewhere in TERM and TYPE is
one of the possible SLOTTYPE types listed above.  There should be a
VARIABLE`:'TYPE pair for every variable in TERM.  By specifying an
essence, you permit much more space- and time-efficient storage of and
access to term slots.

Caveat
------

Note that every class for which you want to be able to create instances
must define at least one create method.

Examples
--------

The following class definition is for a class named `point', with two
public slots, named `x' and `y'. Both slots are of type `integer' and
have initial values of 1 and 2, respectively.

     :- class point =
             [public x:integer=1,
              public y:integer=2].

     Self <- create.
     :- end_class point.

   Because the slots are public, they have get and put methods
generated automatically. Because the class has a create method defined,
it is possible to create an instance with the command

     | ?- create(point, PointObj).

which creates a `point' object and binds the variable `PointObj' to it.

   Using the `point' class, we could create a class, `named_point',
which has an extra public slot, `name'.

     :- class named_point =
             [public name:atom] + point.

     Self <- create(Name, X, Y) :-
             Self << name(Name),
             Self << x(X),
             Self << y(Y).

     :- end_class named_point.

   The only way to create a `named_point' object requires specifying
values for all three slots.

See Also
--------

`end_class/[0,1]'

   *Note obj-scl::, *Note obj-tcl::.


File: sicstus.info,  Node: obj-exp-class_ancestor,  Next: obj-exp-class_method,  Prev: obj-exp-class,  Up: obj-exp

10.13.6.5 `class_ancestor/2'
............................

Synopsis
--------

`class_ancestor(?CLASS, ?ANC)'

Arguments
---------

CLASS
     "atom"

ANC
     "atom"


Description
-----------

ANC is CLASS or an ancestor class of CLASS.

See Also
--------

`class_superclass/2'


File: sicstus.info,  Node: obj-exp-class_method,  Next: obj-exp-class_superclass,  Prev: obj-exp-class_ancestor,  Up: obj-exp

10.13.6.6 `class_method/1' "declaration"
........................................

Synopsis
--------

`:- class_method +NAME/+ARITY, ... .'

Arguments
---------

NAME
     "atom"

ARITY
     "integer"


Description
-----------

Declares that a class's method for send message NAME/ARITY is an
ordinary method, not an instance method.

   Used when the class being defined inherits an instance method from a
superclass, to allow the class to define a non-instance method for the
message. A descendent class may still declare this to be an instance
method, so the same message may be an instance method for some classes
and an ordinary class method for others.

   Must occur within the scope of the class definition. Only applies to
send messages.

See Also
--------

`instance_method/1'


File: sicstus.info,  Node: obj-exp-class_superclass,  Next: obj-exp-class_of,  Prev: obj-exp-class_method,  Up: obj-exp

10.13.6.7 `class_superclass/2'
..............................

Synopsis
--------

`class_superclass(?CLASS, ?SUPER)'

Arguments
---------

CLASS
     "atom"

SUPER
     "atom"


Description
-----------

CLASS is an immediate subclass of SUPER.

See Also
--------

`class_ancestor/2'


File: sicstus.info,  Node: obj-exp-class_of,  Next: obj-exp-create,  Prev: obj-exp-class_superclass,  Up: obj-exp

10.13.6.8 `class_of/2'
......................

Synopsis
--------

`class_of(+OBJ, -CLASS)'

Arguments
---------

OBJ
     "object"

CLASS
     "atom"


Description
-----------

CLASS is the class of OBJ.

Exceptions
----------

`instantiation_error'
     OBJ is unbound.

`type_error'
     OBJ is not a valid object.

See Also
--------

`pointer_object/2'


File: sicstus.info,  Node: obj-exp-create,  Next: obj-exp-current_class,  Prev: obj-exp-class_of,  Up: obj-exp

10.13.6.9 `create/2'
....................

Synopsis
--------

`create(+DESCRIPTOR,-OBJ)'

Arguments
---------

DESCRIPTOR
     "term"

OBJ
     "object"


Description
-----------

OBJ is a newly created and initialized object. Descriptor is a term
describing the object to create. After memory is allocated and any slot
initializations are performed, a create message is sent to the object.

   The functor of DESCRIPTOR indicates the class to create. The
arguments of the create message are the arguments of DESCRIPTOR.

Exceptions
----------

`instantiation_error'
     DESCRIPTOR is unbound.

`domain_error'
     DESCRIPTOR is not a valid `create' descriptor.

`resource_error'
     unable to allocate enough memory for object.

Caveat
------

You must have a `create/N' method for every arity N you want to be able
to use in creating instances of a class.  This includes arity 0.  If no
such method exists, a domain error will be raised.

Examples
--------

Given the class definition

     :- class point =
                     [public x:integer=1,
                      public y:integer=2].

     Self <- create.
     Self <- create(X, Y) :-
                     Self << x(X),
                     Self << y(Y).
     :- end_class point.

the command

     | ?- create(point, Point1).

creates a `point' object, with the default slot values for `x' and `y',
and binds variable `Point1' to the new object. The command

     | ?- create(point(10,15), Point2).

creates a `point' object with values 10 and 15 for slots `x' and `y',
respectively, and binds variable `Point2' to the new object.

See Also
--------

`destroy/1'


File: sicstus.info,  Node: obj-exp-current_class,  Next: obj-exp-debug_message,  Prev: obj-exp-create,  Up: obj-exp

10.13.6.10 `current_class/1'
............................

Synopsis
--------

`current_class(*CLASS)'

Arguments
---------

CLASS
     "atom"


Description
-----------

`Class' is the name of a currently defined class.


File: sicstus.info,  Node: obj-exp-debug_message,  Next: obj-exp-define_method,  Prev: obj-exp-current_class,  Up: obj-exp

10.13.6.11 `debug_message/0' "declaration"
..........................................

Synopsis
--------

`:- debug_message.'

Description
-----------

Prolog clauses following this directive will be compiled to send
messages "carefully."

   That is, a message sent to an object that does not understand the
message will raise an exception, which describes both the message and
the object receiving it. This also catches attempts to send an unbound
message, to send a message to an unbound object, and similar errors.

See Also
--------

`nodebug_message/0'


File: sicstus.info,  Node: obj-exp-define_method,  Next: obj-exp-descendant_of,  Prev: obj-exp-debug_message,  Up: obj-exp

10.13.6.12 `define_method/3'
............................

Synopsis
--------

`define_method(+OBJ, +MESSAGE, +BODY)'

Arguments
---------

OBJ
     "object"

MESSAGE
     "term"

BODY
     "callable"


Description
-----------

Install BODY as the method for MESSAGE in the instance OBJ.  Following
the execution of this goal, sending MESSAGE to OBJ will execute BODY,
rather than the default method or a method previously defined with
`define_method/3'.

   MESSAGE must have been declared to be an instance method for the
class of OBJ.

Exceptions
----------

`instantiation_error'
     any argument is unbound.

`type_error'
     OBJ is not a compound term, or MESSAGE or BODY is not "callable".

`domain_error'
     MESSAGE does not specify an instance method for the class of OBJ,
     or BODY include a goal to fetch or store a non-existent slot.

See Also
--------

`instance_method/1', `undefine_method/3'


File: sicstus.info,  Node: obj-exp-descendant_of,  Next: obj-exp-destroy,  Prev: obj-exp-define_method,  Up: obj-exp

10.13.6.13 `descendant_of/2'
............................

Synopsis
--------

`descendant_of(+OBJ, ?CLASS)'

Arguments
---------

OBJ
     "object"

CLASS
     "atom"


Description
-----------

OBJ is an instance of CLASS or of a descendant of CLASS.

Exceptions
----------

`instantiation_error'
     OBJ is unbound.

`type_error'
     OBJECT is not a valid object.

See Also
--------

`class_ancestor/2', `class_of/2', `class_superclass/2'


File: sicstus.info,  Node: obj-exp-destroy,  Next: obj-exp-direct_message,  Prev: obj-exp-descendant_of,  Up: obj-exp

10.13.6.14 `destroy/1'
......................

Synopsis
--------

`destroy(+OBJ)'

Arguments
---------

OBJ
     "object"


Description
-----------

Dispose of OBJ.

   First send a `destroy' message to OBJ, if such a message is defined
for its class. A `destroy' message takes no argument.  Unlike
`create/2', it is possible to destroy instances of a class even if it
defines no `destroy' methods.

Exceptions
----------

`instantiation_error'
     OBJ is unbound.

`type_error'
     OBJECT is not a valid object.

See Also
--------

`create/2'


File: sicstus.info,  Node: obj-exp-direct_message,  Next: obj-exp-end_class,  Prev: obj-exp-destroy,  Up: obj-exp

10.13.6.15 `direct_message/4'
.............................

Synopsis
--------

`direct_message(?CLASS, ?OP, ?NAME, ?ARITY)'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"


Description
-----------

NAME/ARITY is an OP message directly understood (defined rather than
inherited) by instances of CLASS.  This predicate is used to test
whether a message is defined for a class.

   OP is one of `<-', `>>', or `<<', specifying the kind of message.

   This predicate violates the principle of information hiding by
telling whether the method for a message is defined within a class or
inherited. Hence its use in ordinary programs is discouraged.  It may
be useful, however, during debugging or in developing programming
support tools.

See Also
--------

`<-/2', `<</2', `>>/2', `message/4'


File: sicstus.info,  Node: obj-exp-end_class,  Next: obj-exp-fetch_slot,  Prev: obj-exp-direct_message,  Up: obj-exp

10.13.6.16 `end_class/[0,1]' "declaration"
..........................................

Synopsis
--------

`:- end_class.'

   `:- end_class +CLASSNAME.'

Arguments
---------

CLASSNAME
     "atom"


Description
-----------

A class definition continues until the next `end_class/[0,1]'
directive, the next `class/1' directive, or the end of the file,
whichever comes first.

   It is not possible to nest one class definition within another.

   All clauses that look like method definitions (that is, which have
one of `<-/2', `<</2' or `>>/2' as the principal functors of their
heads) are considered to be method definitions for the class.

Caveat
------

The argument to `end_class/1', if specified, must match the class name
of the preceding `class/1' directive.

See Also
--------

`class/1'


File: sicstus.info,  Node: obj-exp-fetch_slot,  Next: obj-exp-inherit,  Prev: obj-exp-end_class,  Up: obj-exp

10.13.6.17 `fetch_slot/2'
.........................

Synopsis
--------

`fetch_slot(+SLOTNAME, -VALUE)'

Arguments
---------

SLOTNAME
     "atom"

VALUE
     "term"


Description
-----------

Fetch VALUE from the slot specified by SLOTNAME.

   This predicate may only appear in the body of a method clause, and it
always operates on the object to which that message is sent. It cannot
be used to directly access the slots of another object.

Exceptions
----------

`instantiation_error'
     SLOT is unbound.

`domain_error'
     SLOT is not the name of a slot of the current class.

`permission_error'
     SLOT is a private slot of a superclass.

See Also
--------

`>>/2', `store_slot/2'


File: sicstus.info,  Node: obj-exp-inherit,  Next: obj-exp-instance_method,  Prev: obj-exp-fetch_slot,  Up: obj-exp

10.13.6.18 `inherit/1' "declaration"
....................................

Synopsis
--------

`:- inherit +CLASSNAME +OP +NAME/+ARITY, ....'

Arguments
---------

CLASSNAME
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"


Description
-----------

CLASSNAME names the class from which the message should be inherited,
OP indicates which kind of message it is, and NAME and ARITY indicate
the name and arity of the message to be inherited. You may include
several inheritance specifications in one directive.

Caveat
------

Be careful of the precedences of the message operator and the `/'
operator. You may need to use parentheses.

Examples
--------

Suppose classes `toy' and `truck' are defined as follows:

     :-class toy.
     Self <- create.
     Self >> size(small).
     Self >> rolls(false).
     :- end_class toy.

     :- class truck.
     Self <- create.
     Self >> size(small).
     Self >> rolls(true).
     :- end_class truck.

   Then `toy_truck' inherits its size from `toy' and the fact that it
rolls from `truck':

     :- class toy_truck = toy + truck.
     :- inherit
             toy <- (create/O),
             toy <- (size/1),
             truck <- (rolls/1).
     :- end_class toy_truck.

   Note that this is just a toy example.

See Also
--------

`uninherit/1'


File: sicstus.info,  Node: obj-exp-instance_method,  Next: obj-exp-message,  Prev: obj-exp-inherit,  Up: obj-exp

10.13.6.19 `instance_method/1' "declaration"
............................................

Synopsis
--------

`:- instance_method +NAME/+ARITY.'

Arguments
---------

NAME
     "atom"

ARITY
     "integer"


Description
-----------

The message NAME/ARITY is declared to support instance methods in a
class. This means that instances of this class, and its descendants,
may each define their own methods for this message.

   A method defined for this message by the class is considered the
default method for the message. An instance that does not define its
own method uses the default. Defining a new method overrides this
default method; there is no need to explicitly remove it.

   An instance method is installed in an instance of the class with the
`define_method/3' predicate. An instance method is removed from an
instance of the class, reverting to the default method, with the
`undefine_method/3' predicate.

   Must occur within the scope of the class definition. Only applies to
send messages.

See Also
--------

`class_method/1', `define_method/3', `undefine_method/3'


File: sicstus.info,  Node: obj-exp-message,  Next: obj-exp-nodebug_message,  Prev: obj-exp-instance_method,  Up: obj-exp

10.13.6.20 `message/4'
......................

Synopsis
--------

`message(?CLASS, ?OP, ?NAME, ?ARITY)'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"


Description
-----------

NAME/ARITY is an OP message understood by instances of CLASS.  This
predicate is used to test whether a message is either defined for or
inherited by a class.

   OP is one of `<-', `>>', or `<<', specifying the kind of message.

See Also
--------

`<-/2', `<</2', `>>/2', `direct_message/4'


File: sicstus.info,  Node: obj-exp-nodebug_message,  Next: obj-exp-pointer_object,  Prev: obj-exp-message,  Up: obj-exp

10.13.6.21 `nodebug_message/0' "declaration"
............................................

Synopsis
--------

`:- nodebug_message.'

Description
-----------

Prolog clauses following this directive are no longer compiled to send
messages "carefully."

See Also
--------

`debug_message/0'


File: sicstus.info,  Node: obj-exp-pointer_object,  Next: obj-exp-store_slot,  Prev: obj-exp-nodebug_message,  Up: obj-exp

10.13.6.22 `pointer_object/2'
.............................

Synopsis
--------

`pointer_object(+ADDR,-OBJ)'

   `pointer_object(-ADDR,+OBJ)'

Arguments
---------

ADDR
     "integer"

OBJ
     "object"


Description
-----------

ADDR is the address of object OBJ. This can be used to get the address
of an object or to get an object given its address.

Exceptions
----------

`instantiation_error'
     both OBJ and ADDR are unbound.

`type_error'
     ADDR is not an integer.


File: sicstus.info,  Node: obj-exp-store_slot,  Next: obj-exp-undefine_method,  Prev: obj-exp-pointer_object,  Up: obj-exp

10.13.6.23 `store_slot/2'
.........................

Synopsis
--------

`store_slot(+SLOTNAME, +NEWVALUE)'

Arguments
---------

SLOTNAME
     "atom"

NEWVALUE
     "term"


Description
-----------

Store NEWVALUE in the slot specified by SLOTNAME.

   This predicate may only appear in the body of a method clause, and it
always operates on the object to which that message is sent. It cannot
be used to directly modify the slots of another object.

Exceptions
----------

`instantiation_error'
     either argument is unbound.

`type_error'
     NEWVALUE is not of the appropriate type for SLOTNAME.

`domain_error'
     SLOTNAME is not the name of a slot of the current class.

`permission_error'
     SLOTNAME is a private slot of a superclass.

See Also
--------

`<</2', `fetch_slot/2'


File: sicstus.info,  Node: obj-exp-undefine_method,  Next: obj-exp-uninherit,  Prev: obj-exp-store_slot,  Up: obj-exp

10.13.6.24 `undefine_method/3'
..............................

Synopsis
--------

`undefine_method(+OBJ, +NAME, +ARITY)'

Arguments
---------

OBJ
     "object"

NAME
     "atom"

ARITY
     "integer"


Description
-----------

Remove OBJ's current instance method for the NAME/ARITY message. After
executing this goal, sending this message to OBJ executes the class's
default method for the message.

   NAME/ARITY must have been declared to be an instance method for the
class of OBJ.

   If OBJ has no current instance method for the NAME/ARITY message,
the predicate has no effect.

Exceptions
----------

`instantiation_error'
     any argument is unbound.

`type_error'
     OBJ is not a compound term, NAME is not an atom, or ARITY is not
     an integer.

`domain_error'
     MESSAGE does not specify an instance method for the class of OBJ.

See Also
--------

`define_method/3', `instance_method/1'


File: sicstus.info,  Node: obj-exp-uninherit,  Prev: obj-exp-undefine_method,  Up: obj-exp

10.13.6.25 `uninherit/1' "declaration"
......................................

Synopsis
--------

`:- uninherit +CLASS +OP +NAME/+ARITY, ... .'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"


Description
-----------

This prevents the class within whose scope this directive appears from
inheriting the NAME/ARITY method of type OP from ancestor CLASS.

   If CLASS is unbound, the specified message is uninherited from all
ancestors that define it.

Caveat
------

Note that if you define a message for your class, you do not need to
uninherit that message from its superclasses: it will automatically be
shadowed.

   Be careful of the precedences of the message operator and the `/'
operator. You may need to use parentheses.

Examples
--------

     :- uninherit someclass << (foo/1),
                  someclass >> (foo/1).

This prevents the get and put methods for the slot `foo' from being
inherited from any ancestors of class `someclass'. In effect, it makes
the `foo' slot a protected slot for this class.

See Also
--------

`inherit/1'


File: sicstus.info,  Node: obj-glo,  Next: obj-bas,  Prev: obj-exp,  Up: lib-objects

10.13.7 Glossary
----------------

"abstract class"
     A class that cannot have instances. Abstract classes are helpful
     in designing a class hierarchy, to contain the common parts of
     several concrete classes.

"ancestor"
     One of a class's superclasses, one of its superclasses's
     superclasses, etc. Sometimes, for convenience, ancestor includes
     the class itself, along with its proper ancestors.

"child"
     A synonym for subclass.

"class"
     A class is defined by a description of the information its
     instances contain and the messages they respond to.  Every object
     is an instance of one and only one class.

"concrete class"
     A class that can have instances. Most classes are concrete.

"create method"
     Specifies what actions should be taken when an instance of a class
     is created. A create method frequently provides initial slot
     values or specifies an action to be performed by the new object. A
     create message is sent to each new object by the `create/2'
     predicate. A create message is a kind of send message.

"descendant"
     One of a class's subclasses, one of its subclasses's subclasses,
     etc. Sometimes the word descendant includes the class itself,
     along with its proper descendants.

"destroy method"
     Specifies what actions should be taken when an instance of a class
     is destroyed. A destroy message is sent to an object by the
     `destroy/1' predicate. A destroy message is a kind of send message.

"direct slot access"
     Fetching or storing a slot value without sending a message to the
     object. This should be used with care!

     SICStus Objects allows direct access to a class's slots only
     within its method definitions, via the `fetch_slot/2' and
     `store_slot/2' predicates.

"get message"
     A message that inquires about some aspect of an object.  Typically
     used to fetch slot values. Get methods are automatically generated
     for public slots. Get messages are written with the `>>' operator.

"inheritance"
     The process by which a class's slots and methods are determined
     from an ancestor.

"initial value"
     The value a slot is initialized to when an object is created.
     Every slot has a default initial value, which depends upon its
     type. You may specify different initial values in a class
     definition.

"instance"
     Another word for object. The word instance draws attention to the
     class of which the object is an instance.

"instance method"
     A method that may be defined differently for each instance of a
     class. The class may have a default method for this message, which
     is overridden by installing an instance method for a particular
     object.

"message"
     A command to an object to perform an operation or to modify
     itself, or an inquiry into some aspect of the object.  In SICStus
     Objects, a message is either a get message, a put message or a
     send message. The syntax for sending a message to an object is

          OBJECT OPERATOR MESSAGE


     where OPERATOR is one of the following:

    `>>'
          get message

    `<<'
          put message

    `<-'
          send message

"method"
     A class's implementation of a particular message. You send
     messages to an object, but you define methods for a class.

"method clause"
     A Prolog clause used to define a method for a class. A method
     clause has one of `<-/2', `<</2' or `>>/2' as the principal
     functor of its head, and it can only appear within the scope of
     its class's definition. A method's definition may contain more
     than one message clause.

"mixin class"
     A class that is intended to be combined (mixed in) with other
     classes, via multiple inheritance, to define new subclasses.

"multiple inheritance"
     When a class names more than one superclass.  Typically, it
     inherits slots and methods from each.  In SICStus Objects, two
     different superclasses should not use the same slot name. And, if
     a message is defined by more than one superclass, the class
     definition must specify which method to inherit.

"object"
     A modifiable data item that holds information and responds to
     messages. Another word for instance.

"parent class"
     A synonym for superclass.

"private slot"
     A private slot is, by default, only accessible within methods of
     the class itself.  Not even the descendants of the class may
     access its private slots, except through the class's methods. Get
     and put methods are not automatically generated for a private
     slot, so it is only accessed via the methods you define. If the
     visibility of a slot is not specified, it is private, rather than
     public or protected.

"protected slot"
     A protected slot is, by default, only accessible within methods of
     the class itself and its descendants. Get and put methods are not
     automatically generated for a protected slot, so it is only
     accessed via the methods you define. If the visibility of a slot
     is not specified, it is private, rather than public or protected.


     SICStus Objects `protected' is similar to `protected' in C++.

"public slot"
     A public slot is accessible via its own get and put methods, which
     are generated for it automatically. If no visibility is specified,
     a slot is private, rather than public or protected.

"put message"
     A message that modifies some aspect of an object.  Typically used
     to store slot values. Put methods are automatically generated for
     public slots. Put messages are written with the `<<' operator.

"send message"
     The most common sort of message. Used for performing an operation
     on an object or for performing an action that depends upon an
     object. Send messages are written with the `<-' operator.

"send super"
     When a method for a class executes a shadowed superclass's method.
     This allows a class to put a "wrapper" around its superclass's
     method, making it unnecessary to duplicate the method just to make
     a small extension to it.

"shadow"
     When a class defines its own method for a message defined by one
     of its ancestors, the new method hides or "shadows" the ancestor's
     method. The new class's descendants will inherit its method for
     that message, rather than its ancestors. That is, a class always
     inherits the "closer" of two methods for a message.

"slot"
     A part of an instance that holds an individual datum.  Like a
     member of a C struct or a field of a Pascal record.

"subclass"
     A class that is a more specific case of a particular class.  This
     is the opposite of superclass. A class does not name its
     subclasses; they are inferred.

"superclass"
     A class that is a more general case of a particular class.  Each
     class lists its superclasses.

"term class"
     A class whose instances are represented as ordinary Prolog terms.
     The functor of these objects need not be the name of the class,
     and the arity need not be one.

"term slot"
     A slot that can hold any Prolog term.

"uninherit"
     Specify that a method from a superclass should not be inherited.
     This is similar to shadowing the superclass's method, but does not
     specify a replacement for it.

"visibility"
     A slot may be defined to be either `public', `protected', or
     `private'.  By default, if no visibility is specified, a slot is
     private.



File: sicstus.info,  Node: lib-ordsets,  Next: lib-process,  Prev: lib-objects,  Up: The Prolog Library

10.14 Ordered Set Operations--`library(ordsets)'
================================================

This library module provides operations on sets represented as ordered
lists with no duplicates.  Thus `{c,r,a,f,t}' would be `[a,c,f,r,t]'.
The ordering is defined by the `@<' family of term comparison
predicates, which is the ordering used by `sort/2' and `setof/3'.

   The benefit of the ordered representation is that the elementary set
operations can be done in time proportional to the sum of the argument
sizes rather than their product.  You should use the operations defined
here in preference to those in `library(sets)' unless there is a
compelling reason why you can't.  Some of the unordered set routines,
such as `member/2', `length/2' and `select/3' can be used unchanged on
ordered sets; feel free so to use them.

   There is no `ordset_to_list/2', as an ordered set is a list already.
Exported predicates:

`is_ordset(+LIST)'
     is true when LIST is a list of terms [T1,T2,...,TN] and the terms
     are strictly increasing: T1 @< T2 @< ... @< TN.  The output of
     `sort/2' always satisfies this test.  Anything which satisfies
     this test can be given to the predicates in this file, regardless
     of where you got it.

`list_to_ord_set(+LIST, -SET)'
     is true when SET is the ordered representation of the set
     represented by the unordered representation List.  The only reason
     for giving it a name at all is that you may not have realised that
     `sort/2' could be used this way.

`ord_add_element(+SET1, +ELEMENT, -SET2)'
     Equivalent to `ord_union(SET1, [ELEMENT], SET2)', but a bit faster.

`ord_del_element(+SET1, +ELEMENT, -SET2)'
     Equivalent to `ord_subtract(SET1, [ELEMENT], SET2)', but a bit
     faster.

`ord_disjoint(+SET1, +SET2)'
     is true when the two ordered sets have no element in common.

`ord_intersect(+SET1, +SET2)'
     is true when the two ordered sets have at least one element in
     common.

`ord_intersection(+SET1, +SET2, -INTERSECTION)'
     is true when INTERSECTION is the ordered representation of SET1
     and SET2, provided that SET1 and SET2 are ordered sets.

`ord_intersection(+SET1, +SET2, ?INTERSECTION, ?DIFFERENCE)'
     is true when INTERSECTION is the intersection of SET1 and SET2,
     and DIFFERENCE is SET2 \ SET1 (like in ord_union/4), provided that
     SET1 and SET2 are ordered sets.

`ord_intersection(+LISTOFSETS, -INTERSECTION)'
     is true when LISTOFSETS is a nonempty proper list of ordered sets
     and INTERSECTION is their intersection.

`ord_member(+ELT, +SET)'
     is true when ELT is a member of SET.  Suggested by Mark Johnson.

`ord_nonmember(+ITEM, +SET)'
     is true when the given ITEM is _not_ an element of the given SET.

`ord_seteq(+SET1, +SET2)'
     is true when the two arguments represent the same set.  Since they
     are assumed to be ordered representations, they must be identical.

`ord_setproduct(+SET1, +SET2, -PRODUCT)'
     If SET1 and SET2 are ordered sets, PRODUCT will be an ordered set
     of X1-X2 pairs.  Note that we cannot solve for SET1 and SET2,
     because there are infinitely many solutions when PRODUCT is empty,
     and may be a large number in other cases.

`ord_subset(+SET1, +SET2)'
     is true when every element of the ordered set SET1 appears in the
     ordered set SET2.

`ord_subtract(+SET1, +SET2, -DIFFERENCE)'
     is true when DIFFERENCE contains all and only the elements of SET1
     which are not also in SET2.

`ord_symdiff(+SET1, +SET2, -DIFFERENCE)'
     is true when DIFFERENCE is the symmetric difference of SET1 and
     SET2.

`ord_disjoint_union(+SET1, +SET2, -UNION)'
     is true when SET1 and SET2 (given to be ordered sets) have no
     element in common, and UNION is their union.  The meaning is the
     same as
              ord_disjoint(Set1, Set2),
              ord_union(Set1, Set2, Union)
     but it is more efficient.

`ord_union(+SET1, +SET2, -UNION)'
     is true when UNION is the union of SET1 and SET2.  Note that when
     something occurs in both sets, we want to retain only one copy.

`ord_union(+OLDSET, +NEWSET, -UNION, -REALLYNEW)'
     is true when UNION is NEWSET U OLDSET and REALLYNEW is NEWSET \
     OLDSET.  This is useful when you have an iterative problem, and
     you're adding some possibly new elements (NEWSET) to a set
     (OLDSET), and as well as getting the updated set (UNION) you would
     like to know which if any of the "new" elements didn't already
     occur in the set (REALLYNEW).

`ord_union(+LISTOFSETS, -UNION)'
     is true when LISTOFSETS is given as a proper list of ordered sets
     and UNION is their union.  Letting K be the length of LISTOFSETS,
     and N the sum of the sizes of its elements, the cost is O(N LG K).

`ordset_order(+XS, +YS, -R)'
     is true when R is `<', `=', or `>' according as XS is a subset of
     YS, equal to YS, or a superset of YS.  XS and YS are ordered sets.


File: sicstus.info,  Node: lib-process,  Next: lib-queues,  Prev: lib-ordsets,  Up: The Prolog Library

10.15 Process Utilities--`library(process)'
===========================================

This package contains utilities for process creation.

   A process is represented by a "process reference", a ground compound
term. Both SICStus and the operating system maintain a state for each
such process reference and they must therefore be released, either
explicitly with `process_release/1' or implicitly by
`process_wait/[2,3]'. Process references are created with
`process_create/[2,3]' if explicitly requested with the `process/1'
option. Process references are required in order to obtain the exit
status of a process. Many of the predicates can accept a numeric
operating system process id ("PID") but since process ids are subject
to re-use by the OS this is less reliable and does not work if the
process has already exited.  Run `ls' on a home directory in a subshell
under UNIX:
     | ?- absolute_file_name('$SHELL', Shell),
          absolute_file_name('~/', Dir),
          process_create(Shell, ['-c', [ ls, ' ', file(Dir) ]]).
Run `notepad.exe' on a file `C:/foo.txt' under Windows:
     | ?- absolute_file_name('$SYSTEMROOT/notepad.exe', Prog),
          process_create(Prog, [file('C:/foo.txt')]).
Exported predicates:

`process_create(+FILE, +ARGS)'
`process_create(+FILE, +ARGS, :OPTIONS)'
     Start a new process running the program identified by FILE and the
     arguments specified in ARGS. The standard streams of the new
     process can be redirected to prolog streams. The exit status of
     the process can be obtained with `process_wait/[2,3]'.

     FILE, is expanded as if by `absolute_file_name/2' (with argument
     `access(execute)') and is used to locate the file to execute.

     The predefined file search path `path/1' (*note ref-fdi::) is
     especially useful here since it makes it easy to look up the names
     of an executable in the directories mentioned by the `PATH'
     environment variable. To run the Windows command shell `cmd' you
     would simply specify `path('cmd.exe')', to start the UNIX Bash
     shell you would specify `path(bash)'.

     ARGS is a list of argument specifications. Each argument
     specification is either a simple argument specification, see
     below, or a non-empty list of simple argument specifications. The
     expanded value of each element of ARGS is concatenated to produce
     a single argument to the new process. A "simple argument
     specification" can be one of:

    an atom
          The atom name is used as the expanded value. Some operating
          systems only support 7-bit ASCII characters here. Even when
          some larger subset of Unicode is used it may not work
          correctly with all programs.

    `file(FILE)'
          FILE, an atom, is treated as a file name and subject to an
          operating system specific transformation to ensure file name
          syntax and character set is appropriate for the new process.
          This is especially important under Windows where it ensures
          that the full Windows Unicode character set can be used.
          *Please note*: The FILE part of `file(FILE)' is not subject
          to syntactic rewriting, the argument specification `file/1'
          only adjusts for differences in file name syntax and character
          encoding between SICStus and the operating system. You must
          explicitly call `absolute_file_name/[2,3]' if you want to
          expand file search paths etc.

     OPTIONS is a list of options:

    `stdin(SPEC)'
    `stdout(SPEC)'
    `stderr(SPEC)'
          Each SPEC specifies how the corresponding standard stream of
          the new process should be created. SPEC can be one of:
         `std'
               The new process shares the (OS level) standard stream
               with the Prolog process. This is the default.  Note
               that, especially under Windows, the Prolog process may
               not have any OS level standard streams, or the OS
               streams may not be connected to a console or terminal.
               In such a case you need to use `pipe/1' spec, see below,
               and explicitly read (write) data from (to) the process.

         `null'
               The stream is redirected to a null stream, i.e. a stream
               that discards written data and that is always at end of
               file when read.

         `pipe(STREAM)'
               A new Prolog (text) stream is created and connected to
               the corresponding stream of the new process. It is
               currently not possible to request binary streams or to
               specify a character set different from the OS default.
               This stream must be closed using `close/[1,2]', it is not
               closed automatically when the new process exits.

    `process(PROC)'
          PROC will be bound to a process reference that can be used in
          calls to `process_wait/[2,3]' etc.. This process reference
          must be released, either explicitly with `process_release/1'
          or implicitly by `process_wait/[2,3]'.

    `detached(BOOL)'
          BOOL is either `true' or `false'. Specifies whether the new
          process should be "detached", i.e. whether it should be
          notified of terminal events such as `^C' interrupts. By
          default a new process is created detached if none of the
          standard streams are specified, explicitly or implicitly, as
          `std'.

    `cwd(CWD)'
          CWD is expanded as if by `absolute_file_name/2' and is used
          as the working directory for the new process.

          By default, the working directory is the same as the Prolog
          working directory.

    `window(BOOL)'
          BOOL is either `true' or `false' (the default). Specifies
          whether the process should open in its own window.

          Specifying `window(true)' may give unexpected results if the
          standard stream options `stdin/1', `stdout/1' and `stderr/1'
          are specified with anything but their default value `std'.

          Currently only implemented on Windows.


`process_wait(+PROCESS, -EXITSTATUS)'
`process_wait(+PROCESS, -EXITSTATUS, +OPTIONS)'
     Wait for a process to exit and obtain the exit status.

     PROCESS is either a process reference obtained from
     `process_create/3' or an OS process identifier. Specifying a
     process identifier is not reliable. The process identifier may
     have been re-used by the operating system. Under Windows, it is not
     possible to obtain the exit status using a process identifier if
     the process has already exited.

     EXITSTATUS is one of:
    `exit(EXITCODE)'
          The process has exited with exit code EXITCODE. By convention
          processes use exit code zero to signify success and a
          (positive) non-zero value to specify failure.

    `killed(SIGNALNUMBER)'
          UNIX only, the process was killed by signal `SignalNumber' (a
          positive integer).

    `timeout'
          The `timeout/1' option was specified and the process did not
          exit within the specified interval. In this case the process
          reference is not released, even if the `release/1' option is
          specified.
     OPTIONS is a list of options:
    `timeout(SECONDS)'
          Specify a maximum time, in seconds, to wait for the process to
          terminate. SECONDS should be an integer or floating point
          number or the atom `infinite' (the default) to specify
          infinite wait. If the specified timeout interval passes
          before the process exits, `process_wait/3' exits with
          EXITSTATUS set to `timeout' and the process reference is not
          released.

          Currently the UNIX implementation supports only timeout values
          0 (zero) and `infinite'.

    `release(BOOL)'
          BOOL is either `true' (the default) or `false'. Specifies
          whether the process reference should be released when
          `process_wait/3' exits successfully.

`process_id(-PID)'
     Obtain the process identifier of the current (i.e. Prolog) process.

`process_id(+PROCESS, +PID)'
     Obtain the process identifier of the process reference PROCESS.

`is_process(+THING)'
     Returns true if THING is a process reference that has not been
     released.

`process_release(+PROCESS)'
     Release a process reference PROCESS that has previously been
     obtained from `process_create/3'. This ensures that Prolog and the
     operating system can reclaim any resources associated with the
     process reference.

     Usually you would not call this. Either do not request the process
     reference when calling `process_create/3' or let
     `process_wait/[2,3]' reclaim the process reference when the
     process terminates.

`process_kill(+PROCESS)'
`process_kill(+PROCESS, +SIGNALSPEC)'
     Send a signal to the process designated by PROCESS. The signal can
     either be a non-negative integer or a signal name as an (all
     uppercase) atom.

     The following signal names are accepted under UNIX if the platform
     defines them: `SIGABRT', `SIGALRM', `SIGBUS', `SIGCHLD',
     `SIGCONT', `SIGFPE', `SIGHUP', `SIGILL', `SIGINT', `SIGKILL' (the
     default), `SIGPIPE', `SIGPOLL', `SIGPROF', `SIGQUIT', `SIGSEGV',
     `SIGSTOP', `SIGSYS', `SIGTERM', `SIGTRAP', `SIGTSTP', `SIGTTIN',
     `SIGTTOU', `SIGURG', `SIGUSR1', `SIGUSR2', `SIGVTALRM', `SIGXCPU'
     and `SIGXFSZ'. However, many of these do not make sense to send as
     signals.

     Under Windows, which does not have the signal concept, the signal
     name `SIGKILL' (the default) is treated specially and terminates
     the process with `TerminateProcess(Process, -1)'.



File: sicstus.info,  Node: lib-queues,  Next: lib-random,  Prev: lib-process,  Up: The Prolog Library

10.16 Queue Operations --`library(queues)'
==========================================

This module provides an implementation of queues, where you can
   * create an empty queue

   * add an element at either end of a queue

   * add a list of elements at either end of a queue

   * remove an element from the front of a queue

   * remove a list of elements from the front of a queue

   * determine the length of a queue

   * enumerate the elements of a queue

   * recognise a queue

   * print a queue nicely
   The representation was invented by Mark Johnson of the Center for
the Study of Language and Information.  All operations are fast.
Exported predicates:

`empty_queue(?QUEUE)'
     is true when QUEUE represents an empty queue.  It can be used to
     test whether an existing queue is empty or to make a new empty
     queue.

`singleton_queue(?X, ?QUEUE)'
     is true when QUEUE is a queue with just one element X.

`portray_queue(+QUEUE)'
     writes a queue out in a pretty form, as QUEUE[ELEMENTS].  This form
     cannot be read back in, it is just supposed to be readable.  While
     it is meant to be called only when `is_queue(QUEUE)' has been
     established, as by `user:portray(Q) :- is_queue(Q), !,
     portray_queue(Q)'.  it is also meant to work however it is called.

`is_queue(+QUEUE)'
     is true when QUEUE is a queue.  The elements of QUEUE do not have
     to be instantiated, and the BACK of the QUEUE may or may not be.
     It can only be used to recognise queues, not to generate them.  To
     generate queues, use `queue_length(QUEUE, _)'.

`queue_head(+QUEUE, -HEAD)'
     is true when HEAD is the first element of the given QUEUE.  It does
     not remove HEAD from QUEUE; HEAD is still there afterwards.  It can
     only be used to find HEAD, it cannot be used to make a QUEUE.

`queue_tail(?QUEUE, ?TAIL)'
     is true when QUEUE and TAIL are both queues and TAIL contains all
     the elements of QUEUE except the first.  Note that QUEUE and TAIL
     share structure, so that you can add elements at the back of only
     one of them.  It can solve for either argument given the other.

`queue_cons(?HEAD, ?TAIL, ?QUEUE)'
     is true when HEAD is the head of QUEUE and TAIL is the tail of
     QUEUE, that is, when TAIL and QUEUE are both queues, and the
     elements of the QUEUE are HEAD followed by the elements of TAIL in
     order.  It can be used in either direction, so
              queue_cons(+Head, +Q0, -Q)      adds Head to Q0 giving Q
              queue_cons(-Head, -Q, +Q0)      removes Head from Q0 giving Q

`queue_last(?LAST, ?QUEUE)'
     is true when LAST is the last element currently in QUEUE.  It does
     not remove LAST from QUEUE; it is still there.  This can be used to
     generate a non-empty QUEUE.  The cost is O(|QUEUE|).

`queue_last(+FORE, +LAST, -QUEUE)'
     is true when FORE and QUEUE are both lists and the elements of
     QUEUE are the elements of FORE in order followed by LAST.  This is
     the operation which adds an element at the end of FORE giving
     QUEUE;  it is not reversible, unlike `queue_cons/3', and it
     side-effects FORE, again unlike `queue_cons/3'.

`append_queue(?LIST, ?QUEUE0, ?QUEUE)'
     is true when QUEUE is obtained by appending the elements of LIST
     in order at the front of QUEUE0, e.g.  `append_queue([a,b,c],
     Queue[d,e], Queue[a,b,c,d,e])'.  Use
              append_queue([+X1,...,+Xn], +Q0, -Q) to add X1,...,Xn to Q0 giving Q
              append_queue([-X1,...,-Xn], -Q, +Q0) to take X1...Xn from Q0 giving Q
     The cost is O(N) and the operation is pure.

`queue_append(+QUEUE0, +LIST, -QUEUE)'
     is true when QUEUE is obtained by appending the elements of LIST
     in order at the rear end of QUEUE0, e.g.
     `append_queue(Queue[a,b,c], [d,e], Queue[a,b,c,d,e])'.  This is
     like `queue_last/3'; it side-effects QUEUE0.

`list_queue(?LIST, ?QUEUE)'
     is true when QUEUE is a queue and LIST is a list and both have the
     same elements in the same order.  `list_queue/2' and `queue_list/2'
     are the same except for argument order.

`queue_list(?QUEUE, ?LIST)'
     is true when QUEUE is a queue and LIST is a list and both have the
     same elements in the same order.  `queue_list/2' and `list_queue/2'
     are the same except for argument order.

`queue_length(?QUEUE, ?LENGTH)'
     is true when QUEUE is a queue having LENGTH elements.  It may be
     used to determine the LENGTH of a QUEUE or to make a QUEUE of
     given LENGTH.

`queue_member(?ELEMENT, +QUEUE)'
     is true when ELEMENT is an element of QUEUE.  It could be made to
     generate queues, but that would be rather inefficient.  It bears
     the name `queue_member/2' because it is prepared to enumerate
     ELEMENTS.

`queue_memberchk(+ELEMENT, +QUEUE)'
     is true when the given ELEMENT is an element of QUEUE.  Once it
     finds a member of QUEUE which unifies with ELEMENT, it commits to
     it.  Use it to check a ground ELEMENT.

`map_queue(:PRED, +QUEUE[X1,...,XN])'
     succeeds when PRED(XI) succeeds for each element XI of the QUEUE.

`map_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     succeeds when PRED(XI,YI) succeeds for each corresponding pair of
     elements XI, YI of the two queues.

`map_queue_list(:PRED, ?QUEUE[X1,...,XN], ?[Y1,...,YN])'
     succeeds when PRED(XI, YI) is true for each corresponding pair
     XI,YI of elements of the QUEUE and the LIST.  It may be used to
     generate either of the sequences from the other.

`map_list_queue(:PRED, ?[X1,...,XN], ?QUEUE[Y1,...,YN])'
     succeeds when PRED(XI, YI) is true for each corresponding pair
     XI,YI of elements of the LIST and the QUEUE.  It may be used to
     generate either of the sequences from the other.

`some_queue(:PRED, +QUEUE[X1,...,XN])'
     succeeds when PRED(XI) succeeds for some XI in the QUEUE.  It will
     try all ways of proving PRED(XI) for each XI, and will try each XI
     in the QUEUE.  `somechk_queue/2' is to `some_queue/2' as
     `memberchk/2' is to `member/2'; you are more likely to want
     `somechk_queue/2'.  This acts on backtracking like `member/2';
     QUEUE should be proper.

`some_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I.

`somechk_queue(:PRED, +QUEUE[X1,...,XN])'
     is true when PRED(XI) is true for some I, and it commits to the
     first solution it finds (like `memberchk/2').

`somechk_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I, and it commits to
     the first solution it finds (like `memberchk/2').


File: sicstus.info,  Node: lib-random,  Next: lib-rem,  Prev: lib-queues,  Up: The Prolog Library

10.17 Random Number Generator--`library(random)'
================================================

This library module provides a random number generator using algorithm
AS 183 from the Journal of Applied Statistics as the basic algorithm.

   The state of the random number generator corresponds to a term
`random(X,Y,Z,B)' where X is an integer in the range [1,30268], Y is an
integer in the range [1,30306], Z is an integer in the range [1,30322],
and B is a nonzero integer.

   Exported predicates:

`getrand(-RANDOMSTATE)'
     returns the random number generator's current state

`setrand(+RANDOMSTATE)'
     sets the random number generator's state to RANDOMSTATE.  If
     RANDOMSTATE is not a valid random state, it reports an error, and
     then fails.

`maybe'
     succeeds determinately with probability 1/2, fails with
     probability 1/2.  We use a separate "random bit" generator for
     this test to avoid doing much arithmetic.

`maybe(+PROBABILITY)'
     succeeds determinately with probability Probability, fails with
     probability 1-PROBABILITY.  Arguments =< 0 always fail, >= 1
     always succeed.

`maybe(+P, +N)'
     succeeds determinately with probability P/N, where 0 =< P =< N and
     P and N are integers.  If this condition is not met, it fails.  It
     is equivalent to `random(0, N, X), X < P', but is somewhat faster.

`random(-UNIFORM)'
     unifies UNIFORM with a new random number in [0.0,1.0)

`random(+L, +U, -R)'
     unifies R with a random integer in [L,U) when L and U are integers
     (note that U will _never_ be generated), or to a random floating
     number in [L,U) otherwise.

`random_member(-ELEM, +LIST)'
     unifies ELEM with a random element of LIST, which must be proper.
     Takes O(N) time (average and best case).

`random_select(?ELEM, ?LIST, ?REST)'
     unifies ELEM with a random element of LIST and REST with all the
     other elements of LIST (in order).  Either LIST or REST should be
     proper, and LIST should/will have one more element than REST.
     Takes O(N) time (average and best case).

`random_subseq(+LIST, -SBSQ, -CMPL)'
     unifies SBSQ with a random sub-sequence of LIST, and CMPL with its
     complement.  After this, `subseq(List, Sbsq, Cmpl)' will be true.
     Each of the 2**|LIST| solutions is equally likely.  Like its
     name-sake `subseq/3', if you supply SBSQ and CMPL it will
     interleave them to find LIST.  Takes O(N) time.  LIST should be
     proper.

`random_permutation(?LIST, ?PERM)'
     unifies PERM with a random permutation of LIST.  Either LIST or
     PERM should be proper, and they should/will have the same length.
     Each of the N! permutations is equally likely, where `length(List,
     N)'.  This takes O(N LG N) time and is bidirectional.

`random_perm2(A,B, X,Y)'
     unifies X,Y = A,B or X,Y = B,A, making the choice at random, each
     choice being equally likely.  It is equivalent to
     `random_permutation([A,B], [X,Y])'.

`random_numlist(+P, +L, +U, -LIST)'
     where P is a probability (0..1) and L=<U are integers unifies LIST
     with a random subsequence of the integers L..U, each integer being
     included with probability P.


File: sicstus.info,  Node: lib-rem,  Next: lib-samsort,  Prev: lib-random,  Up: The Prolog Library

10.18 Rem's Algorithm--`library(rem)'
=====================================

This library module maintains equivalence classes using Rem's algorithm.
Exported predicates:

`rem_create(+SIZE, -REM)'
     creates an equivalence representation function REM which maps each
     of the nodes 1..SIZE to itself.

`rem_head(?NODE, +REM, -HEAD)'
     is true when HEAD is the representative of the equivalence class
     that NODE belongs to in the given REM.

`rem_equivalent(?NODE1, ?NODE2, +REM)'
     is true when NODE1 and NODE2 belong to the same equivalence class
     in the given REM.

`rem_add_link(?NODE1, ?NODE2, +OLDREM, -NEWREM)'
     is true when adding the equivalence NODE1===NODE2 to the partition
     represented by OLDREM yields a partition which is represented by
     NEWREM.  If NODE1 or NODE2 is uninstantiated, it will backtrack
     over all the nodes.  It's not clear how useful this is.


File: sicstus.info,  Node: lib-samsort,  Next: lib-sets,  Prev: lib-rem,  Up: The Prolog Library

10.19 Generic Sorting--`library(samsort)'
=========================================

This library module provides generic sorting.  Exported predicates:

`samsort(+RAWLIST, -SORTED)'
     is given a proper list RAWLIST and unifies SORTED with a list
     having exactly the same elements as RAWLIST but in ascending order
     according to the standard order on terms.

`merge(+LIST1, +LIST2, -MERGED)'
     is true when MERGED is the stable merge of the two given lists.
     If the two lists are not ordered, the merge doesn't mean a great
     deal.  Merging is perfectly well defined when the inputs contain
     duplicates, and all copies of an element are preserved in the
     output, e.g. merge("122357", "34568", "12233455678").

`samsort(:ORDER, +RAWLIST, -SORTEDLIST)'
     is given a proper list RAWLIST and a binary predicate ORDER (note
     that it may be an N-ARY predicate with the first N-2 arguments
     already filled in) and unifies SORTEDLIST with a sorted version of
     RAWLIST.  This is only supposed to work when Orderis transitive.

`merge(:ORDER, +LIST1, +LIST2, -MERGED)'
     is like `merge/3' except that it takes an ORDER predicate as its
     first arguments, like all the generalised ordering routines.
     samkeysort(+RAWLIST, -SORTED) is given a proper list RAWLIST of
     KEY-VALUE pairs, and unifies SORTED with a list having exactly the
     same elements as RAWLIST but in ascending order according to the
     standard order on the keys.

`keymerge(+LIST1, +LIST2, -MERGED)'
     is like `merge/3' except that it compares only the keys of its
     input lists.  Note that it will not work properly when MERGED is
     already instantiated.


File: sicstus.info,  Node: lib-sets,  Next: lib-sockets,  Prev: lib-samsort,  Up: The Prolog Library

10.20 Unordered Set Operations--`library(sets)'
===============================================

This library module provides operations on sets represented as
unordered lists with no repeated elements.  The ordered representation
used in `library(ordsets)' is much more efficient, but these routines
were designed before sort/2 entered the language.  Exported predicates:

`add_element(+ELEMENT, +SET1, -SET2)'
     is true when SET1 and SET2 are sets represented as unordered lists,
     and SET2 = SET1 U {ELEMENT}.  It may only be used to calculate SET2
     given ELEMENT and SET1.

`del_element(+ELEMENT, +SET1, -SET2)'
     is true when SET1 and SET2 are sets represented as unordered lists,
     and SET2 = SET1 \ {ELEMENT}.  It may only be used to calculate SET2
     given ELEMENT and SET1.  If SET1 does not contain ELEMENT, SET2
     will be identical to SET1 (the old version made a new copy of
     SET1).  If SET1 is not an unordered set, but contains more than
     one copy of ELEMENT, only the first will be removed.  If you want
     to delete all copies of a given element, use `lists:delete/3'.
     For a version which fails if ELEMENT is not in SET1, use
     `selectchk/3'.

`disjoint(+SET1, +SET2)'
     is true when the two given sets have no elements in common.  It is
     the opposite of `intersect/2'.  If either of the arguments is
     improper, `disjoint/2' will fail.

`is_set(+LIST)'
     is true when LIST is a proper list that contains no repeated
     elements.

`pairfrom(?SET, ?ELEMENT1, ?ELEMENT2, ?RESIDUE)'
     is true when SET is a list, ELEMENT1 occurs in list, ELEMENT2
     occurs in list after ELEMENT1, and RESIDUE is everything in SET
     bar the two ELEMENTS.  The point of this thing is to select pairs
     of elements from a set without selecting the same pair twice in
     different orders.

`intersect(+SET1, +SET2)'
     is true when the two sets have a member in common.  It assumes
     that both sets are known, and that you don't care which element it
     is that they share.

`subset(+SET1, +SET2)'
     is true when each member of SET1 occurs in SET2.  It can only be
     used to test two given sets; it cannot be used to generate subsets.

`set_order(+XS, +YS, -R)'
     is true when R is `<', `=', or `>' according as XS is a subset of
     YS, equivalent to YS, or a superset of YS.

`seteq(+SET1, +SET2)'
     is true when each Set is a subset of the other.

`list_to_set(+LIST, -SET)'
     is true when LIST and SET are lists, and SET has the same elements
     as LIST in the same order, except that it contains no duplicates.
     The two are thus equal considered as sets.

`power_set(+SET, -POWERSET)'
     is true when SET is a list and POWERSET is a list of lists which
     represents the power set of the set that Set represents.

`intersection(+SET1, +SET2, -INTERSECTION)'
     is true when all three arguments are lists representing sets, and
     INTERSECTION contains every element of SET1 which is also an
     element of SET2, the order of elements in INTERSECTION being the
     same as in SET1.  That is, INTERSECTION represents the
     intersection of the sets represented by SET1 and SET2.

`intersection(+LISTOFSETS, -INTERSECTION)'
     is true when INTERSECTION is the intersection of all the sets in
     LISTOFSETS.  The order of elements in INTERSECTION is taken from
     the first set in LISTOFSETS.  This has been turned inside out to
     minimise the storage turnover.

`subtract(+SET1, +SET2, -DIFFERENCE)'
     is like `intersect/3', but this time it is the elements of SET1
     which _are_ in SET2 that are deleted.  Note that duplicated
     ELEMENTS of SET1 which are not in SET2 are retained in DIFFERENCE.

`symdiff(+SET1, +SET2, -DIFFERENCE)'
     is true when DIFFERENCE is the symmetric difference of SET1 and
     SET2, that is, if each element of DIFFERENCE occurs in one of SET1
     and SET2 but not both.  The construction method is such that the
     answer will have no duplicates even if the SETS do.

`setproduct(+SET1, +SET2, -CARTESIANPRODUCT)'
     is true when SET1 is a set (list) and SET2 is a set (list) and
     CARTESIANPRODUCT is a set of ELT1-ELT2 pairs, with a pair for for
     each element ELT1 of SET1 and ELT2 of SET2.

`disjoint_union(+SET1, +SET2, -UNION)'
     is true when `disjoint(Set1, Set2)' and `union(Set1, Set2, Union)',
     that is, SET1 and SET2 have no element in command and UNION is
     their union.

`union(+SET1, +SET2, -UNION)'
     is true when `subtract(Set1,Set2,Diff)' and
     `append(Diff,Set2,Union)', that is, when UNION is the elements of
     SET1 that do not occur in SET2, followed by all the elements of
     SET2.

`union(+SET1, +SET2, -UNION, -DIFFERENCE)'
     is true when `union(Set1, Set2, Union)' and `subtract(Set1, Set2,
     Difference)'.

`union(+LISTOFSETS, -UNION)'
     is true when UNION is the union of all the sets in LISTOFSETS.  It
     has been arranged with storage turnover in mind.


File: sicstus.info,  Node: lib-sockets,  Next: lib-structs,  Prev: lib-sets,  Up: The Prolog Library

10.21 Socket I/O--`library(sockets)'
====================================

This library package defines a number of predicates for communicating
over sockets.  To create a (bi-directional) stream connected to a
remote server, use `socket_client_open/3'.  To open a port for remote
clients to connect to, use `socket_server_open/2' and to open a stream
to a connecting client, use `socket_server_accept/4'.  To be able to
multiplex input and output from several streams (not necesessarily
socket streams) and incoming connections, use `socket_select/7'.

   All streams below can be read from as well as written on.  All I/O
predicates operating on streams can be used, for example `get_code/2',
`get_byte/2', `read/2', `write/2', `format/3', `current_stream/3', etc.
The predicates that create streams take options similar to `open/4',
e.g., to specify whether the stream is binary (the default) or text.

`socket_client_open(+ADDR, -STREAM, +OPTIONS)'
     Creates a stream STREAM connected to address ADDR.  ADDR can be:
    `HOST:PORT'
          Connect to the machine with address HOST (a host name or host
          address) at port PORT (a port number or service name).  The
          HOST should be an atom, e.g., `'www.sics.se''. The PORT is
          either a port number as an integer or atom, e.g., `80', or
          `'80''; alternatively some "well known port names" can be
          used, e.g., `'http''. The set of well known port names is OS
          specific, portable code should use integer port numbers.

     The stream is created using options from OPTIONS. Supported
     options include:
    `type(binary)'
          Create a binary stream (the default).

    `type(text)'
          Create a text stream. The default encoding is Latin 1.

    `eof_action(ACTION)'
          end of file action, as for `open/4'.

     To create a binary stream to some web server `www.sics.se', you
     would do e.g.,
          | ?- socket_client_open('www.sics.se':80, Stream, [type(binary)]).

     or, to make a text (Latin 1) stream to a `daytime' service in Hong
     Kong you could do:

          | ?- socket_client_open('stdtime.gov.hk':daytime, S, [type(text)]),
               read_line(S, L),
               format('~s', [L]).

     See the source code for `library('linda/client')' for a simple
     client.

`socket_server_open(?PORT, -SERVERSOCKET)'
     Create a server socket SERVERSOCKET that listens on port PORT.
     Port can be either an integer port number or an atomic service
     name, see `socket_client_open/3' for details. Port can also be a
     variable in which case a free port number is used and PORT is
     bound to it.  The created server socket should be closed with
     `socket_server_close/1' eventually. Incoming connection can be
     accepted with `socket_server_accept/4' and waited for with
     `socket_select/7'.  See the source code for
     `library('linda/server')' for a simple server that uses this
     predicate.

`socket_server_accept(+SERVERSOCKET, -CLIENT, -STREAM, +STREAMOPTIONS)'
     The first connection to socket SERVERSOCKET is extracted, blocking
     if necessary.  The stream STREAM is created on this connection
     using STREAMOPTIONS as for `socket_client_open/3'. CLIENT will be
     unified with an atom containing the numerical Internet host
     address of the connecting client.  Note that the stream will be
     `type(binary)' unless `type(text)' is explicitly specified.

`socket_server_close(+SERVERSOCKET)'
     Close the server socket SERVERSOCKET and stop listening on its
     port.

`socket_select(+SERVERSOCKETS,-SREADY, +READSTREAMS,-RREADY, +WRITESTREAMS,-WREADY, +TIMEOUT)'
     Check for server sockets with incoming connections (i.e., ready
     for `socket_server_accept/4'), streams on READSTREAMS ready for
     input, and streams on WRITESTREAMS ready for output. The streams
     can be any kind of streams, they need not be socket streams. The
     ready server sockets are returned (in the same order) in SREADY,
     the ready input streams in RREADY, and the ready output streams in
     WREADY.

     An input (output) stream is ready for input (output) when an
     "item" can be read (written) without blocking. An item is a
     character for text streams and a byte for binary streams.  Note
     that a stream is considered ready for I/O if the corresponding I/O
     operation will raise an error (such as if the stream is past end
     of stream).

     Each entry in the input lists SERVERSOCKETS, READSTREAMS, and
     WRITESTREAMS can be either a server socket or stream respectively
     or a term `TERM-ENTRY' where ENTRY is the server socket or stream
     and TERM is some arbitrary term used for book-keeping. If an entry
     is associated with a term in this way then so will the
     corresponding ready entry.

     If TIMEOUT is instantiated to `off', the predicate waits until
     something is available.  If TIMEOUT is a nonzero number (integer
     or floating point), then the predicate waits at most that number
     of seconds before returning. For backward compatibility, if
     TIMEOUT is S:U the predicate waits at most S seconds and U
     microseconds. If there is a timeout, all ready lists are unified
     with `[]'.

     See the source code for `library('linda/server')' for a simple
     server that uses this predicate.

`current_host(?HOSTNAME)'
     HOSTNAME is unified with the fully qualified name of the machine
     that the process is executing on. The call will also succeed if
     HOSTNAME is instantiated to the unqualified name of the machine in
     lower case.


File: sicstus.info,  Node: lib-structs,  Next: lib-system,  Prev: lib-sockets,  Up: The Prolog Library

10.22 The Structs Package--`library(structs)'
=============================================

* Menu:

* str-fty::                             Foreign Types
* str-cft::                             Checking Foreign Term Types
* str-cdf::                             Creating and Destroying Foreign Terms
* str-afd::                             Accessing and Modifying Foreign Term Contents
* str-cas::                             Casting
* str-nul::                             Null Foreign Terms
* str-ifc::                             Interfacing with Foreign Code
* str-etr::                             Examining Type Definitions at Runtime
* str-tip::                             Tips
* str-exa::                             Example

   The `structs' package allows Prolog to hold pointers to C data
structures, and to access and store into fields in those data
structures.  Currently, the only representation for a pointer supported
by SICStus Prolog is an integer, so it isn't possible to guarantee that
Prolog can't confuse a pointer with an ordinary Prolog term.  What this
package does is to represent such a pointer as a term with the type of
the structure or array as its functor and the integer that is the
address of the actual data as its only argument.  We will refer such
terms as "foreign terms".  

   The package consists of two modules, `str_decl' and `structs'. The
`str_decl' module is used at compile time to translate the
structs-related constructs.  Any file that defines or accesses structs
should include the command:

     :- load_files(library(str_decl),
                   [when(compile_time), if(changed)]).

   The `structs' module provides runtime support for structs.  A file
that accesses structs should include the command:

     :- use_module(library(structs)).

   You will probably include both in most files that define and access
structs.

     *Important caveats:*

     You should not count on future versions of the structs package to
     continue to represent foreign terms as compound Prolog terms.  In
     particular, you should never explicitly take apart a foreign term
     using unification or `functor/3' and `arg/3'.  You may use the
     predicate `foreign_type/2' to find the type of a foreign term, and
     `cast/3' (casting a foreign term to address) to get the address
     part of a foreign term.  You may also use `cast/3' to cast an
     address back to a foreign term.  You should use
     `null_foreign_term/2' to check if a foreign term is null, or to
     create a null foreign term of some type.

     It should never be necessary to explicitly take apart foreign
     terms.


File: sicstus.info,  Node: str-fty,  Next: str-cft,  Up: lib-structs

10.22.1 Foreign Types
---------------------

* Menu:

* str-fty-dty::                         Declaring Types

   There are two sorts of objects that Prolog may want to handle:
"atomic" and "compound".  "Atomic" objects include numbers and atoms,
and "compound" objects include data structures and arrays.  To be more
precise about it, an atomic type is defined by one of the following:

`integer'
     Long signed integer.

`integer_32'
     32 bit signed integer.

`integer_16'
     16 bit signed integer.

`integer_8'
     8 bit signed integer.

`unsigned'
     long unsigned integer.

`unsigned_32'
     32 bit unsigned integer.

`unsigned_16'
     16 bit unsigned integer.

`unsigned_8'
     8 bit unsigned integer.

`float'
     64 bit floating-point number.

`float_32'
     32 bit floating-point number.

`atom'
     32 bit Prolog atom number.  Unique for different atoms, but not
     consistent across Prolog sessions.  The atom is made non garbage
     collectable. *Note Atoms in C::.

`string'
     A pointer to an encoded string.  Represented as an atom in Prolog.
     *Please note*: This string must not be overwritten, as it
     constitutes the print name of an atom.  Also, the atom and string
     are made non garbage collectable. *Note Atoms in C::.

`address'
     An untyped address.  Like `pointer(_)', but `library(structs)'
     does no type checking for you. Represented as a Prolog integer.

`opaque'
     Unknown type.  Cannot be represented in Prolog.  A pointer to an
     opaque object may be manipulated.

   Compound types are defined by one of the following:

`pointer(TYPE)'
     a long pointer to a thing of type TYPE.

`array(NUM,TYPE)'
     A chunk of memory holding NUM (an integer) things of type TYPE.

`array(TYPE)'
     A chunk of memory holding some number of things of type TYPE.
     This type does not allow bounds checking, so it should be used
     with great care.  It is also not possible to use this sort of
     array as an element in an array, or in a struct or union.

`struct(FIELDS)'
     A compound structure.  FIELDS is a list of FIELD_name:TYPE pairs.
     Each FIELD_name is an atom, and each TYPE is any valid type.

`union(MEMBERS)'
     A union as in C.  MEMBERS is a list of MEMBER_name:TYPE pairs.
     Each MEMBER_name is an atom, and each TYPE is any valid type.  The
     space allocated for one of these is the maximum of the spaces
     needed for each member.  It is not permitted to store into a union
     (you must get a member of the union to store into, as in C).

   C programmers will recognize that the kinds of data supported by
this package were designed for the C language.  They should also work
for other languages, but programmers must determine the proper type
declarations in those languages.  The table above makes clear the
storage requirements and interpretation of each type.

   Note that there is one important difference between the `structs'
package and C:  the `structs' package permits declarations of pointers
to arrays.  A pointer to an array is distinguished from a pointer to a
single element.  For example
     pointer(array(integer_8))

is probably a more appropriate declaration of a C string type than
     pointer(integer_8)

which is the orthodox way to declare a string in C.


File: sicstus.info,  Node: str-fty-dty,  Up: str-fty

10.22.1.1 Declaring Types
.........................

Programmers may declare new named data structures with the following
procedure:
     :- foreign_type
         Type_name = Type,
         ...,
         Type_name = Type.

where TYPE_NAME is an atom, and TYPE defines either an atomic or
compound type, or is a previously-defined type name.

   In Prolog, atomic types are represented by the natural atomic term
(integer, float, or atom).  Compound structures are represented by
terms whose functor is the name of the type, and whose only argument is
the address of the data.  So a term `foo(123456)' represents the thing
of type `foo' that exists at machine address 123456.  And a term
`integer(123456)' represents the integer that lives in memeory at
address 123456, _not_ the number 123456.

   For types that are not named, a type name is generated using the
names of associated types and the dollar sign character (`$'), and
possibly a number.  Therefore, users should not use `$' in their type
names.


File: sicstus.info,  Node: str-cft,  Next: str-cdf,  Prev: str-fty,  Up: lib-structs

10.22.2 Checking Foreign Term Types
-----------------------------------

The type of a foreign term may determined by the goal
     foreign_type(+FOREIGN_TERM, -TYPE_NAME)

   Note that `foreign_type/2' will fail if FOREIGN_TERM is not a
foreign term.


File: sicstus.info,  Node: str-cdf,  Next: str-afd,  Prev: str-cft,  Up: lib-structs

10.22.3 Creating and Destroying Foreign Terms
---------------------------------------------

Prolog can create or destroy foreign terms using
     new(+TYPE, -DATUM),
     new(+TYPE, +SIZE, -DATUM) and
     dispose(+DATUM)

where TYPE is an atom specifying what type of foreign term is to be
allocated, and DATUM is the foreign term.  The DATUM returned by
`new/[2,3]' is not initialized in any way.  `dispose/1' is a dangerous
operation, since once the memory is disposed, it may be used for
something else later.  If DATUM is later accessed, the results will be
unpredictable.  `new/3' is only used to allocate arrays whose size is
not known beforehand, as defined by `array(TYPE)', rather than
`array(TYPE,SIZE)'.


File: sicstus.info,  Node: str-afd,  Next: str-cas,  Prev: str-cdf,  Up: lib-structs

10.22.4 Accessing and Modifying Foreign Term Contents
-----------------------------------------------------

Prolog can get or modify the contents of a foreign term with the
procedures
     get_contents(+DATUM, ?PART, ?VALUE)
     put_contents(+DATUM, +PART, +VALUE).

   It can also get a pointer to a field or element of a foreign term
with the procedure
     get_address(+DATUM, ?PART, ?VALUE).

   For all three of these, DATUM must be a foreign term, and PART
specifies what part of DATUM VALUE is.  If DATUM is an array, PART
should be an integer index into the array, where 0 is the first
element.  For a pointer, PART should be the atom `contents' and VALUE
will be what the pointer points to.  For a struct, PART should be a
field name, and VALUE will be the contents of that field.  In the case
of `get_contents/3' and `get_address/3', if PART is unbound,
`get_contents/3' will backtrack through all the valid parts of DATUM,
binding both PART and VALUE.  A C programmer might think of the
following pairs as corresponding to each other:
     Prolog: get_contents(Foo, Bar, Baz)
          C: Baz = Foo->Bar

     Prolog: put_contents(Foo, Bar, Baz)
          C: Foo->Bar = Baz

     Prolog: get_address(Foo, Bar, Baz)
          C: Baz = &Foo->Bar.

   The hitch is that only atomic and pointer types can be got and put
by `get_contents/3' and `put_contents/3'.  This is because Prolog can
only hold pointers to C structures, not the structures themselves.
This isn't quite as bad as it might seem, though, since usually
structures contain pointers to other structures, anyway.  When a
structure directly contains another structure, Prolog can get a pointer
to it with `get_address/3'.


File: sicstus.info,  Node: str-cas,  Next: str-nul,  Prev: str-afd,  Up: lib-structs

10.22.5 Casting
---------------

Prolog can "cast" one type of foreign term to another.  This means that
the foreign term is treated just as if it where the other type.  This is
done with the following procedure:
     cast(+FOREIGN0, +NEW_TYPE, -FOREIGN)

where FOREIGN is the foreign term that is the same data as FOREIGN0,
only is of foreign type NEW_TYPE.  FOREIGN0 is not affected.  This is
much like casting in C.

   Casting a foreign term to `address' will get you the raw address of a
foreign term.  This is not often necessary, but it is occasionally
useful in order to obtain an indexable value to use in the first
argument of a dynamic predicate you are maintaining.  An `address' may
also be casted to a proper foreign type.

   This predicate should be used with great care, as it is quite easy to
get into trouble with this.


File: sicstus.info,  Node: str-nul,  Next: str-ifc,  Prev: str-cas,  Up: lib-structs

10.22.6 Null Foreign Terms
--------------------------

"NULL" foreign terms may be handled.  The predicate
     null_foreign_term(+TERM, -TYPE)
     null_foreign_term(-TERM, +TYPE)

holds when TERM is a foreign term of TYPE, but is NULL (the address is
0).  At least one of TERM and TYPE must be bound.  This can be used to
generate NULL foreign terms, or to check a foreign term to determine
whether or not it is NULL.


File: sicstus.info,  Node: str-ifc,  Next: str-etr,  Prev: str-nul,  Up: lib-structs

10.22.7 Interfacing with Foreign Code
-------------------------------------

Foreign terms may be passed between Prolog and other languages through
the foreign interface.

   To use this, all foreign types to be passed between Prolog and
another language must be declared with `foreign_type/2' before the
`foreign/[2,3]' clauses specifying the foreign functions.

   The `structs' package extends the foreign type specifications
recognized by the foreign interface.  In addition to the types already
recognized by the foreign interface, any atomic type recognized by the
`structs' package is understood, as well as a pointer to any named
`structs' type.

   For example, if you have a function

     char nth_char(string, n)
         char *string;
         int n;
         {
             return string[n];
         }

   You might use it from Prolog as follows:
     :- foreign_type cstring = array(integer_8).

     foreign(nth_char, c, nth_char(+pointer(cstring), +integer, [-integer_8])).

   This allows the predicate `nth_char/3' to be called from Prolog to
determine the nth character of a C string.

   Note that all existing foreign interface type specifications are
unaffected, in particular `address/[0,1]' continue to pass addresses to
and from Prolog as plain integers.

   If you use the foreign resource linker, `splfr', on a Prolog file
that uses the `structs' package, you must pass it the `--structs'
option.  This will make `splfr' understand foreign type specifications
and translate them into C declarations in the generated header file
(*note The Foreign Resource Linker::).


File: sicstus.info,  Node: str-etr,  Next: str-tip,  Prev: str-ifc,  Up: lib-structs

10.22.8 Examining Type Definitions at Runtime
---------------------------------------------

The above described procedures should be sufficient for most needs.
This module does, however, provide a few procedures to allow
programmers to access type definitions.  These may be a convenience for
debugging, or in writing tools to manipulate type definitions.

   The following procedures allow programmers to find the definition of
a given type:
     type_definition(?TYPE, ?DEFINITION)
     type_definition(?TYPE, ?DEFINITION, ?SIZE)

where TYPE is an atom naming a type, DEFINITION is the definition of
that type, and SIZE is the number of bytes occupied by a foreign term of
this type.  SIZE will be the atom `unknown' if the size of an object of
that type is not known.  Such types may not be used as fields in
structs or unions, or in arrays.  However, pointers to them may be
created.  If TYPE is not bound at call time, these procedures will
backtrack through all current type definitions.

   A definition looks much like the definition given when the type was
defined with `type/1', except that it has been simplified.  Firstly,
intermediate type names have been elided.  For example, if `foo' is
defined as `foo=integer', and `bar' as `bar=foo', `type_definition(bar,
integer)' would hold.  Also, in the definition of a compound type,
types of parts are always defined by type names, rather than complex
specifications.  So if the type of a field in a struct was defined as
`pointer(fred)', it will show up in the definition as `'$fred''.  Of
course, `type_definition('$fred', pointer(fred))' would hold, also.

   The following predicates allow the programmer to determine whether
or not a given type is atomic:
     atomic_type(?TYPE)

     atomic_type(?TYPE, ?PRIMITIVE_TYPE)

     atomic_type(?TYPE, ?PRIMITIVE_TYPE, ?SIZE)

where TYPE is an atomic type.  See *Note str-fty:: for the definition
of an atomic type.  PRIMITIVE_TYPE is the primitive type that TYPE is
defined in terms of.  SIZE is the number of bytes occupied by an object
of type TYPE, or the atom `unknown', as above.  If TYPE is unbound at
call time, these predicates will backtrack through all the currently
defined atomic types.


File: sicstus.info,  Node: str-tip,  Next: str-exa,  Prev: str-etr,  Up: lib-structs

10.22.9 Tips
------------

  1. Most important tip: don't subvert the `structs' type system by
     looking inside foreign terms to get the address, or use
     `functor/3' to get the type.  This has two negative effects:
     firstly, if the `structs' package should change its representation
     of foreign terms, your code will not work.  But more importantly,
     you are more likely to get type mismatches, and likely to get
     unwrapped terms or even doubly wrapped terms where you expect
     wrapped ones.

  2. Remember that a foreign term `fred(123456)' is not of type `fred',
     but a pointer to `fred'.  Looked at another way, what resides in
     memory at address 123456 is of type `fred'.

  3. The wrapper put on a foreign term signifies the type of that
     foreign term.  If you declare a type to be `pointer(opaque)'
     because you want to view that pointer to be opaque, when you get
     something of this type, it will be printed as `opaque(456123)'.
     This is not very informative.  It is better to declare
          fred = opaque,
          thing = struct([...,
                      part:pointer(fred),
                      ...
                  ]).

     so that when you get the contents of the `part' member of a
     `thing', it is wrapped as `fred(456123)'.


File: sicstus.info,  Node: str-exa,  Prev: str-tip,  Up: lib-structs

10.22.10 Example
----------------

The following example shows how to use `library(structs)' in a simple
package for handling integer arrays.  We define a module `minivec' with
exported predicates for creating and disposing arrays, accessing its
elements, and computing their sum.  The summing operation is
implemented in C and the rest in Prolog.  Arrays are created using the
`array(TYPE)' foreign type.

   Note that the type declaration `int32' does not have to be given in
the C source code, as it appears in the automatically generated header
file `minivec_glue.h'.  Note also how the foreign type specification
`+pointer(int_array)' corresponds to the C type declaration `int32 *'.

                                                         _% minivec.pl_
     :- module(minivec, [
             new_array/2,
             get_array/3,
             put_array/3,
             dispose_array/1,
             sum_array/2
             ]).

     :- load_files(library(str_decl), [when(compile_time)]).
     :- use_module(library(structs)).

     :- foreign_type
             int32           = integer_32,
             int_array       = array(int32).

     foreign(c_sum_array, c_sum_array(+integer,
                                      +pointer(int_array),
                                      [-integer])).

     foreign_resource(minivec, [c_sum_array]).

     :- load_foreign_resource(minivec).

     new_array(Size, array(Size,Mem)) :-
             new(int_array, Size, Mem).

     get_array(Index, array(_,Mem), Value) :-
             get_contents(Mem, Index, Value).

     put_array(Index, array(_,Mem), Value) :-
             put_contents(Mem, Index, Value).

     dispose_array(array(_,Mem)) :-
             dispose(Mem).

     sum_array(array(Size,Mem), Sum) :-
             c_sum_array(Size, Mem, Sum).

                                                      _/* minivec.c */_
     #include "minivec_glue.h"

     long c_sum_array(long cnt, int32 *mem)
     {
       int i;
       long sum = 0;

       for (i=0; i<cnt; i++)
         sum += mem[i];
       return sum;
     }

                                                            _# session_
     % splfr --struct minivec.pl minivec.c
     % sicstus -l minivec
     % compiling /home/matsc/sicstus4/Suite/minivec.pl...
     % [...]
     % compiled /home/matsc/sicstus4/Suite/minivec.pl in module minivec, 30 msec 68388 bytes
     SICStus 4.0.2 ...
     Licensed to SICS
     | ?- new_array(4, A),
          put_array(0,A,1),
          put_array(1,A,10),
          put_array(2,A,100),
          put_array(3,A,1000),
          sum_array(A,S),
          dispose_array(A).
     A = array(4,int_array(1264224)),
     S = 1111

   A fragment from the generated header file:

                                                 _/* minivec_glue.h */_
     #include <sicstus/sicstus.h>
     #include <stdlib.h>
     typedef int int32;
     typedef int32 *(int_array)/* really an unknown-size array */;
     extern long c_sum_array( long, int32 *);


File: sicstus.info,  Node: lib-system,  Next: lib-terms,  Prev: lib-structs,  Up: The Prolog Library

10.23 Operating System Utilities--`library(system)'
===================================================

This package contains utilities for invoking services from the operating
system that does not fit elsewhere.

   Exported predicates:

`now(-WHEN)'
     Unifies the current date and time as a UNIX timestamp with WHEN.

`datime(-DATIME)'
     Unifies DATIME with the current date and time as a `datime/6'
     record of the form `datime(YEAR,MONTH,DAY,HOUR,MIN,SEC)'.  All
     fields are integers.

`datime(+WHEN,-DATIME)'

`datime(-WHEN,+DATIME)'
     Convert a time stamp, as obtained by `now/1', to a `datime/6'
     record. Can be used in both directions.

`sleep(+SECONDS)'
     Puts the SICStus Prolog process asleep for SECOND seconds, where
     SECONDS should be a non-negative number.

`environ(?VAR, ?VALUE)'
     VAR is the name of an environment variable, and VALUE is its
     value.  Both are atoms.  Can be used to enumerate all current
     environment variables.


File: sicstus.info,  Node: lib-terms,  Next: lib-timeout,  Prev: lib-system,  Up: The Prolog Library

10.24 Term Utilities--`library(terms)'
======================================

This library module provides miscellaneous operations on terms.
Exported predicates:

`subsumeschk(+GENERAL, +SPECIFIC)'
     is true when SPECIFIC is an instance of GENERAL.  It does not bind
     any variables.

`subsumes(+GENERAL, +SPECIFIC)'
     is true when SPECIFIC is an instance of GENERAL.  It will bind
     variables in GENERAL (but not those in SPECIFIC) so that GENERAL
     becomes identical to SPECIFIC.

`variant(+TERM, +VARIANT)'
     is true when TERM and VARIANT are identical modulo renaming of
     variables, provided TERM and VARIANT have no variables in common.

`term_subsumer(+TERM1, +TERM2, -TERM)'
     binds TERM to a most specific generalisation of TERM1 and TERM2.
     Using Plotkin's algorithm [Machine Intelligence 5, 1970], extended
     by Dan Sahlin to handle cyclic structures.

`term_hash(+TERM, -HASH)'
     If TERM is ground, an integer hash value corresponding to TERM is
     unified with HASH.  Otherwise, the goal just succeeds.

`term_hash(+TERM, +DEPTH, +RANGE, -HASH)'
     If TERM is instantiated to the given DEPTH, an integer hash value
     in the range [0,RANGE) corresponding to TERM is unified with HASH.
     Otherwise, the goal just succeeds.

`term_variables(+TERM, -VARIABLES)'
     True if VARIABLES is the set of variables occurring in TERM.

`term_variables_bag(+TERM, -VARIABLES)'
     True if VARIABLES is the list of variables occurring in TERM, in
     first occurrence order.

`acyclic_term(+X)'
     True if X is finite (acyclic).  Runs in linear time.

`cyclic_term(+X)'
     True if X is infinite (cyclic).  Runs in linear time.

`term_order(+X, +Y, -R)'
     is true when X and Y are arbitrary terms, and R is `<', `=', or
     `>' according as X @< Y, X == Y, or X @> Y.  This is the same as
     `compare/3', except for the argument order.

`contains_term(+KERNEL, +EXPRESSION)'
     is true when the given KERNEL occurs somewhere in the EXPRESSION.
     It can only be used as a test; to generate sub-terms use
     `sub_term/2'.

`free_of_term(+KERNEL, +EXPRESSION)'
     is true when the given KERNEL does not occur anywhere in the
     EXPRESSION.  NB: if the EXPRESSION contains an unbound variable,
     this must fail, as the KERNEL might occur there.  Since there are
     infinitely many KERNELS not contained in any EXPRESSION, and also
     infinitely many EXPRESSIONS not containing any KERNEL, it doesn't
     make sense to use this except as a test.

`occurrences_of_term(+KERNEL, +EXPRESSION, -TALLY)'
     is true when the given KERNEL occurs exactly TALLY times in
     EXPRESSION.  It can only be used to calculate or test TALLY; to
     enumerate KERNELS you'll have to use `sub_term/2' and then test
     them with this routine.  If you just want to find out whether
     KERNEL occurs in EXPRESSION or not, use `contains_term/2' or
     `free_of_term/2'.

`contains_var(+VARIABLE, +TERM)'
     is true when the given TERM contains at least one sub-term which
     is identical to the given VARIABLE.  We use `==' to check for the
     variable (`contains_term/2' uses `=') so it can be used to check
     for arbitrary terms, not just variables.

`free_of_var(+VARIABLE, +TERM)'
     is true when the given TERM contains no sub-term identical to the
     given VARIABLE (which may actually be any term, not just a var).
     For variables, this is precisely the "occurs check" which is
     needed for sound unification.

`occurrences_of_var(+TERM, +VARIABLE, -TALLY)'
     is true when the given VARIABLE occurs exactly TALLY times in
     TERM.  It can only be used to calculate or test TALLY; to
     enumerate Variables you'll have to use `sub_term/2' and then test
     them with this routine.  If you just want to find out whether
     VARIABLE occurs in TERM or not, use `contains_var/2' or
     `free_of_var/2'.

`sub_term(?KERNEL, +TERM)'
     is true when KERNEL is a sub-term of TERM.  It enumerates the
     sub-terms of TERM in an arbitrary order.  Well, it is defined that
     a sub-term of TERM will be enumerated before its own sub-terms are
     (but of course some of those sub-terms might be elsewhere in TERM
     as well).

`depth_bound(+TERM, +BOUND)'
     is true when the term depth of TERM is no greater than BOUND, that
     is, when constructor functions are nested no more than BOUND deep.
     Later variable bindings may invalidate this bound.  To find the
     (current) depth, use `term_depth/2'.

`length_bound(?LIST, +BOUND)'
     is true when the length of LIST is no greater than BOUND.  It can
     be used to enumerate Lists up to the bound.

`size_bound(+TERM, +BOUND)'
     is true when the number of constant and function symbols in TERM is
     (currently) at most BOUND.  If TERM is non-ground, later variable
     bindings may invalidate this bound.  To find the (current) size,
     use `term_size/2'.

`term_depth(+TERM, -DEPTH)'
          calculates the Depth of a Term, using the definition
              term_depth(Var) = 0
              term_depth(Const) = 0
              term_depth(F(T1,...,Tn)) = 1+max(term_depth(T1),...,term_depth(Tn))

`term_size(+TERM, -SIZE)'
     calculates the SIZE of a TERM, defined to be the number of
     constant and function symbol occurrences in it.

`same_functor(?T1, ?T2)'
     is true when T1 and T2 have the same principal functor.  If one of
     the terms is a variable, it will be instantiated to a new term
     with the same principal functor as the other term (which should be
     instantiated) and with arguments being new distinct variables.  If
     both terms are variables, an error is reported.

`same_functor(?T1, ?T2, ?N)'
     is true when T1 and T2 have the same principal functor, and their
     common arity is N. Like `same_functor/3', at least one of T1 and T2
     must be bound, or an error will be reported.

`same_functor(?T1, ?T2, ?F, ?N)'
     is true when T1 and T2 have the same principal functor, and their
     common functor is F/N. Given T1 (or T2) the remaining arguments
     can be computed.  Given F and N, the remaining arguments can be
     computed.  If too many arguments are unbound, an error is reported.


File: sicstus.info,  Node: lib-timeout,  Next: lib-trees,  Prev: lib-terms,  Up: The Prolog Library

10.25 Meta-Call with Limit on Execution Time--`library(timeout)'
================================================================

Exported predicates:

`time_out(:GOAL, +TIME, -RESULT)'
     The GOAL is executed as if by `call/1'.  If computing any solution
     takes more than TIME milliseconds, the goal will be aborted and
     RESULT unified with the atom `time_out'.  If the goal succeeds
     within the specified time, RESULT is unified with the atom
     `success'.  TIME must be a number between (not including) 0 and
     2147483647.

     The time is measured in process virtual time under UNIX. Under
     Windows NT/2000/XP, as of SICStus 3.10, thread virtual time is
     used, which is the same as process virtual time for
     single-threaded processes. Under Windows 98/ME the time is
     measured in real time (wall time), due to limitations in those
     operating systems.

     The precision of the time out interval is usually not better than
     several tens of milliseconds. This is due to limitations in the
     timing mechanisms used to implement `library(timeout)'.


   `time_out/3' is implemented by raising and handling `time_out'
exceptions, so any exception handler in the scope of GOAL must be
prepared to pass on `time_out' exceptions.  The following incorrect
example shows what can happen otherwise:

     | ?- time_out(on_exception(Q,(repeat,false),true), 1000, Res).
     Q = time_out,
     Res = success


File: sicstus.info,  Node: lib-trees,  Next: lib-types,  Prev: lib-timeout,  Up: The Prolog Library

10.26 Updatable Binary Trees--`library(trees)'
==============================================

This libary module provides updatable binary trees with logarithmic
access time.  Exported predicates:

`gen_label(?INDEX, +TREE, ?VALUE)'
     assumes that Tree is a proper binary tree, and is true when VALUE
     is the INDEX-TH element in TREE.  Can be used to enumerate all
     VALUES by ascending INDEX.

`get_label(+INDEX, +TREE, -LABEL)'
     treats the tree as an array of N elements and returns the INDEX-TH.
     If INDEX < 1 or > N it simply fails, there is no such element.  As
     Tree need not be fully instantiated, and is potentially unbounded,
     we cannot enumerate INDICES.

`list_to_tree(+LIST, -TREE)'
     takes a given LIST of N elements and constructs a binary TREE
     where `get_label(K, TREE, LAB)' <=> LAB is the KTH element of LIST.

`map_tree(:PRED, +OLDTREE, ?NEWTREE)'
     is true when OLDTREE and NEWTREE are binary trees of the same shape
     and PRED(OLD,NEW) is true for corresponding elements of the two
     trees.

`put_label(+INDEX, +OLDTREE, -LABEL, -NEWTREE)'
     constructs a new tree the same shape as the old which moreover has
     the same elements except that the INDEX-TH one is LABEL.  Unlike
     the "arrays" of `library(arrays)', OLDTREE is not modified and you
     can hang on to it as long as you please.  Note that O(LG N) new
     space is needed.

`put_label(+INDEX, +OLDTREE, -OLDLABEL, -NEWTREE, +NEWLABEL)'
     is true when OLDTREE and NEWTREE are trees of the same shape having
     the same elements except that the INDEX-TH element of OLDTREE is
     OLDLABEL and the INDEX-TH element of NEWTREE is NEWLABEL.  You can
     swap the <TREE,LABEL> argument pairs if you like, it makes no
     difference.

`tree_size(+TREE, -SIZE)'
     calculates the number of elements in the TREE.  All trees made by
     `list_to_tree/2' that are the same size have the same shape.

`tree_to_list(+TREE, -LIST)'
     is the converse operation to `list_to_tree/2'.  Any mapping or
     checking operation can be done by converting the tree to a list,
     mapping or checking the list, and converting the result, if any,
     back to a tree.  It is also easier for a human to read a list than
     a tree, as the order in the tree goes all over the place.


File: sicstus.info,  Node: lib-types,  Next: lib-ugraphs,  Prev: lib-trees,  Up: The Prolog Library

10.27 Type Checking--`library(types)'
=====================================

This library module provides more and better type tests.  For the
purposes of this library, we first define an abstract type TYPETERM, as
follows:

TYPETERM           ::= `atom'
                   | `atomic'
                   | `callable'
                   | `character'
                   | `character_code'
                   | `compound'
                   | `float'
                   | `float(RANGETERM)'
                   | `ground'
                   | `integer'
                   | `integer(RANGETERM)'
                   | `list'
                   | `list(TYPE)'
                   | `nonvar'
                   | `number'
                   | `number(RANGETERM)'
                   | `oneof(L)'
                   | `pair'
                   | `proper_list'
                   | `proper_list(TYPE)'
                   | `simple'
                   | `term'
                   | `var'

RANGETERM          ::= `between(L,U)'
                   | `>=(L)'
                   | `>(L)'
                   | `=\=(L)'

   Exported predicates:

`must_be(+TERM, +TYPE, +GOAL, +ARGNO)'
     checks whether the TERM belongs to the indicated TYPE, which
     should be a TYPETERM.  If it isn't, there are two cases: the TERM
     may not be instantiated enough to tell yet, in which case an
     Instantiation Error will be raised, or the TERM may be definitely
     not of the type, in which case a Type Error is raised.  You should
     use this in commands with side effects, and should arrange that if
     this predicate does not succeed the side effect(s) will not take
     place. If an exception is raised, it will pinpoint the line of
     code in the scope of which the error occurs, if possible.

`illarg(+ERRORTERM, +GOAL, +ARGNO)'
`illarg(+ERRORTERM, +GOAL, +ARGNO, +CULPRIT)'
     is the way to raise an error exception, if you would like the
     exception to pinpoint the line of code in the scope of which the
     error occurs.  This is especially useful in the context of
     source-linked debugging. CULPRIT defaults to argument number ARGNO
     of GOAL. These three arguments are passed to the exception being
     raised, if appropriate. ERRORTERM should be one of the following.
     *Note ref-ere-err::.

    `var'
          An Instantiation error is raised.

    `type(ERRORTYPE)'
          Same as `must_be(CULPRIT, ERRORTYPE, GOAL, ARGNO)'.

    `domain(ERRORTYPE,ERRORDOMAIN)'
          First, the type is checked by `must_be(CULPRIT, ERRORTYPE,
          GOAL, ARGNO)'.  If the type is valid, a Domain Error is
          raised with the expected domain being ERRORDOMAIN.

    `force_type(EXPTYPE)'
          A Type Error is raised.

    `context(CONTEXTTYPE,COMMANDTYPE)'
          A Context Error is raised.

    `existence(OBJTYPE,CULPRIT,MESSAGE)'
          An Existence Error is raised.

    `permission(OPERATION,OBJTYPE,MESSAGE)'
          A Permission Error is raised.

    `representation(ERRORTYPE)'
          A Representation Error is raised.

    `evaluation(ERRORTYPE)'
          An Evaluation Error is raised.

    `consistency(CULPRIT1,CULPRIT2,MESSAGE)'
          A Consistency Error is raised.

    `syntax(POS,MSG,TOKENS,AFTERERROR)'
          A Syntax Error is raised.

    `resource(RESOURCE)'
          A Resource Error is raised.

    `system(MESSAGE)'
          A System Error is raised.



File: sicstus.info,  Node: lib-ugraphs,  Next: lib-varnumbers,  Prev: lib-types,  Up: The Prolog Library

10.28 Unweighted Graph Operations--`library(ugraphs)'
=====================================================

This library module provides operations on directed graphs.  An
unweighted directed graph (ugraph) is represented as a list of
(VERTEX-NEIGHBORS) pairs, where the pairs are in standard order (as
produced by `keysort/2' with unique keys) and the neighbors of each
vertex are also in standard order (as produced by `sort/2'), and every
neighbor appears as a vertex even if it has no neighbors itself.

   An undirected graph is represented as a directed graph where for
each edge (U,V) there is a symmetric edge (V,U).

   An edge (U,V) is represented as the term U-V.

   A vertex can be any term.  Two vertices are distinct iff they are
not identical (`==').

   A path is represented as a list of vertices.  No vertex can appear
twice in a path.

   Exported predicates:

`vertices_edges_to_ugraph(+VERTICES, +EDGES, -GRAPH)'
     is true if VERTICES is a list of vertices, EDGES is a list of
     edges, and GRAPH is a graph built from VERTICES and EDGES.
     VERTICES and EDGES may be in any order.  The vertices mentioned in
     EDGES do not have to occur explicitly in VERTICES.  VERTICES may
     be used to specify vertices that are not connected to any edges.

`vertices(+GRAPH, -VERTICES)'
     unifies VERTICES with the vertices in GRAPH.

`edges(+GRAPH, -EDGES)'
     unifies EDGES with the edges in GRAPH.

`add_vertices(+GRAPH1, +VERTICES, -GRAPH2)'
     is true if GRAPH2 is GRAPH1 with VERTICES added to it.

`del_vertices(+GRAPH1, +VERTICES, -GRAPH2)'
     is true if GRAPH2 is GRAPH1 with VERTICES and all edges to and from
     VERTICES removed from it.

`add_edges(+GRAPH1, +EDGES, -GRAPH2)'
     is true if GRAPH2 is GRAPH1 with EDGES and their "to" and "from"
     vertices added to it.

`del_edges(+GRAPH1, +EDGES, -GRAPH2)'
     is true if GRAPH2 is GRAPH1 with EDGES removed from it.

`transpose_ugraph(+GRAPH, -TRANSPOSE)'
     is true if TRANSPOSE is the graph computed by replacing each edge
     (U,V) in GRAPH by its symmetric edge (V,U).  It can only be used
     one way around.  The cost is O(N LOG N).

`neighbors(+VERTEX, +GRAPH, -NEIGHBORS)'
`neighbours(+VERTEX, +GRAPH, -NEIGHBORS)'
     is true if VERTEX is a vertex in GRAPH and NEIGHBORS are its
     neighbors.

`complement(+GRAPH, -COMPLEMENT)'
     COMPLEMENT is the complement graph of GRAPH, i.e. the graph that
     has the same vertices as GRAPH but only the edges that are not in
     GRAPH.

`compose(+G1, +G2, -COMPOSITION)'
     computes COMPOSITION as the composition of two graphs, which need
     not have the same set of vertices.

`transitive_closure(+GRAPH, -CLOSURE)'
     computes CLOSURE as the transitive closure of GRAPH in O(N^3) time.

`symmetric_closure(+GRAPH, -CLOSURE)'
     computes CLOSURE as the symmetric closure of GRAPH, i.e. for each
     edge (U,V) in GRAPH, add its symmetric edge (V,U).  Approx. O(N
     LOG N) time.  This is useful for making a directed graph
     undirected.

`top_sort(+GRAPH, -SORTED)'
     finds a topological ordering of GRAPH and returns the ordering as
     a list of SORTED vertices.  Fails iff no ordering exists, i.e.
     iff the graph contains cycles.  Approx. O(N LOG N) time.

`max_path(+V1, +V2, +GRAPH, -PATH, -COST)'
     is true if PATH is a list of vertices constituting a longest path
     of cost COST from V1 to V2 in GRAPH, there being no cyclic paths
     from V1 to V2.  Takes O(N^2) time.

`min_path(+V1, +V2, +GRAPH, -PATH, -LENGTH)'
     is true if PATH is a list of vertices constituting a shortest path
     of length LENGTH from V1 to V2 in GRAPH.  Takes O(N^2) time.

`min_paths(+VERTEX, +GRAPH, -TREE)'
     is true if TREE is a tree of all the shortest paths from VERTEX to
     every other vertex in GRAPH.  This is the single-source shortest
     paths problem.  The algorithm is straightforward.

`path(+VERTEX, +GRAPH, -PATH)'
     is given a GRAPH and a VERTEX of that GRAPH, and returns a maximal
     PATH rooted at VERTEX, enumerating more PATHS on backtracking.

`reduce(+GRAPH, -REDUCED)'
     is true if REDUCED is the reduced graph for GRAPH. The vertices of
     the reduced graph are the strongly connected components of GRAPH.
     There is an edge in REDUCED from U to V iff there is an edge in
     GRAPH from one of the vertices in U to one of the vertices in V. A
     strongly connected component is a maximal set of vertices where
     each vertex has a path to every other vertex.  Algorithm from
     "Algorithms" by Sedgewick, page 482, Tarjan's algorithm.

`reachable(+VERTEX, +GRAPH, -REACHABLE)'
     is given a Graph and a VERTEX of that GRAPH, and returns the set
     of vertices that are REACHABLE from that VERTEX.  Takes O(N^2)
     time.

`random_ugraph(+P, +N, -GRAPH)'
     where P is a probability, unifies GRAPH with a random graph of N
     vertices where each possible edge is included with probability P.

`min_tree(+GRAPH, -TREE, -COST)'
     is true if TREE is a spanning tree of an _undirected_ GRAPH with
     cost COST, if it exists.  Using a version of Prim's algorithm.


File: sicstus.info,  Node: lib-varnumbers,  Next: lib-wgraphs,  Prev: lib-ugraphs,  Up: The Prolog Library

10.29 An Inverse of numbervars/3--`library(varnumbers)'
=======================================================

The built-in predicate `numbervars/3' makes a term ground by binding
the variables in it to subterms of the form `'$VAR'(N)' where N is an
integer.  Most of the calls to `numbervars/3' look like
         numbervars(Term, 0, _)
   which can be abbreviated to
         numbervars(Term)
   if you use this package.

   `varnumbers/3' is a partial inverse to `numbervars/3':
         varnumbers(Term, N0, Copy)
   unifies COPY with a copy of TERM in which subterms of the form
`'$VAR'(N)' where N is an integer not less than N0 (that is, subterms
which might have been introduced by `numbervars/3' with second argument
N0) have been consistently replaced by new variables.  Since 0 is the
usual second argument of `numbervars/3', there is also
         varnumbers(Term, Copy)

   This provides a facility whereby a Prolog-like data base can be kept
as a term.  For example, we might represent `append/3' thus:
         Clauses = [
             (append([], '$VAR'(0), '$VAR'(0)) :- true),
             (append(['$VAR'(0)|'$VAR'(1), '$VAR'(2), ['$VAR'(0)|'$VAR(3)]) :-
                 append('$VAR'(1), '$VAR'(2), '$VAR'(3)))
         ]
   and we might access clauses from it by doing
         prove(Goal, Clauses) :-
                 member(Clause, Clauses),
                 varnumbers(Clause, (Goal:-Body)),
                 prove(Goal).

   Exported predicates:

`numbervars(+TERM)'
     makes TERM ground by binding variables to subterms `'$VAR'(N)' with
     values of N ranging from 0 up.

`varnumbers(+TERM, -COPY)'
     xo succeeds when TERM was a term producing by calling
     `numbervars(TERM)' and COPY is a copy of TERM with such subterms
     replaced by variables.

`varnumbers(+TERM, +N0, -COPY)'
     succeeds when TERM was a term produced by calling
     `numbervars(TERM, N0, N)' (so that all subterms `'$VAR'(X)' have
     `integer(X)', `X >= N0') and COPY is a copy of TERM with such
     subterms replaced by variables.


File: sicstus.info,  Node: lib-wgraphs,  Next: lib-xml,  Prev: lib-varnumbers,  Up: The Prolog Library

10.30 Weighted Graph Operations--`library(wgraphs)'
===================================================

This library module provides operations on weighted directed graphs.  A
weighted directed graph (wgraph) is represented as a list of
(VERTEX-EDGELIST) pairs, where the pairs are in standard order (as
produced by `keysort/2' with unique keys), the edgelist is a list of
(NEIGHBOR-WEIGHT) pair also in standard order (as produced by
`keysort/2' with unique keys), every weight is a nonnegative integer,
and every neighbor appears as a vertex even if it has no neighbors
itself.

   An undirected graph is represented as a directed graph where for
each edge (U,V) there is a symmetric edge (V,U).

   An edge (U,V) is represented as the term U-V.

   A vertex can be any term.  Two vertices are distinct iff they are
not identical (`==').

   A path is represented as a list of vertices.  No vertex can appear
twice in a path.

   Exported predicates:

`vertices/2'
`edges/2'
`add_vertices/3'
`neighbors/3'
`neighbours/3'
     Re-exported from `library(wgraphs)'.

`wgraph_to_ugraph(+WEIGHTEDGRAPH, -GRAPH)'
     is true if GRAPH has the same vertices and edges as WEIGHTEDGRAPH,
     except the edges of GRAPH are unweighted.

`ugraph_to_wgraph(+GRAPH, -WEIGHTEDGRAPH)'
     is true if WEIGHTEDGRAPH has the same vertices and edges as GRAPH,
     except the edges of WEIGHTEDGRAPH all have weight 1.

`ugraph_to_wgraph(+SubGraph, +WeightedGraph, -WeightedSubGraph)'
     is true if WeightedSubGraph has the same vertices and edges as
     SubGraph and the same weights as the corresponding edges in
     WeightedGraph.

`vertices_edges_to_wgraph(+VERTICES, +EDGES, -WEIGHTEDGRAPH)'
     is true if VERTICES is a list of vertices, EDGES is a list of
     edges, and WEIGHTEDGRAPH is a graph built from VERTICES and EDGES.
     VERTICES and EDGES may be in any order.  The vertices mentioned in
     EDGES do not have to occur explicitly in VERTICES.  VERTICES may
     be used to specify vertices that are not connected to any edges.

`del_vertices(+WEIGHTEDGRAPH1, +VERTICES, -WEIGHTEDGRAPH2)'
     is true if WEIGHTEDGRAPH2 is WEIGHTEDGRAPH1 with VERTICES and all
     edges to and from VERTICES removed from it.

`add_edges(+WEIGHTEDGRAPH1, +EDGES, -WEIGHTEDGRAPH2)'
     is true if WEIGHTEDGRAPH2 is WEIGHTEDGRAPH1 with EDGES and their
     "to" and "from" vertices added to it.

`del_edges(+WEIGHTEDGRAPH1, +EDGES, -WEIGHTEDGRAPH2)'
     is true if WEIGHTEDGRAPH2 is WEIGHTEDGRAPH1 with EDGES removed
     from it.

`transpose_wgraph(+WEIGHTEDGRAPH, -TRANSPOSE)'
     is true if TRANSPOSE is the graph computed by replacing each edge
     (U,V) in WEIGHTEDGRAPH by its symmetric edge (V,U).  It can only
     be used one way around.  The cost is O(N LOG N).

`transitive_closure(+WEIGHTEDGRAPH, -CLOSURE)'
     computes Closure as the transitive closure of WEIGHTEDGRAPH in
     O(N^3) time.  Uses Floyd's algorithm and fragments of Barney
     Pell's code.

`symmetric_closure(+WEIGHTEDGRAPH, -CLOSURE)'
     computes CLOSURE as the symmetric closure of WEIGHTEDGRAPH, i.e.
     for each edge (U,V) in WEIGHTEDGRAPH, add its symmetric edge
     (V,U).  Approx O(N LOG N) time.  This is useful for making a
     directed graph undirected.

`top_sort(+GRAPH, -SORTED)'
     finds a topological ordering of a GRAPH and returns the ordering
     as a list of SORTED vertices.  Fails iff no ordering exists, i.e.
     iff the graph contains cycles.  Takes O(N LOG N) time.

`max_path(+V1, +V2, +WEIGHTEDGRAPH, -PATH, -COST)'
     is true if PATH is a list of vertices constituting a longest path
     of cost Cost from V1 to V2 in WEIGHTEDGRAPH, there being no cyclic
     paths from V1 to V2.  Takes O(N^2) time.

`min_path(+V1, +V2, +WEIGHTEDGRAPH, -PATH, -COST)'
     is true if PATH is a list of vertices constituting a shortest path
     with total cost COST from V1 to V2 in WEIGHTEDGRAPH.  Takes O(N^2)
     time.

`min_paths(+VERTEX, +WEIGHTEDGRAPH, -TREE)'
     is true if TREE is a tree of all the shortest paths from VERTEX to
     every other vertex in WEIGHTEDGRAPH.  This is the single-source
     shortest paths problem.  Using Dijkstra's algorithm.

`path(+VERTEX, +WEIGHTEDGRAPH, -PATH)'
     is given a WEIGHTEDGRAPH and a VERTEX of that WEIGHTEDGRAPH, and
     returns a maximal PATH rooted at VERTEX, enumerating more PATHS on
     backtracking.

`reduce(+WEIGHTEDGRAPH, -REDUCED)'
     is true if REDUCED is the reduced graph for WEIGHTEDGRAPH. The
     vertices of the reduced graph are the strongly connected
     components of WEIGHTEDGRAPH.  There is an edge in REDUCED from U
     to V iff there is an edge in WEIGHTEDGRAPH from one of the
     vertices in U to one of the vertices in V. A strongly connected
     component is a maximal set of vertices where each vertex has a
     path to every other vertex.  Algorithm from "Algorithms" by
     Sedgewick, page 482, Tarjan's algorithm.

`reachable(+VERTEX, +WEIGHTEDGRAPH, -REACHABLE)'
     is given a WEIGHTEDGRAPH and a VERTEX of that WEIGHTEDGRAPH, and
     returns the set of vertices that are REACHABLE from that VERTEX.
     Takes O(N^2) time.

`random_wgraph(+P, +N, +W, -WEIGHTEDGRAPH)'
     where P is a probability, unifies WEIGHTEDGRAPH with a random
     graph with vertices 1..N where each possible edge is included with
     probability P and random weight in 1..W.

`min_tree(+WEIGHTEDGRAPH, -TREE, -COST)'
     is true if TREE is a minimum-COST spanning tree of an _undirected_
     WEIGHTEDGRAPH with cost COST, if it exists.  Using Kruskal's
     algorithm.


File: sicstus.info,  Node: lib-xml,  Next: lib-linda,  Prev: lib-wgraphs,  Up: The Prolog Library

10.31 Parsing and Generating XML--`library(xml)'
================================================

This is a package for parsing XML with Prolog, which provides Prolog
applications with a simple "Document Value Model" interface to XML
documents.  A description of the subset of XML that it supports can be
found at: `http://homepages.tesco.net/binding-time/xml.pl.html'

   The package, originally written by Binding Time Ltd., is in the
public domain and unsupported.  To use the package, enter the query:

   The package represents XML documents by the abstract data type
DOCUMENT, which is defined by the following grammar:

DOCUMENT       ::=                           { well-formed document }
               `xml(ATTRIBUTES,CONTENT)'     
               |                             { malformed document }
               `malformed(ATTRIBUTES,CONTENT)'

ATTRIBUTES     ::= `[]'                      
               |                             
               `[NAME=CHAR-DATA|ATTRIBUTES]' 

CONTENT        ::= `[]'                      
               |   `[CTERM|CONTENT]'         

CTERM          ::= `pcdata(CHAR-DATA)'       { text }
               |   `comment(CHAR-DATA)'      { an XML comment }
               |                             { a Namespace }
               `namespace(URI,PREFIX,ELEMENT)'
               |                             { <TAG>..</TAG> encloses
               `element(TAGATTRIBUTES,CONTENT)'CONTENT or <TAG /> if empty }
               |                             { A PI <? NAME CHAR-DATA ?> }
               `instructions(NAME,CHAR-DATA)'
               |   `cdata(CHAR-DATA)'        { <![CDATA[CHAR-DATA]]>  }
               |                             { DTD <!DOCTYPE .. > }
               `doctype(TAG,DOCTYPE-ID)'     
               |   `unparsed(CHAR-DATA)'     { text that hasn't been
                                             parsed }
               |   `out_of_context(TAG)'     { TAG is not closed }

TAG            ::= "atom"                    { naming an element }

NAME           ::= "atom"                    { not naming an element }

URI            ::= "atom"                    { giving the URI of a
                                             namespace }

CHAR-DATA      ::= "code-list"               

DOCTYPE-ID     ::=                           
               `public(CHAR-DATA,CHAR-DATA)' 
               |                             
               `public(CHAR-DATA,DTD-LITERALS)'
               |   `system(CHAR-DATA)'       
               |                             
               `system(CHAR-DATA,DTD-LITERALS)'
               |   `local'                   
               |   `local,DTD-LITERALS'      

DTD-LITERALS   ::= `[]'                      
               |                             
               `[dtd_literal(CHAR-DATA)|DTD-LITERALS]'

   The following predicates are exported by the package:

`xml_parse(?CHARS, ?DOCUMENT)'
`xml_parse(?CHARS, ?DOCUMENT, +OPTIONS)'
     Either parses CHARS, a "code-list", to DOCUMENT, a DOCUMENT.
     CHARS is not required to represent strictly well-formed XML.  Or
     generates CHARS, a "code-list", from DOCUMENT, a DOCUMENT.  If
     DOCUMENT is not a valid DOCUMENT term representing well-formed
     XML, an exception is raised.  In the second usage of the
     predicate, the only option available is `format/1'.

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be `true' or `false':

    `format(BOOLEAN)'
          Indent the element content (default `true').

    `extended_characters(BOOLEAN)'
          Use the extended character entities for XHTML (default
          `true').

    `remove_attribute_prefixes(BOOLEAN)'
          Remove namespace prefixes from attributes when it's the same
          as the prefix of the parent element (default `false').

`xml_subterm(+TERM, ?SUBTERM)'
     Unifies SUBTERM with a sub-term of TERM, a DOCUMENT. This can be
     especially useful when trying to test or retrieve a deeply-nested
     subterm from a document.

`xml_pp(+DOCUMENT)'
     "Pretty prints" DOCUMENT, a DOCUMENT, on the current output stream.


File: sicstus.info,  Node: lib-linda,  Next: lib-chr,  Prev: lib-xml,  Up: The Prolog Library

10.32 Process Communication--`library(linda/[server,client])'
=============================================================

Linda is a concept for process communication.

   For an introduction and a deeper description, see [Carreiro &
Gelernter 89a] or [Carreiro & Gelernter 89b], respectively.

   One process is running as a server and one or more processes are
running as clients.  The processes are communicating with sockets and
supports networks.

   The server is in principle a blackboard on which the clients can
write (`out/1'), read (`rd/1') and remove (`in/1') data.  If the data
is not present on the blackboard, the predicates suspend the process
until they are available.

   There are some more predicates besides the basic `out/1', `rd/1' and
`in/1'.  The `in_noblock/1' and `rd_noblock/1' does not suspend if the
data is not available--they fail instead.  A blocking fetch of a
conjunction of data can be done with `in/2' or `rd/2'.

   Example: A simple producer-consumer.  In client 1:
     producer :-
            produce(X),
            out(p(X)),
            producer.

     produce(X) :- .....

   In client 2:

     consumer :-
            in(p(A)),
            consume(A),
            consumer.

     consume(A) :- .....

   Example: Synchronization

            ...,
            in(ready),  %Waits here until someone does out(ready)
            ...,

   Example: A critical region

            ...,
            in(region_free),  % wait for region to be free
            critical_part,
            out(region_free), % let next one in
            ...,

   Example: Reading global data

            ...,
            rd(data(Data)),
            ...,

     or, without blocking:
            ...,
            rd_noblock(data(Data)) ->
                  do_something(Data)
            ;     write('Data not available!'),nl
            ),
            ...,

   Example: Waiting for one of several events

            ...,
            in([e(1),e(2),...,e(n)], E),
     %  Here is E instantiated to the first tuple that became available
            ...,

* Menu:

* lib-linda-server:: Linda Server
* lib-linda-client:: Linda Client


File: sicstus.info,  Node: lib-linda-server,  Next: lib-linda-client,  Up: lib-linda

10.32.1 Linda Server
--------------------

The server is the process running the "blackboard process".  It is an
ordinary SICStus process, which can be run on a separate machine if
necessary.

   To load the package, enter the query

     | ?- use_module(library('linda/server')).

and start the server with `linda/[0,1]'.

`linda'
     Starts a Linda-server in this SICStus.  The network address is
     written to the current output stream as HOST:PORTNUMBER.

`linda(:OPTIONS)'
     Starts a Linda-server in this SICStus. Each option on the list
     OPTIONS is one of
    `ADDRESS-GOAL'
          where ADDRESS must be unifiable with HOST:PORT and GOAL must
          be instantiated to a goal.

          When the linda server is started, HOST and PORT are bound to
          the server host and port respectively and the goal GOAL is
          called. A typical use of this would be to store the
          connection information in a file so that the clients can find
          the server to connect to.

          For backward compatibility, if OPTIONS is not a list, it is
          assumed to be an option of the form `ADDRESS-GOAL'.

          In SICStus before 3.9.1, GOAL needed an explicit module
          prefix to ensure it was called in the right module. This is no
          longer necessary since `linda/1' is now a meta-predicate.

    `accept_hook(CLIENT,STREAM,GOAL)'
          When a client attempts to connects to the server CLIENT and
          STREAM will be bound to the IP address of the client and the
          socket stream connected to the client, respectively. The GOAL
          is then called, and if it succeeds, the client is allowed to
          connect. If GOAL fails, the server will close the stream and
          ignore the connection request. A typical use of this feature
          would be to restrict the addresses of the clients allowed to
          connect. If you require bullet proof security, you would
          probably need something more sophisticated.


     Example:
          | ?- linda([(Host:Port)-mypred(Host,Port),
                      accept_hook(C,S,should_accept(C,S))]).

     will call `mypred/2' when the server is started.  `mypred/2' could
     start the client-processes, save the address for the clients etc.
     Whenever a client attempts to connect from a host with IP address
     ADDR, a bi-directional socket stream STREAM will be opened to the
     client, and `should_accept(ADDR,STREAM)' will be called to
     determine if the client should be allowed to connect.



File: sicstus.info,  Node: lib-linda-client,  Prev: lib-linda-server,  Up: lib-linda

10.32.2 Linda Client
--------------------

The clients are one or more SICStus processes that have connection(s)
to the server.

   To load the package, enter the query

     | ?- use_module(library('linda/client')).

   Some of the following predicates fail if they don't receive an
answer from the Linda-server in a reasonable amount of time.  That time
is set with the predicate `linda_timeout/2'.

`linda_client(+ADDRESS)'
     Establishes a connection to a Linda-server specified by ADDRESS.
     The ADDRESS is of the format HOST:PORTNUMBER as given by
     `linda/[0,1]'.

     It is not possible to be connected to two Linda-servers at the
     same time.

     This predicate can fail due to a timeout.

`close_client'
     Closes the connection to the server.

`shutdown_server/0'
     Sends a Quit signal to the server, which keeps running after
     receiving this signal, until such time as all the clients have
     closed their connections. It is up to the clients to tell each
     other to quit. When all the clients are done, the server stops
     (i.e. `linda/[0,1]' succeeds).  Courtesy of Malcolm Ryan.  Note
     that `close_client/0' should be called _after_
     `shutdown_server/0'. `shutdown_server/0' will raise an error if
     there is no connection between the client and the server.

`linda_timeout(?OLDTIME, ?NEWTIME)'
     This predicate controls Linda's timeout. OLDTIME is unified with
     the old timeout and then timeout is set to NEWTIME.  The value is
     either `off' or of the form SECONDS:MILLISECONDS.  The former
     value indicates that the timeout mechanism is disabled, that is,
     eternal waiting.  The latter form is the TIMEOUT-TIME.

`out(+TUPLE)'
     Places the tuple TUPLE in Linda's tuple-space.

`in(?TUPLE)'
     Removes the tuple TUPLE from Linda's tuple-space if it is there.
     If not, the predicate blocks until it is available (that is,
     someone performs an `out/1').

`in_noblock(?TUPLE)'
     Removes the tuple TUPLE from Linda's tuple-space if it is there.
     If not, the predicate fails.

     This predicate can fail due to a timeout.

`in(+TUPLELIST, ?TUPLE)'
     As `in/1' but succeeds when either of the tuples in TUPLELIST is
     available. TUPLE is unified with the fetched tuple.  If that
     unification fails, the tuple is _not_ reinserted in the
     tuple-space.

`rd(?TUPLE)'
     Succeeds if TUPLE is available in the tuple-space, suspends
     otherwise until it is available.  Compare this with `in/1': the
     tuple is _not_ removed.

`rd_noblock(?TUPLE)'
     Succeeds if TUPLE is available in the tuple-space, fails otherwise.

     This predicate can fail due to a timeout.

`rd(+TUPLELIST, ?TUPLE)'
     As `in/2' but does not remove any tuples.

`bagof_rd_noblock(?TEMPLATE, +TUPLE, ?BAG)'
     BAG is the list of all instances of TEMPLATE such that TUPLE
     exists in the tuple-space.

     The behavior of variables in TUPLE and TEMPLATE is as in
     `bagof/3'.  The variables could be existentially quantified with
     `^/2' as in `bagof/3'.

     The operation is performed as an atomic operation.

     This predicate can fail due to a timeout.

     Example: Assume that only one client is connected to the server
     and that the tuple-space initially is empty.
          | ?- out(x(a,3)), out(x(a,4)), out(x(b,3)), out(x(c,3)).

          | ?- bagof_rd_noblock(C-N, x(C,N), L).

          C = _32,
          L = [a-3,a-4,b-3,c-3],
          N = _52

          | ?- bagof_rd_noblock(C, N^x(C,N), L).

          C = _32,
          L = [a,a,b,c],
          N = _48


File: sicstus.info,  Node: lib-chr,  Next: lib-clpfd,  Prev: lib-linda,  Up: The Prolog Library

10.33 Constraint Handling Rules--`library(chr)'
===============================================

This section is written by Tom Schrijvers, K.U. Leuven, and adjustments
by Jan Wielemaker.

   The CHR system of SICstus Prolog is the K.U.Leuven CHR system.  The
runtime environment is written by Christian Holzbaur and Tom Schrijvers
while the compiler is written by Tom Schrijvers. Both are integrated
with SICStus Prolog and licensed under compatible conditions with
permission from the authors.

   The main reference for the CHR system is [Schrijvers & Demoen 04].

* Menu:

* CHR Introduction::
* CHR Syntax and Semantics::
* CHR in Prolog Programs::
* CHR Debugging::
* CHR Examples::
* CHR Guidelines::


File: sicstus.info,  Node: CHR Introduction,  Next: CHR Syntax and Semantics,  Up: lib-chr

10.33.1 Introduction
--------------------

Constraint Handling Rules (CHR) is a committed-choice rule-based
language embedded in Prolog. It is designed for writing constraint
solvers and is particularly useful for providing application-specific
constraints.  It has been used in many kinds of applications, like
scheduling, model checking, abduction, type checking among many others.

   CHR has previously been implemented in other Prolog systems (SICStus,
Eclipse, Yap), Haskell and Java. This CHR system is based on the
compilation scheme and runtime environment of CHR in SICStus.

   In this documentation we restrict ourselves to giving a short
overview of CHR in general and mainly focus on elements specific to this
implementation. For a more thorough review of CHR we refer the reader to
[Fruehwirth 98].

   In *Note CHR Syntax and Semantics:: we present the syntax of CHR in
Prolog and explain informally its operational semantics. Next, *Note
CHR in Prolog Programs:: deals with practical issues of writing and
compiling Prolog programs containing CHR. *Note CHR Debugging::
explains the currently primitive CHR debugging facilities.  *Note CHR
Debugging Predicates:: provides a few useful predicates to inspect the
constraint store and *Note CHR Examples:: illustrates CHR with two
example programs.  Finally, *Note CHR Guidelines:: concludes with a few
practical guidelines for using CHR.


File: sicstus.info,  Node: CHR Syntax and Semantics,  Next: CHR in Prolog Programs,  Prev: CHR Introduction,  Up: lib-chr

10.33.2 Syntax and Semantics
----------------------------

* Menu:

* CHR Syntax::
* CHR Semantics::


File: sicstus.info,  Node: CHR Syntax,  Next: CHR Semantics,  Up: CHR Syntax and Semantics

10.33.2.1 Syntax
................

The syntax of CHR rules is the following:

RULES          ::= RULE RULES
RULES          ::= EMPTY

RULE           ::= NAME ACTUAL_RULE PRAGMA `.'

NAME           ::= ATOM `@'
NAME           ::= EMPTY

ACTUAL_RULE    ::= SIMPLIFICATION_RULE
ACTUAL_RULE    ::= PROPAGATION_RULE
ACTUAL_RULE    ::= SIMPAGATION_RULE

SIMPLIFICATION_RULE::= HEAD `<=>' GUARD BODY
PROPAGATION_RULE::= HEAD `==>' GUARD BODY
SIMPAGATION_RULE::= HEAD `\' HEAD `<=>' GUARD BODY

HEAD           ::= CONSTRAINTS

CONSTRAINTS    ::= CONSTRAINT CONSTRAINT_ID
CONSTRAINTS    ::= CONSTRAINT CONSTRAINT_ID `,' CONSTRAINTS

CONSTRAINT     ::= COMPOUND_TERM

CONSTRAINT_ID  ::= EMPTY
CONSTRAINT_ID  ::= `#' VARIABLE

GUARD          ::= EMPTY
GUARD          ::= GOAL `|'

BODY           ::= GOAL

PRAGMA         ::= EMPTY
PRAGMA         ::= `pragma' ACTUAL_PRAGMAS

ACTUAL_PRAGMAS ::= ACTUAL_PRAGMA
ACTUAL_PRAGMAS ::= ACTUAL_PRAGMA `,' ACTUAL_PRAGMAS

ACTUAL_PRAGMA  ::= `passive(VARIABLE)'

   Note that the guard of a rule may not contain any goal that binds a
variable in the head of the rule with a non-variable or with another
variable in the head of the rule. It may however bind variables that do
not appear in the head of the rule, e.g. an auxiliary variable
introduced in the guard.


File: sicstus.info,  Node: CHR Semantics,  Prev: CHR Syntax,  Up: CHR Syntax and Semantics

10.33.2.2 Semantics
...................

In this subsubsection the operational semantics of CHR in Prolog are
presented informally. They do not differ essentially from other CHR
systems.

   When a constraint is called, it is considered an active constraint
and the system will try to apply the rules to it. Rules are tried and
executed sequentially in the order they are written.

   A rule is conceptually tried for an active constraint in the
following way. The active constraint is matched with a constraint in
the head of the rule. If more constraints appear in the head they are
looked for among the suspended constraints, which are called passive
constraints in this context. If the necessary passive constraints can
be found and all match with the head of the rule and the guard of the
rule succeeds, the rule is committed and the body of the rule executed.
If not all the necessary passive constraint can be found, the matching
fails or the guard fails, the body is not executed and the process of
trying and executing simply continues with the following rules. If for
a rule, there are multiple constraints in the head, the active
constraint will try the rule sequentially multiple times, each time
trying to match with another constraint.

   This process ends either when the active constraint disappears, i.e.
it is removed by some rule, or after the last rule has been processed.
In the latter case the active constraint becomes suspended.

   A suspended constraint is eligible as a passive constraint for an
active constraint. The other way it may interact again with the rules,
is when a variable appearing in the constraint becomes bound to either
a non-variable or another variable involved in one or more constraints.
In that case the constraint is triggered, i.e. it becomes an active
constraint and all the rules are tried.

   Rule Types.  There are three different kinds of rules, each with
their specific semantics:

"simplification"
     The simplification rule removes the constraints in its head and
     calls its body.

"propagation"
     The propagation rule calls its body exactly once for the
     constraints in its head.

"simpagation"
     The simpagation rule removes the constraints in its head after the
     `\' and then calls its body. It is an optimization of
     simplification rules of the form:

          CONSTRAINTS_1, CONSTRAINTS_2 <=> CONSTRAINTS_1, BODY

     Namely, in the simpagation form:

          CONSTRAINTS_1 \ CONSTRAINTS_2 <=> BODY

     the CONSTRAINTS_1 constraints are not called in the body.

   Rule Names.  Naming a rule is optional and has no semantical
meaning. It only functions as documentation for the programmer.

   Pragmas.  The semantics of the pragmas are:

`passive(IDENTIFIER)'
     The constraint in the head of a rule IDENTIFIER can only match a
     passive constraint in that rule.

   Additional pragmas may be released in the future.

   Options.  

   It is possible to specify options that apply to all the CHR rules in
the module.  Options are specified with the `chr_option/2' declaration:

     :- chr_option(Option,Value).

and may appear in the file anywhere after the first constraints
declaration.

   Available options are:
`check_guard_bindings'
     This option controls whether guards should be checked for
     (illegal) variable bindings or not. Possible values for this
     option are `on', to enable the checks, and `off', to disable the
     checks. If this option is on, any guard fails when it binds a
     variable that appears in the head of the rule.  When the option is
     off, the behavior of a binding in the guard is undefined.

`optimize'
     This option controls the degree of optimization.  Possible values
     are `full', to enable all available optimizations, and `off' (the
     default), to disable all optimizations.  If optimization is
     enabled, debugging must be disabled.

`debug'
     This options enables or disables the possibility to debug the CHR
     code.  Possible values are `on' (the default) and `off'. See *Note
     CHR Debugging:: for more details on debugging.


File: sicstus.info,  Node: CHR in Prolog Programs,  Next: CHR Debugging,  Prev: CHR Syntax and Semantics,  Up: lib-chr

10.33.3 CHR in Prolog Programs
------------------------------

* Menu:

* CHR Embedding in Prolog Programs::
* CHR Constraint Declaration::
* CHR Compilation::


File: sicstus.info,  Node: CHR Embedding in Prolog Programs,  Next: CHR Constraint Declaration,  Up: CHR in Prolog Programs

10.33.3.1 Embedding in Prolog Programs
......................................

The CHR constraints defined in a `.pl' file are associated with a
module. The default module is `user'. One should never load different
`.pl' files with the same CHR module name.


File: sicstus.info,  Node: CHR Constraint Declaration,  Next: CHR Compilation,  Prev: CHR Embedding in Prolog Programs,  Up: CHR in Prolog Programs

10.33.3.2 Constraint Declaration
................................

Every constraint used in CHR rules has to be declared with a
`chr_constraint/1' declaration by the "constraint specifier". For
convenience multiple constraints may be declared at once with the same
`chr_constraint/1' declaration followed by a comma-separated list of
constraint specifiers.

   A constraint specifier is, in its compact form, F/A where F and A
are respectively the functor name and arity of the constraint, e.g.

     :- chr_constraint foo/1.
     :- chr_constraint bar/2, baz/3.

   In its extended form, a constraint specifier is `C(A_1,...,A_N)'
where C is the constraint's functor, N its arity and the A_I are
argument specifiers. An argument specifier is a mode, optionally
followed by a type. E.g.

     :- chr_constraint get_value(+,?).
     :- chr_constraint domain(?int,+list(int)),
                        alldifferent(?list(int)).

   A mode is one of the following:

`-'
     The corresponding argument of every occurrence of the constraint
     is always unbound.

`+'
     The corresponding argument of every occurrence of the constraint
     is always ground.

`?'
     The corresponding argument of every occurrence of the constraint
     can have any instantiation, which may change over time. This is the
     default value.

   A type can be a user-defined type or one of the built-in types. A
type comprises a (possibly infinite) set of values. The type
declaration for a constraint argument means that for every instance of
that constraint the corresponding argument is only ever bound to values
in that set. It does not state that the argument necessarily has to be
bound to a value.

   The built-in types are:

`int'
     The corresponding argument of every occurrence of the constraint
     is an integer.

`float'
     ... a floating point number.

`number'
     ... a number.

`natural'
     ... a positive integer.

`any'
     The corresponding argument of every occurrence of the constraint
     can have any type. This is the default value.

   User-defined types are algebraic data types, similar to those in
Haskell or the discriminated unions in Mercury. An algebraic data type
is defined using

     :- chr_type TYPE ---> BODY.

   If the type term is a functor of arity zero (i.e. one having zero
arguments), it names a "monomorphic" type. Otherwise, it names a
"polymorphic" type; the arguments of the functor must be distinct type
variables. The body term is defined as a sequence of constructor
definitions separated by semi-colons.

   Each constructor definition must be a functor whose arguments (if
any) are types. Discriminated union definitions must be transparent: all
type variables occurring in the body must also occur in the type.

   Here are some examples of algebraic data type definitions:

     :- chr_type color ---> red ; blue ; yellow ; green.
     :- chr_type tree --->  empty ; leaf(int) ; branch(tree, tree).
     :- chr_type list(T) --->    [] ; [T | list(T)].
     :- chr_type pair(T1, T2) ---> (T1 - T2).

   Each algebraic data type definition introduces a distinct type. Two
algebraic data types that have the same bodies are considered to be
distinct types (name equivalence).

   Constructors may be overloaded among different types: there may be
any number of constructors with a given name and arity, so long as they
all have different types.

   Aliases can be defined using `=='. For example, if your program uses
lists of lists of integers, you can define an alias as follows:

     :- chr_type lli == list(list(int)).


File: sicstus.info,  Node: CHR Compilation,  Prev: CHR Constraint Declaration,  Up: CHR in Prolog Programs

10.33.3.3 Compilation
.....................

The Prolog CHR compiler exploits `user:term_expansion/6' rules to
translate the constraint handling rules to plain Prolog. These rules
are loaded from `library(chr)'.  They are activated after finding a
declaration of the format:

     :- chr_constraint ...

   It is advised to define CHR rules in a module file, where the module
declaration is immediately followed by loading `library(chr)' as
exemplified below:

     :- module(zebra, [ zebra/0 ]).
     :- use_module(library(chr)).

     :- chr_constraint ...


File: sicstus.info,  Node: CHR Debugging,  Next: CHR Examples,  Prev: CHR in Prolog Programs,  Up: lib-chr

10.33.4 Debugging
-----------------

The CHR debugging facilities are currently rather limited. Only tracing
is currently available.  To use the CHR debugging facilities for a CHR
file it must be compiled for debugging. Generating debug info is
controlled by the CHR option `debug', whose default is derived from the
CHR flag `generate_debug_info'.

* Menu:

* CHR Ports::
* CHR Tracing::
* CHR Debugging Predicates::


File: sicstus.info,  Node: CHR Ports,  Next: CHR Tracing,  Up: CHR Debugging

10.33.4.1 Ports
...............

For CHR constraints the four standard ports are defined:

`call'
     A new constraint is called and becomes active.

`exit'
     An active constraint exits: it has either been inserted in the
     store after trying all rules or has been removed from the
     constraint store.

`fail'
     An active constraint fails.

`redo'
     An active constraint starts looking for an alternative solution.

   In addition to the above ports, CHR constraints have five additional
ports:

`wake'
     A suspended constraint is woken and becomes active.

`insert'
     An active constraint has tried all rules and is suspended in the
     constraint store.

`remove'
     An active or passive constraint is removed from the constraint
     store.

`try'
     An active constraints tries a rule with possibly some passive
     constraints. The try port is entered just before committing to the
     rule.

`apply'
     An active constraints commits to a rule with possibly some passive
     constraints. The apply port is entered just after committing to the
     rule.


File: sicstus.info,  Node: CHR Tracing,  Next: CHR Debugging Predicates,  Prev: CHR Ports,  Up: CHR Debugging

10.33.4.2 Tracing
.................

Tracing is enabled with the `chr_trace/0' predicate and disabled with
the `chr_notrace/0' predicate.

   When enabled, the tracer will step through the `call', `exit',
`fail', `wake' and `apply' ports, accepting debug commands, and simply
write out the other ports.

   The following debug commands are currently supported:

     CHR debug options:

             <cr>    creep           c       creep
             s       skip
             g       ancestors
             n       nodebug
             b       break
             a       abort
             f       fail
             ?       help            h       help

   Their meaning is:

`creep'
     Step to the next port.

`skip'
     Skip to exit port of this call or wake port.

`ancestors'
     Print list of ancestor call and wake ports.

`nodebug'
     Disable the tracer.

`break'
     Enter a recursive Prolog toplevel.  See `break/0'.

`abort'
     Exit to the toplevel.  See `abort/0'.

`fail'
     Insert failure in execution.

`help'
     Print the above available debug options.


File: sicstus.info,  Node: CHR Debugging Predicates,  Prev: CHR Tracing,  Up: CHR Debugging

10.33.4.3 Debugging Predicates
..............................

The `chr' module exports several predicates that allow inspecting and
printing the content of the constraint store.

`chr_trace/0'
     Activate the CHR tracer.  By default the CHR tracer is activated
     and deactivated automatically by the Prolog predicates `trace/0'
     and `notrace/0'.

`chr_notrace/0'
     De-activate the CHR tracer.  By default the CHR tracer is
     activated and deactivated automatically by the Prolog predicates
     `trace/0' and `notrace/0'.

`chr_leash(+SPEC)'
     Define the set of CHR ports on which the CHR tracer asks for user
     intervention (i.e. stops). SPEC is either a list of ports as
     defined in *Note CHR Ports:: or a predefined alias.  Defined
     aliases are: `full' to stop at all ports, `none' or `off' to never
     stop, and `default' to stop at the `call', `exit', `fail', `wake'
     and `apply' ports.  See also `leash/1'.

`chr_flag(+FLAGNAME, ?OLDVALUE, ?NEWVALUE)'
     OLDVALUE is the value of the CHR flag FLAGNAME, and the new value
     of FLAGNAME is set to NEWVALUE.  The valid CHR flag are the
     following:

    `toplevel_show_store'
          If `on' (the default), the Prolog toplevel displays the
          constraint store at the end of each query. If `off', the
          toplevel does not display this.

    `generate_debug_info'
          Provides the default if the `debug' option is not given.  The
          valid values are `true' and `false' (the default).

    `optimize'
          Provides the default if the `optimize' option is not given.
          The valid values are `full' and `off' (the default).

`chr_show_store(+MOD)'
     Prints all suspended constraints of module MOD to the current
     output stream.



File: sicstus.info,  Node: CHR Examples,  Next: CHR Guidelines,  Prev: CHR Debugging,  Up: lib-chr

10.33.5 Examples
----------------

Here are two example constraint solvers written in CHR.

  1. The program below defines a solver with one constraint, `leq/2',
     which is a less-than-or-equal constraint, also known as a partial
     order constraint.

          :- module(leq,[leq/2]).
          :- use_module(library(chr)).

          :- chr_constraint leq/2.
          reflexivity   leq(X,X) <=> true.
          antisymmetry  leq(X,Y), leq(Y,X) <=> X = Y.
          idempotence   leq(X,Y) \ leq(X,Y) <=> true.
          transitivity  leq(X,Y), leq(Y,Z) ==> leq(X,Z).

     When the above program is loaded, you can call the `leq/2'
     constraint in a query, e.g.:

          | ?- leq(X,Y), leq(Y,Z).
          leq(X,Y),
          leq(X,Z),
          leq(Y,Z) ?

  2. The program below implements a simple finite domain constraint
     solver.

          :- module(dom,[dom/2]).
          :- use_module(library(chr)).
          :- use_module(library(sets), [intersection/3]).

          :- chr_constraint dom(?int,+list(int)).
          :- chr_type list(T) ---> [] ; [T|list(T)].

          dom(X,[]) <=> fail.
          dom(X,[Y]) <=> X = Y.
          dom(X,L) <=> nonvar(X) | memberchk(X,L).
          dom(X,L1), dom(X,L2) <=> intersection(L1,L2,L3), dom(X,L3).

     When the above program is loaded, you can call the `dom/2'
     constraint in a query, e.g.:

          | ?- dom(A,[1,2,3]), dom(A,[3,4,5]).
          A = 3

   Finally, Martin Keser's WebCHR package at
`http://bruckner.informatik.uni-ulm.de/webchr/' contains more than 40
example programs for SICStus 4, complete with documentation and example
queries.


File: sicstus.info,  Node: CHR Guidelines,  Prev: CHR Examples,  Up: lib-chr

10.33.6 Guidelines
------------------

In this subsection we cover several guidelines on how to use CHR to
write constraint solvers and how to do so efficiently.

Check guard bindings yourself.
     It is considered bad practice to write guards that bind variables
     of the head and to rely on the system to detect this at runtime.
     It is inefficient and obscures the working of the program.

Set semantics.
     The CHR system allows the presence of identical constraints, i.e.
     multiple constraints with the same functor, arity and arguments.
     For most constraint solvers, this is not desirable: it affects
     efficiency and possibly termination. Hence appropriate simpagation
     rules should be added of the form:

          CONSTRAINT \ CONSTRAINT <=> TRUE.

Multi-headed rules.
     Multi-headed rules are executed more efficiently when the
     constraints share one or more variables.

Mode and type declarations.
     Provide mode and type declarations to get more efficient program
     execution.

Compile once, run many times.
     Does consulting your CHR program take a long time? Probably it
     takes the CHR compiler a long time to compile the CHR rules into
     Prolog code. When you disable optimizations the CHR compiler will
     be a lot quicker, but you may lose performance.


File: sicstus.info,  Node: lib-clpfd,  Next: lib-clpqr,  Prev: lib-chr,  Up: The Prolog Library

10.34 Constraint Logic Programming over Finite Domains--`library(clpfd)'
========================================================================

* Menu:

* CLPFD Intro:: Introduction
* CLPFD Interface:: Solver Interface
* Available Constraints:: Available Constraints
* Enumeration Predicates:: Enumeration Predicates
* Statistics Predicates:: Statistics Predicates
* Answer Constraints:: Answer Constraints
* The Constraint System:: The Constraint System
* Defining Global Constraints:: Defining Global Constraints
* Defining Primitive Constraints:: Defining Primitive Constraints
* Example Programs:: Example Programs
* Syntax Summary:: Syntax Summary


File: sicstus.info,  Node: CLPFD Intro,  Next: CLPFD Interface,  Up: lib-clpfd

10.34.1 Introduction
--------------------

The clp(FD) solver described in this chapter is an instance of the
general Constraint Logic Programming scheme introduced in [Jaffar &
Michaylov 87].  This constraint domain is particularly useful for
modeling discrete optimization and verification problems such as
scheduling, planning, packing, timetabling etc.  The treatise [Van
Hentenryck 89] is an excellent exposition of the theoretical and
practical framework behind constraint solving in finite domains, and
summarizes the work up to 1989.

   This solver has the following highlights:

   * Two classes of constraints are handled internally: primitive
     constraints and global constraints.

   * The constraints described in this chapter are automatically
     translated to conjunctions of primitive and global library
     constraints.

   * The truth value of a primitive constraint can be reflected into a
     0/1-variable (reification).

   * New primitive constraints can be added by writing so-called
     indexicals.

   * New global constraints can be written in Prolog, by means of a
     programming interface.

   This library fully supports multiple SICStus run-times in a process.

* Menu:

* Referencing CLPFD:: Referencing this Software
* Acknowledgments CLPFD:: Acknowledgments

   The rest of this chapter is organized as follows: How to load the
solver and how to write simple programs is explained in *Note CLPFD
Interface::.  A description of all constraints that the solver provides
is contained in *Note Available Constraints::.  The predicates for
searching for solution are documented in *Note Enumeration Predicates::.
The predicates for getting execution statistics are documented in *Note
Statistics Predicates::.  A few example programs are given in *Note
Example Programs::.  Finally, *Note Syntax Summary:: contains syntax
rules for all expressions.

   The following sections discuss advanced features and are probably
only relevant to experienced users: How to control the amount of
information presented in answers to queries is explained in *Note
Answer Constraints::.  The solver's execution mechanism and primitives
are described in *Note The Constraint System::.  How to add new global
constraints via a programming interface is described in *Note Defining
Global Constraints::.  How to define new primitive constraints with
indexicals is described in *Note Defining Primitive Constraints::.


File: sicstus.info,  Node: Referencing CLPFD,  Next: Acknowledgments CLPFD,  Up: CLPFD Intro

10.34.1.1 Referencing this Software
...................................

When referring to this implementation of clp(FD) in publications,
please use the following reference:

     Carlsson M., Ottosson G., Carlson B.  `An Open-Ended Finite Domain
     Constraint Solver', Proc. Programming Languages: Implementations,
     Logics, and Programs, 1997.


File: sicstus.info,  Node: Acknowledgments CLPFD,  Prev: Referencing CLPFD,  Up: CLPFD Intro

10.34.1.2 Acknowledgments
.........................

The first version of this solver was written as part of Key
Hyckenberg's MSc thesis in 1995, with contributions from Greger
Ottosson at the Computing Science Department, Uppsala University.  The
code was later rewritten by Mats Carlsson with contributions by Nicolas
Beldiceanu.  Pe'ter Szeredi contributed material for this manual
chapter.

   The development of this software was supported by the Swedish
National Board for Technical and Industrial Development (NUTEK) under
the auspices of Advanced Software Technology (ASTEC) Center of
Competence at Uppsala University.

   We include a collection of examples, among which some have been
distributed with the INRIA implementation of clp(FD) [Diaz & Codognet
93].


File: sicstus.info,  Node: CLPFD Interface,  Next: Available Constraints,  Prev: CLPFD Intro,  Up: lib-clpfd

10.34.2 Solver Interface
------------------------

The solver contains predicates for checking the consistency and
entailment of finite domain constraints, as well as solving for solution
values for your problem variables.

   In the context of this constraint solver, a "finite domain" is a
subset of small integers, and a "finite domain constraint" denotes a
relation over a tuple of small integers.  Hence, only small integers
and unbound variables are allowed in finite domain constraints.

   All "domain variables", i.e. variables that occur as arguments to
finite domain constraints get associated with a finite domain, either
explicitly declared by the program, or implicitly imposed by the
constraint solver.  Temporarily, the domain of a variable may actually
be infinite, if it does not have a finite lower or upper bound.  If
during the computation a variable receives a new lower or upper bound
that cannot be represented as a small integer, an overflow condition is
issued.  This is expressed as silent failure or as a representation
error, subject to the `overflow' option of `fd_flag/3'.

   The domain of all variables gets smaller and smaller as more
constraints are added.  If a domain becomes empty, the accumulated
constraints are unsatisfiable, and the current computation branch fails.
At the end of a successful computation, all domains have usually become
singletons, i.e. the domain variables have become assigned.

   The domains do not become singletons automatically.  Usually, it
takes some amount of search to find an assignment that satisfies all
constraints.  It is the programmer's responsibility to do so.  If some
domain variables are left unassigned in a computation, the garbage
collector will preserve all constraint data that is attached to them.

   *Please note*: if a term containing domain variables is copied,
asserted, collected as a solution to `findall/3' and friends, or raised
as an exception, those domain variables will be replaced by brand new
variables in the copy.  To retain the domain variables and any attached
constraints, you can use `copy_term/3' (*note ref-lte-cpt::).

   The heart of the constraint solver is a scheduler for indexicals [Van
Hentenryck et al. 92] and global constraints.  Both entities act as
coroutines performing incremental constraint solving or entailment
checking.  They wake up by changes in the domains of its arguments.
All constraints provided by this package are implemented as indexicals
or global constraints.  New constraints can be defined by the user.

   Indexicals are reactive functional rules, which take part in the
solver's basic constraint solving algorithm, whereas each global
constraint is associated with its particular constraint solving
algorithm.  The solver maintains two scheduling queues, giving priority
to the queue of indexicals.

   The feasibility of integrating the indexical approach with a Prolog
based on the WAM was clearly demonstrated by Diaz's clp(FD)
implementation [Diaz & Codognet 93], one of the fastest finite domains
solvers around.

* Menu:

* Posting Constraints:: Posting Constraints
* A Constraint Satisfaction Problem:: A Constraint Satisfaction Problem
* Reified Constraints:: Reified Constraints


File: sicstus.info,  Node: Posting Constraints,  Next: A Constraint Satisfaction Problem,  Up: CLPFD Interface

10.34.2.1 Posting Constraints
.............................

A constraint is called as any other Prolog predicate.  When called, the
constraint is "posted" to the store.  For example:

     | ?- X in 1..5, Y in 2..8, X+Y #= T.
     X in 1..5,
     Y in 2..8,
     T in 3..13

     | ?- X in 1..5, T in 3..13, X+Y #= T.
     X in 1..5,
     T in 3..13,
     Y in -2..12

   Note that the answer constraint shows the domains of nonground query
variables, but not any constraints that may be attached to them.


File: sicstus.info,  Node: A Constraint Satisfaction Problem,  Next: Reified Constraints,  Prev: Posting Constraints,  Up: CLPFD Interface

10.34.2.2 A Constraint Satisfaction Problem
...........................................

Constraint satisfaction problems (CSPs) are a major class of problems
for which this solver is ideally suited.  In a CSP, the goal is to pick
values from pre-defined domains for certain variables so that the given
constraints on the variables are all satisfied.

   As a simple CSP example, let us consider the Send More Money puzzle.
In this problem, the variables are the letters S, E, N, D, M, O, R,
and Y.  Each letter represents a digit between 0 and 9.  The problem is
to assign a value to each digit, such that SEND + MORE equals MONEY.

   A program that solves the puzzle is given below.  The program
contains the typical three steps of a clp(FD) program:

  1. declare the domains of the variables

  2. post the problem constraints

  3. look for a feasible solution via backtrack search, or look for an
     optimal solution via branch-and-bound search

   Sometimes, an extra step precedes the search for a solution: the
posting of surrogate constraints to break symmetries or to otherwise
help prune the search space.  No surrogate constraints are used in this
example.

   The domains of this puzzle are stated via the `domain/3' goal and by
requiring that S and M be greater than zero.  The two problem
constraint of this puzzle are the equation (`sum/8') and the constraint
that all letters take distinct values (`all_different/1').  Finally,
the backtrack search is performed by `labeling/2'.  Different search
strategies can be encoded in the `Type' parameter.  In the example
query, the default search strategy is used (select the leftmost
variable, try values in ascending order).

     :- use_module(library(clpfd)).

     mm([S,E,N,D,M,O,R,Y], Type) :-
          domain([S,E,N,D,M,O,R,Y], 0, 9),      % step 1
          S#>0, M#>0,
          all_different([S,E,N,D,M,O,R,Y]),     % step 2
          sum(S,E,N,D,M,O,R,Y),
          labeling(Type, [S,E,N,D,M,O,R,Y]).    % step 3

     sum(S, E, N, D, M, O, R, Y) :-
                       1000*S + 100*E + 10*N + D
          +            1000*M + 100*O + 10*R + E
          #= 10000*M + 1000*O + 100*N + 10*E + Y.

     | ?- mm([S,E,N,D,M,O,R,Y], []).
     D = 7,
     E = 5,
     M = 1,
     N = 6,
     O = 0,
     R = 8,
     S = 9,
     Y = 2


File: sicstus.info,  Node: Reified Constraints,  Prev: A Constraint Satisfaction Problem,  Up: CLPFD Interface

10.34.2.3 Reified Constraints
.............................

Instead of merely posting constraints it is often useful to reflect its
truth value into a 0/1-variable B, so that:

   * the constraint is posted if B is set to 1

   * the negation of the constraint is posted if B is set to 0

   * B is set to 1 if the constraint becomes entailed

   * B is set to 0 if the constraint becomes disentailed

   This mechanism is known as "reification".  Several frequently used
operations can be defined in terms of reified constraints, such as
blocking implication [Saraswat 90] and the cardinality operator [Van
Hentenryck & Deville 91], to name a few.  A reified constraint is
written:

     | ?- CONSTRAINT #<=> B.

where CONSTRAINT is reifiable.  As an example of a constraint that uses
reification, consider `exactly(X,L,N)', which is true if X occurs
exactly N times in the list L.  It can be defined thus:

     exactly(_, [], 0).
     exactly(X, [Y|L], N) :-
         X #= Y #<=> B,
         N #= M+B,
         exactly(X, L, M).


File: sicstus.info,  Node: Available Constraints,  Next: Enumeration Predicates,  Prev: CLPFD Interface,  Up: lib-clpfd

10.34.3 Available Constraints
-----------------------------

This section describes the classes of constraints that can be used with
this solver.

* Menu:

* Arithmetic Constraints:: Arithmetic Constraints
* Membership Constraints:: Membership Constraints
* Propositional Constraints:: Propositional Constraints
* Combinatorial Constraints:: Combinatorial Constraints
* User-Defined Constraints:: User-Defined Constraints


File: sicstus.info,  Node: Arithmetic Constraints,  Next: Membership Constraints,  Up: Available Constraints

10.34.3.1 Arithmetic Constraints
................................

`?EXPR RELOP ?EXPR'
     defines an arithmetic constraint.  The syntax for EXPR and RELOP
     is defined by a grammar (*note Syntax of Arithmetic
     Expressions::).  Note that the expressions are not restricted to
     being linear.  Constraints over non-linear expressions, however,
     will usually yield less constraint propagation than constraints
     over linear expressions.

     Arithmetic constraints can be reified as e.g.:

          | ?- X in 1..2, Y in 3..5, X#=<Y #<=> B.
          B = 1,
          X in 1..2,
          Y in 3..5

Linear arithmetic constraints, except equalities, maintain
bound-consistency and their reified versions detect bound-entailment
and -disentailment; *note The Constraint System::.

   The following constraints are among the library constraints that
general arithmetic constraints compile to.  They express a relation
between a sum or a scalar product and a value, using a dedicated
algorithm, which avoids creating any temporary variables holding
intermediate values.  If you are computing a sum or a scalar product, it
can be much more efficient to compute lists of coefficients and
variables and post a single sum or scalar product constraint than to
post a sequence of elementary constraints.

`sum(+XS, +RELOP, ?VALUE)'
     where XS is a list of integers or domain variables, RELOP is a
     relational symbol as above, and VALUE is an integer or a domain
     variable.  True if `sum(XS) RELOP VALUE'.  Cannot be reified.
     Corresponds roughly to `sumlist/2' in `library(lists)'.

`scalar_product(+COEFFS, +XS, +RELOP, ?VALUE)'
`scalar_product(+COEFFS, +XS, +RELOP, ?VALUE, +OPTIONS)'
     where COEFFS is a list of length N of integers, XS is a list of
     length N of integers or domain variables, RELOP is a relational
     symbol as above, and VALUE is an integer or a domain variable.
     True if `sum(COEFFS*XS) RELOP VALUE'.  Cannot be reified.

     OPTIONS is a list that may include the following option.  It can
     be used to control the level of consistency used by the constraint.

    `consistency(CONS)'
          The value is one of the following:
         `domain'
               The constraint will maintain arc-consistency.  *Please
               note*: This option is only meaningful if RELOP is `#=',
               and requires that any domain variables have finite
               bounds.

         `bound'
         `value'
               The constraint will try to maintain bound-consistency
               (the default).

   The following constraints constrain a value to be the minimum
(maximum) of a given list of values.

`minimum(?VALUE, +XS)'
     where XS is a list of integers or domain variables, and VALUE is
     an integer or a domain variable.  True if VALUE is the minimum of
     XS.  Cannot be reified.  Corresponds to `min_member/2' in
     `library(lists)'.

`maximum(?VALUE, +XS)'
     where XS is a list of integers or domain variables, and VALUE is
     an integer or a domain variable.  True if VALUE is the maximum of
     XS.  Cannot be reified.  Corresponds to `max_member/2' in
     `library(lists)'.


File: sicstus.info,  Node: Membership Constraints,  Next: Propositional Constraints,  Prev: Arithmetic Constraints,  Up: Available Constraints

10.34.3.2 Membership Constraints
................................

`domain(+VARIABLES, +MIN, +MAX)'
     where VARIABLES is a list of domain variables or integers, MIN is
     an integer or the atom `inf' (minus infinity), and MAX is an
     integer or the atom `sup' (plus infinity).  True if the variables
     all are elements of the range `MIN..MAX'.  Cannot be reified.

`?X in +RANGE'
     defines a membership constraint.  X is an integer or a domain
     variable and RANGE is a CONSTANTRANGE (*note Syntax of
     Indexicals::).  True if X is an element of the range.

`?X in_set +FDSET'
     defines a membership constraint.  X is an integer or a domain
     variable and FDSET is an FD set term (*note FD Set Operations::).
     True if X is an element of the FD set.

   `in/2' and `in_set/2' constraints can be reified.  They maintain
arc-consistency and their reified versions detect arc-entailment and
-disentailment; *note The Constraint System::.


File: sicstus.info,  Node: Propositional Constraints,  Next: Combinatorial Constraints,  Prev: Membership Constraints,  Up: Available Constraints

10.34.3.3 Propositional Constraints
...................................

Propositional combinators can be used to combine reifiable constraints
into propositional formulae over such constraints.  Such formulae are
goal expanded by the system into sequences of reified constraints and
arithmetic constraints.  For example,

     X #= 4 #\/ Y #= 6

expresses the disjunction of two equality constraints.

   The leaves of propositional formulae can be reifiable constraints,
the constants 0 and 1, or 0/1-variables.  New primitive, reifiable
constraints can be defined with indexicals as described in *Note
Defining Primitive Constraints::.  The following propositional
combinators are available:

`#\ :Q'
     True if the constraint Q is false.

`:P #/\ :Q'
     True if the constraints P and Q are both true.

`:P #\ :Q'
     True if exactly one of the constraints P and Q is true.

`:P #\/ :Q'
     True if at least one of the constraints P and Q is true.

`:P #=> :Q'
`:Q #<= :P'
     True if the constraint Q is true or the constraint P is false.

`:P #<=> :Q'
     True if the constraints P and Q are both true or both false.

   Note that the reification scheme introduced in *Note Reified
Constraints:: is a special case of a propositional constraint.

