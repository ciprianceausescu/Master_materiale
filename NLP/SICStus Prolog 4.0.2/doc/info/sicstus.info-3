This is info/sicstus.info, produced by makeinfo version 4.8 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 6 November 2007.


File: sicstus.info,  Node: Breakpoint Conditions,  Next: Consult,  Prev: Breakpoint Processing,  Up: Debug Intro

5.9 Breakpoint Conditions
=========================

This section describes the format of simple breakpoint conditions.  We
first list the tests that can be used to enquire the state of
execution. We then proceed to describe the conditions usable in the
action part and the options for focusing on past execution states.
Finally, we describe condition macros and the format of the values of
the debugger action variables.

   We distinguish between two kinds of tests, based on whether they
refer to information stored in the backtrace or not. The latter
category, the "non-backtraced tests", contains the conditions related
to the current port (`port', `bid', `mode', `show', `command', `get')
and the breakpoint type selection conditions (`advice' and `debug').
All remaining tests refer to information stored in the backtrace.

   Non-backtraced tests will raise an exception, if they appear in
calls to `execution_state/1' from outside the debugger, or in queries
about past execution state, in `execution_state/2'.

   Backtraced tests are allowed both inside and outside the debugger.
However such tests can fail if the given query is not meaningful in the
given context, e.g. if `execution_state(goal(G))' is queried before any
breakpoints were encountered.

   Note that if a test is used in the second argument of
`execution_state/2', the term _current_, in the following descriptions,
should be interpreted as referring to the execution state focused on
(described by the first argument of `execution_state/2').

* Menu:

* Goal Tests:: Tests Related to the Current Goal
* Source Tests:: Tests Related to Source Information
* Port Tests:: Tests Related to the Current Port
* Break Tests:: Tests Related to the Break Level
* Other Tests:: Other Conditions
* Action Conditions:: Conditions Usable in the Action Part
* Past States:: Options for Focusing on a Past State
* Condition Macros:: Condition Macros
* Action Variables:: The Action Variables


File: sicstus.info,  Node: Goal Tests,  Next: Source Tests,  Up: Breakpoint Conditions

5.9.1 Tests Related to the Current Goal
---------------------------------------

The following tests give access to basic information about the current
invocation.

`inv(INV)'
     The invocation number of the current goal is INV. Invocation
     numbers start from 1.

`depth(DEPTH)'
     The current execution depth is DEPTH.

`goal(MGOAL)'
     The current goal is an instance of the module name expanded MGOAL
     template. The current goal and MGOAL are unified. This condition
     is equivalent to  the `subsumes(MGOAL,CURRENTGOAL)' test
     (`subsumes/2' is defined in `library(terms)', *note lib-terms::).

`pred(MFUNC)'
     The module name expanded MFUNC template matches (see notes below)
     the functor (M`:'F`/'N) of the current goal.  The unification
     required for matching is carried out.

`module(MODULE)'
     The  current goal is invoked from module MODULE. For compiled
     calls to built-in predicates MODULE will always be `prolog'.

`goal_private(GOALPRIV)'
     The private information associated with the current goal is
     GOALPRIV. This is initialized to an unbound variable at the Call
     port. It is strongly recommended that GOALPRIV be used as an open
     ended list, *note Storing User Information in the Backtrace::.

`exited(BOOLEAN)'
     BOOLEAN is `true' if the current invocation has exited, and
     `false' otherwise. This condition is mainly used for looking at
     past execution states.

`parent_inv(INV)'
     The invocation number of the _debugger-parent_ (see notes below) of
     the current goal is INV.

`ancestor(ANCGOAL,INV)'
     The youngest debugger-ancestor of the current goal, which is an
     instance of the module name expanded ANCGOAL template, is at
     invocation number INV. The unification required for matching is
     carried out.

   Notes:

   The "debugger-parent" of a goal is the youngest ancestor of the goal
present on the backtrace.  This will differ from the ordinary parent if
not all goals are traced, e.g. if the goal in question is reached in
zip mode.  A "debugger-ancestor" of a goal is any of its ancestors on
the backtrace.

   In the `goal' and `ancestor' tests above, there is a given module
qualified goal template, say MODT`:'GOALT, and it is matched against a
concrete goal term MOD`:'GOAL in the execution state.  This matching is
carried out as follows:

  a. It is checked that GOAL is an instance of GOALT.

  b. GOAL and GOALT are unified.

  c. It is checked that MOD and MODT are either unifiable (and are
     unified), or name such modules in which GOAL has the same meaning,
     i.e. either one of MOD`:'GOAL and MODT`:'GOAL is an exported
     variant of the other, or both are imported from the same module.

   Similar matching rules apply for predicate functors, in the `pred'
condition. In this test the argument holds a module qualified functor
template, say MODT`:'NAME`/'ARITY, and this is matched against a
concrete goal term MOD`:'GOAL in the execution state.

  a. It is checked that the functor of GOAL unifies with NAME`/'ARITY,
     and this unification is carried out.

  b. It is checked that MOD and MODT are either unifiable (and are
     unified), or name such modules in which GOAL has the same meaning.


File: sicstus.info,  Node: Source Tests,  Next: Port Tests,  Prev: Goal Tests,  Up: Breakpoint Conditions

5.9.2 Tests Related to Source Information
-----------------------------------------

These tests provide access to source related information.  The `file'
and `line' tests will fail if no source information is present. The
`parent_clause' and `parent_pred' tests are available for interpreted
code only, they will fail in compiled code.

`file(FILE)'
     The current goal is invoked from a file whose absolute name is
     FILE.

`line(FILE,LINE)'
     The current goal is invoked from line LINE, from within a file
     whose absolute name is FILE.

`line(LINE)'
     The current goal is invoked from line LINE.

`parent_clause(CL)'
     The current goal is invoked from clause CL.

`parent_clause(CL,SEL)'
     The current goal is invoked from clause CL and within its body it
     is pointed to by the subterm selector SEL.

`parent_clause(CL,SEL,I)'
     The current goal is invoked from clause CL, it is pointed to by
     the subterm selector SEL within its body, and it is the Ith goal
     within it. The goals in the body are counted following their
     textual occurrence.

`parent_pred(PRED)'
     The current goal is invoked from predicate PRED.

`parent_pred(PRED,N)'
     The current goal is invoked from predicate PRED, clause number N.

   The `parent_pred' tests match their first argument against the
functor of the parent predicate in the same way as the `pred' test
does, see the notes in the previous section (*Note Goal Tests::).


File: sicstus.info,  Node: Port Tests,  Next: Break Tests,  Prev: Source Tests,  Up: Breakpoint Conditions

5.9.3 Tests Related to the Current Port
---------------------------------------

These tests can only be used inside the debugger and only when focused
on the current invocation.  If they appear in `execution_state/2' or in
`execution_state/1' called from outside the debugger, an exception will
be raised.

   The notion of port in breakpoint handling is more general than
outlined earlier in *Note Procedure Box::. Here, the following terms
are used to describe a port: 

     call, exit(nondet), exit(det), redo, fail,
     exception(EXCEPTION), block, unblock

   Furthermore, the atoms `exit' and `exception' can be used in the
`port' condition (see below), to denote either of the two exit ports
and an arbitrary exception port, respectively.

`port(PORT)'
     The current execution port matches PORT in the following sense:
     either PORT and the current port unify, or PORT is the functor of
     the current port (e.g.  `port(exit)' holds for both `exit(det)' and
     `exit(nondet)' ports).

     As explained earlier, the port condition for a non Call port is
     best placed in the action part.  This is because the failure of
     the action part will cause the debugger to pass through the Call
     port silently, and to build a procedure box, even in zip mode. The
     following idiom is suggested for creating breakpoints at non Call
     ports:

          add_breakpoint(TESTS-[port(PORT),ACTIONS], BID).

`bid(BID)'
     The breakpoint being examined has a breakpoint identifier BID.
     (BID = `none' if no breakpoint was selected.)

`mode(MODE)'
     MODE is the value of the `mode' variable, which normally reflects
     the current debugger mode.

`command(COMMAND)'
     COMMAND is the value of the `command' variable, which is the
     command to be executed by default, if the breakpoint is selected.

`show(SHOW)'
     SHOW is the value of the `show' variable, i.e. the default show
     method (the method for displaying the goal in the trace message).

   The last three of the above tests access the _debugger action
variables_. These breakpoint conditions have a different meaning in the
action part. For example, the condition `mode(trace)', if it occurs in
the tests, _checks_ if the current debugger mode is `trace'. On the
other hand, if the same term occurs within the action part, it _sets_
the debugger mode to `trace'.

   To support the querying of the action variables in the action part,
the following breakpoint condition is provided:

`get(ACTVAR)'
     Equivalent to ACTVAR, where this is an action variable test, i.e.
     one of the terms `mode(MODE)', `command(COMMAND)', `show(SHOW)'.
     It has this meaning in the action part as well.

   For the `port', `mode', `command' and `show' conditions, the
condition can be replaced by its argument, if that is not a variable.
For example the condition `call' can be used instead of `port(call)'.
Conditions matching the terms listed above as valid port values will be
converted to a `port' condition. Similarly, any valid value for the
three debugger action variables is converted to an appropriate
condition. These valid values are described in *Note Action Variables::.


File: sicstus.info,  Node: Break Tests,  Next: Other Tests,  Prev: Port Tests,  Up: Breakpoint Conditions

5.9.4 Tests Related to the Break Level
--------------------------------------

These tests can be used both inside and outside the condition evaluation
process, and also can be used in queries about past break levels.

`break_level(N)'
     We are at (or focused on) break level N (N = 0 for the outermost
     break level).

`max_inv(MAXINV)'
     The last invocation number used within the current break level is
     MAXINV. Note that this invocation number may not be present in the
     backtrace (because the corresponding call exited determinately).

`private(PRIV)'
     The private information associated with the break level is PRIV.
     Similarly to `goal_private/1', this condition refers initially to
     an unbound variable and can be used to store an arbitrary Prolog
     term. However, it is strongly recommended that PRIV be used as an
     open ended list, *note Storing User Information in the Backtrace::.



File: sicstus.info,  Node: Other Tests,  Next: Action Conditions,  Prev: Break Tests,  Up: Breakpoint Conditions

5.9.5 Other Conditions
----------------------

The following conditions are for prescribing or checking the breakpoint
type.  They cause an exception if used outside the debugger or in
`execution_state/2'.

`advice'
     The breakpoint in question is of advice type.

`debugger'
     The breakpoint in question is of debugger type.

   The following construct converts an arbitrary Prolog goal into a
condition.

`true(COND)'
     The Prolog goal COND is true, i.e. `once(COND)' is executed and
     the condition is satisfied if and only if this completes
     successfully.  If an exception is raised during execution, an error
     message is printed and the condition fails.

     The substitutions done on executing COND are carried out.  COND is
     subject to module name expansion. If used in the test part of
     spypoint conditions, the goal should not have any side-effects, as
     the test part may be evaluated several times.

   The following conditions represent the Boolean constants.

`true'

`[]'
     A condition that is always true. Useful e.g. in conditionals.

`false'
     A condition that is always false.


File: sicstus.info,  Node: Action Conditions,  Next: Past States,  Prev: Other Tests,  Up: Breakpoint Conditions

5.9.6 Conditions Usable in the Action Part
------------------------------------------

The meaning of the following conditions, if they appear  in the action
part, is different from their meaning in the test part.

`mode(MODE)'
     Set the debugger mode to MODE.

`command(COMMAND)'
     Set the command to be executed to COMMAND.

`show(SHOW)'
     Set the show method to SHOW.

   The values admissible for MODE, COMMAND and SHOW are described in
*Note Action Variables::.

   Furthermore, any other condition can be used in the action part,
except for the ones specifying the breakpoint type (`advice' and
`debugger'). Specifically, the `get' condition can be used to access
the value of an action variable.


File: sicstus.info,  Node: Past States,  Next: Condition Macros,  Prev: Action Conditions,  Up: Breakpoint Conditions

5.9.7 Options for Focusing on a Past State
------------------------------------------

The following ground terms can be used in the first argument of
`execution_state/2' (*note Breakpoint Predicates::). Alternatively, a
list containing such terms can be used. If a given condition occurs
multiple times, only the last one is considered. The order of
conditions within the list does not matter.

`break_level(BL)'
     Focus on the current invocation of break level BL. BL is the break
     level number, the top-level being `break_level(0)'.  For past
     break levels, the current invocation is the one from which the
     next break level was entered.

`inv(INV)'
     Focus on the invocation number INV of the currently focused break
     level.


File: sicstus.info,  Node: Condition Macros,  Next: Action Variables,  Prev: Past States,  Up: Breakpoint Conditions

5.9.8 Condition Macros
----------------------

There are a few condition macros expanding to a list of other
conditions:

`unleash'
     Expands to `[show(print),command(proceed)]'

`hide'
     Expands to `[show(silent),command(proceed)]'

`leash'
     Expands to `[show(print),command(ask)]'

   The user can also define condition macros using the hook predicate
below.

`breakpoint_expansion(+MACRO, -BODY)  "hook,development"'
`user:breakpoint_expansion(+MACRO, -BODY)'
     This predicate is called with each (non-composite) breakpoint test
     or action, as its first argument. If it succeeds, the term
     returned in the second argument (`Body') is substituted for the
     original condition. The expansion is done at the time the
     breakpoint is added.

     Note that BODY can be composite, but it cannot be of form
     `TESTS-ACTIONS'. This means that the whole BODY will be
     interpreted as being in either the test or the action part,
     depending on the context.

     The built-in breakpoint conditions can not be redefined using this
     predicate.


File: sicstus.info,  Node: Action Variables,  Prev: Condition Macros,  Up: Breakpoint Conditions

5.9.9 The Action Variables
--------------------------

In this section we list the possible values of the debugger action
variables, and their meaning.

   Note that the Prolog terms, supplied as values, are copied when a
variable is set. This is relevant primarily in the case of the
`proceed/2' and `flit/2' values.

   Values allowed in the `show' condition:

`print'
     Write using options stored in the `debugger_print_options' Prolog
     flag.  

`silent'
     Display nothing.

`display'
     Write using `display'.

`write'
     Write using `writeq'.

`write_term(OPTIONS)'
     Write using options OPTIONS.

`METHOD-SEL'
     Display only the subterm selected by SEL, using METHOD. Here,
     METHOD is one of the methods above, and SEL is a subterm selector.

   Values allowed in the `command' condition:

`ask'
     Ask the user what to do next.

`proceed'
     Continue the execution without interacting with the user (cf.
     unleashing).

`flit'
     Continue the execution without building a procedure box for the
     current goal (and consequently not encountering any other ports
     for this invocation).  Only meaningful at Call ports, at other
     ports it is equivalent to `proceed'.

`proceed(GOAL,NEW)'
     Unless at call port, first go back to the call port (retry the
     current invocation, see the `retry(INV)' command value below).
     Next, unify the current goal with GOAL and execute the goal NEW in
     its place. Create (or keep) a procedure box for the current goal.

     This construct is used by the `u' (unify) interactive debugger
     command.

     Both the GOAL and NEW arguments are module name expanded when the
     breakpoint is added: the module of GOAL defaults to the module of
     the current goal, while that of NEW to the module name of the
     breakpoint spec. If the command value is created during run time,
     the module name of both arguments defaults to the module of the
     current goal.

     The term `proceed(GOAL,NEW)' will be copied when the `command'
     action variable is set. Therefore breakpoint specs of form
          Tests - [goal(foo(X)),...,proceed(_,bar(X))]

     should be avoided, and

          Tests - [goal(foo(X)),...,proceed(foo(Y),bar(Y))
     should be used instead. The first variant will not work as
     expected if `X' is non-ground, as the variables in the `bar/1'
     call will be detached from the original ones in `foo/1'. Even if
     `X' is ground, the first variant may be much less efficient, as it
     will copy the possibly huge term `X'.

`flit(GOAL,NEW)'
     Same as `proceed(GOAL,NEW)', but do not create (or discard) a
     procedure box for the current goal. (Consequently no other ports
     will be encountered for this invocation.)

     Notes for `proceed/2', on module name expansion and copying, also
     apply to `flit/2'.

`exception(E)'
     Raise the exception E.

`abort'
     Abort the execution.

`retry(INV)'
     Retry the most recent goal in the backtrace with an invocation
     number less or equal to INV (go back to the Call port of the
     goal). This is used by the interactive debugger command `r',
     retry; *note Debug Commands::.

`reexit(INV)'
     Re-exit the invocation with number INV (go back to the Exit port
     of the goal).  INV must be an exact reference to an exited
     invocation present in the backtrace (exited nondeterminately, or
     currently being exited). This is used by the interactive debugger
     command `je', jump to Exit port; *note Debug Commands::.

`redo(INV)'
     Redo the invocation with number INV (go back to the Redo port of
     the goal).  INV must be an exact reference to an exited invocation
     present in the backtrace. This is used by the interactive debugger
     command `jr', jump to Redo port; *note Debug Commands::.

`fail(INV)'
     Fail the most recent goal in the backtrace with an invocation
     number less or equal to INV (transfer control back to the Fail
     port of the goal). This is used by the interactive debugger
     command `f', fail; *note Debug Commands::.

   Values allowed in the `mode' condition:

`qskip(INV)'
     Quasi-skip until the first port with invocation number less or
     equal to INV is reached.  Having reached that point, `mode' is set
     to `trace'. Valid only if \Inv \geq 1 and furthermore \Inv \leq
     \CurrInv for entry ports (Call, Redo), and \Inv < \CurrInv for all
     other ports, where CURRINV is the invocation number of the current
     port.

`skip(INV)'
     Skip until the first port with invocation number less or equal to
     INV is reached, and set `mode' to `trace' there.  INV should obey
     the same rules as for `qskip'.

`trace'
     Creep.

`debug'
     Leap.

`zip'
     Zip.

`off'
     Continue without debugging.


File: sicstus.info,  Node: Consult,  Next: Exceptions Debug,  Prev: Breakpoint Conditions,  Up: Debug Intro

5.10 Consulting during Debugging
================================

It is possible, and sometimes useful, to consult a file whilst in the
middle of program execution.  Predicates that have been successfully
executed and are subsequently redefined by a consult and are later
reactivated by backtracking, will not notice the change of their
definitions.  In other words, it is as if every predicate, when called,
creates a copy of its definition for backtracking purposes.


File: sicstus.info,  Node: Exceptions Debug,  Next: Debug Summary,  Prev: Consult,  Up: Debug Intro

5.11 Catching Exceptions
========================

Usually, exceptions that occur during debugging sessions are displayed
only in trace mode and for invocation boxes for predicates with
spypoints on them, and not during skips.  However, it is sometimes
useful to make exceptions trap to the debugger at the earliest
opportunity instead.  The hook predicate `user:error_exception/1'
provides such a possibility:

`error_exception(+EXCEPTION)  "hook"'
`user:error_exception(+EXCEPTION)'
     This predicate is called at all Exception ports.  If it succeeds,
     the debugger enters trace mode and prints an exception port
     message.  Otherwise, the debugger mode is unchanged and a message
     is printed only in trace mode or if a spypoint is reached, and not
     during skips.

   Note that this hook takes effect when the debugger arrives at an
Exception port. For this to happen, procedure boxes have to be built,
e.g. by running (the relevant parts of) the program in debug mode.


File: sicstus.info,  Node: Debug Summary,  Prev: Exceptions Debug,  Up: Debug Intro

5.12 Predicate Summary
======================

`add_breakpoint(+CONDITIONS, -BID)  "development"'
     Creates a breakpoint with CONDITIONS and with identifier BID.

`user:breakpoint_expansion(+MACRO, -BODY)  "hook,development"'
     defines debugger condition macros

`current_breakpoint(?CONDITIONS, ?BID, ?STATUS, ?KIND, ?TYPE)  "development"'
     There is a breakpoint with conditions CONDITIONS, identifier BID,
     enabledness STATUS, kind KIND, and type TYPE.

`debug  "development"'
     switch on debugging

`user:debugger_command_hook(+DCOMMAND,-ACTIONS)  "hook,development"'
     Allows the interactive debugger to be extended with user-defined
     commands.

`debugging  "development"'
     display debugging status information

`disable_breakpoints(+BIDS)  "development"'
     Disables the breakpoints specified by BIDS.

`enable_breakpoints(+BIDS)  "development"'
     Enables the breakpoints specified by BIDS.

`user:error_exception(+EXCEPTION)  "hook"'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

`execution_state(+TESTS)  "development"'
     TESTS are satisfied in the current state of the execution.

`execution_state(+FOCUSCONDITIONS, +TESTS)  "development"'
     TESTS are satisfied in the state of the execution pointed to by
     FOCUSCONDITIONS.

`leash(+M)  "development"'
     set the debugger's leashing mode to M

`nodebug  "development"'
     switch off debugging

`nospy(:P)  "development"'
     remove spypoints from the procedure(s) specified by P

`nospyall  "development"'
     remove all spypoints

`notrace  "development"'
     switch off debugging (same as `nodebug/0')

`nozip  "development"'
     switch off debugging (same as `nodebug/0')

`profile_data(:SPEC,?SELECTION,?RESOLUTION,?DATA)  "development"'
     DATA is the profiling data collected from the instrumented
     predicates covered by SPEC with selection and resolution SELECTION
     and RESOLUTION respectively.

`profile_reset(:SPEC)  "development"'
     The profiling counters for the instrumented predicates covered by
     SPEC are zeroed.

`remove_breakpoints(+BIDS)  "development"'
     Removes the breakpoints specified by BIDS.

`spy(:P)  "development"'
`spy(:P,:C)'
     set spypoints on the procedure(s) specified by P with conditions C

`trace  "development"'
     switch on debugging and start tracing immediately

`unknown(-O,+N)  "development"'
     Changes action on undefined predicates from O to N.

`user:unknown_predicate_handler(+G,+M,-N)  "hook"'
     handle for unknown predicates.

`zip  "development"'
     switch on debugging in zip mode



File: sicstus.info,  Node: Mixing C and Prolog,  Next: Interfacing .NET and Java,  Prev: Debug Intro,  Up: Top

6 Mixing C/C++ and Prolog
*************************

SICStus Prolog provides a bi-directional, procedural interface for
program parts written in C and Prolog.  The C side of the interface
defines a number of functions and macros for various operations.  On
the Prolog side, you have to supply declarations specifying the names
and argument/value types of C functions being called as predicates.
These declarations are used by the predicate `load_foreign_resource/1',
which performs the actual binding of C functions to predicates.

   In most cases, the argument/value type declarations suffice for
making the necessary conversions of data automatically as they are
passed between C and Prolog.  However, it is possible to declare the
type of an argument to be a Prolog term, in which case the receiving
function will see it as a "handle" object, called an "SP_term_ref", for
which access functions are provided.

   The C support routines are available in a development system as well
as in runtime systems.  The support routines include:

   * Static and dynamic linking of C code into the Prolog environment.

   * Automatic conversion between Prolog terms and C data with
     `foreign/[2,3]' declarations.

   * Functions for accessing and creating Prolog terms, and for
     creating and manipulating SP_term_refs.

   * The Prolog system may call C predicates, which may call Prolog
     back without limits on recursion. Predicates that call C may be
     defined dynamically from C.

   * Support for creating stand-alone executables.

   * Support for creating user defined Prolog streams.

   * Functions to read and write on Prolog streams from C.

   * Functions to install interrupt handlers that can safely call
     Prolog.

   * Functions for manipulating mutual exclusion locks.

   * User hooks that can be used to perform user defined actions e.g.
     for customizing the memory management bottom layer.


   In addition to the interface described in this chapter,
`library(structs)' and `library(objects)' (see *Note lib-structs:: and
*Note lib-objects::) allow Prolog to hold pointers to C data structures
and arrays and access and store into fields in those data structures in
a very efficient way, allowing the programmer to stay completely inside
Prolog.

* Menu:

* CPL Notes:: Notes
* Calling C from Prolog:: Calling C from Prolog
* Calling C++ from Prolog:: Calling C++ from Prolog
* Support Functions:: Support Functions
* Calling Prolog from C:: Calling Prolog from C
* SICStus Streams:: SICStus Streams
* Stand-Alone Executables:: Stand-Alone Executables
* Mixing Examples:: Examples


File: sicstus.info,  Node: CPL Notes,  Next: Calling C from Prolog,  Up: Mixing C and Prolog

6.1 Notes
=========

_The SP_PATH variable_
     It is normally not necessary to set this environment variable, but
     its value will be used, as a fall-back, at runtime if no explicit
     boot path is given when initializing a runtime or development
     system.  In this chapter, the environment variable `SP_PATH' is
     used as a shorthand for the SICStus Prolog installation directory,
     whose default location for SICStus 4.0.2 is
     `/usr/local/lib/sicstus-4.0.2') for UNIX and `C:\Program
     Files\SICStus Prolog 4.0.2' for Windows.  *Note too-sicstus::.

          *Windows note*: Explicit use of the `SP_PATH' variable is
          discouraged, since Windows applications can find out for
          themselves where they were started from.  `SP_PATH' is only
          used if the directory where `sprt4-0-2.dll' is loaded from
          does not contain `sp-4.0.2' (a directory), `sprt.sav', or
          `spre.sav'.  If `SP_PATH' is used, SICStus expects it to be
          set such that `%SP_PATH%\bin' contains `sprt.sav' or
          `spre.sav'.  *Note Runtime Systems on Target Machines::.

_Definitions and declarations_
     Type definitions and function declarations for the interface are
     found in the header file `<sicstus/sicstus.h>'.

_Error Codes_
     The value of many support functions is a return code, namely:
     `SP_SUCCESS' for success, `SP_FAILURE' for failure, `SP_ERROR' if
     an error condition occurred, or if an uncaught exception was
     raised during a call from C to Prolog.  If the value is
     `SP_ERROR', the macro `SP_errno' will return a value describing
     the error condition:

          int SP_errno

     The function `SP_error_message()' returns a pointer to the
     diagnostic message corresponding to a specified error number.

_Wide Characters_
     The foreign interface supports wide characters. Whenever a
     sequence of possibly wide character codes is to be passed to or
     from a C function it is encoded as a sequence of bytes, using the
     UTF-8 encoding.  Unless noted otherwise the encoded form is
     terminated by a NUL byte. This sequence of bytes will be called an
     "encoded string", representing the given sequence of character
     codes.  Note that it is a property of the UTF-8 encoding that it
     does not change ASCII character code sequences.

     If a foreign function is specified to return an encoded string, an
     exception will be raised if, on return to Prolog, the actual
     string is malformed (is not a valid sequence of UTF-8 encoded
     characters). The exception raised is
     `representation_error(...,...,mis_encoded_string)'.



File: sicstus.info,  Node: Calling C from Prolog,  Next: Calling C++ from Prolog,  Prev: CPL Notes,  Up: Mixing C and Prolog

6.2 Calling C from Prolog
=========================

Functions written in the C language may be called from Prolog using an
interface in which automatic type conversions between Prolog terms and
common C types are declared as Prolog facts.  Calling without type
conversion can also be specified, in which case the arguments and
values are passed as SP_term_refs. This interface is partly modeled
after Quintus Prolog.

   The functions installed using this foreign language interface may
invoke Prolog code and use the support functions described in the other
sections of this chapter.

   Functions, or their equivalent, in any other language having C
compatible calling conventions may also be interfaced using this
interface. When referring to C functions in the following, we also
include such other language functions. Note however that a C compiler is
needed since a small amount of glue code (in C) must be generated for
interfacing purposes.

   As an alternative to this interface, `SP_define_c_predicate()'
defines a Prolog predicate such that when the Prolog predicate is
called it will call a C function with a term corresponding to the
Prolog goal. For details, *note cpg-ref-SP_define_c_predicate::.

* Menu:

* Foreign Resources:: Foreign Resources
* Conversion Declarations:: Conversion Declarations
* Conversions between Prolog Arguments and C Types:: Conversions between Prolog Arguments and C Types
* Interface Predicates:: Interface Predicates
* The Foreign Resource Linker:: The Foreign Resource Linker
* Init and Deinit Functions:: Init and Deinit Functions
* Creating the Linked Foreign Resource:: Creating the Linked Foreign Resource


File: sicstus.info,  Node: Foreign Resources,  Next: Conversion Declarations,  Up: Calling C from Prolog

6.2.1 Foreign Resources
-----------------------

A "foreign resource" is a set of C functions, defined in one or more
files, installed as an atomic operation.  The name of a foreign
resource, the "resource name", is an atom, which should uniquely
identify the resource.  Thus, two foreign resources with the same name
cannot be installed at the same time, even if they correspond to
different files.

   The resource name of a foreign resource is derived from its file
name by deleting any leading path and the suffix. Therefore the resource
name is not the same as the absolute file name.  For example, the
resource name of both `~john/foo/bar.so' and `~ringo/blip/bar.so' is
`bar'. If `load_foreign_resource('~john/foo/bar')' has been done
`~john/foo/bar.so' will be unloaded if either
`load_foreign_resource('~john/foo/bar')' or
`load_foreign_resource('~ringo/blip/bar')' is subsequently called.

   It is recommended that a resource name be all lowercase, starting
with `a' to `z' followed by a sequence consisting of `a' to `z',
underscore (`_'), and digits.  The resource name is used to construct
the file name containing the foreign resource.

   For each foreign resource, a `foreign_resource/2' fact is used to
declare the interfaced functions. For each of these functions, a
`foreign/[2,3]' fact is used to specify conversions between predicate
arguments and C-types.  These conversion declarations are used for
creating the necessary interface between Prolog and C.

   The functions making up the foreign resource, the automatically
generated glue code, and any libraries, are compiled and linked, using
the `splfr' tool (*note The Foreign Resource Linker::), to form a
"linked foreign resource". A linked foreign resource exists in two
different flavors, "static" and "dynamic". A static resource is simply
a relocatable object file containing the foreign code. A dynamic
resource is a shared library (`.so' under most UNIX dialects, `.dll'
under Windows), which is loaded into the Prolog executable at runtime.

   Foreign resources can be linked into the Prolog executable either
when the executable is built ("pre-linked"), or at runtime.
Pre-linking can be done using static or dynamic resources.
Runtime-linking can only be done using dynamic resources. Dynamic
resources can also be unlinked.

   In all cases, the declared predicates are installed by the built-in
predicate `load_foreign_resource/1'.  If the resource was pre-linked,
only the predicate names are bound; otherwise, runtime-linking is
attempted (using `dlopen()', `LoadLibrary()', or similar).


File: sicstus.info,  Node: Conversion Declarations,  Next: Conversions between Prolog Arguments and C Types,  Prev: Foreign Resources,  Up: Calling C from Prolog

6.2.2 Conversion Declarations
-----------------------------

Conversion declaration predicates:

`foreign_resource(+RESOURCENAME,+FUNCTIONS)  "hook"'
     Specifies that a set of foreign functions, to be called from
     Prolog, are to be found in the resource named by RESOURCENAME.
     FUNCTIONS is a list of functions exported by the resource.  Only
     functions that are to be called from Prolog and optionally one
     "init function" and one "deinit function" should be listed. The
     init and deinit functions are specified as `init(FUNCTION)' and
     `deinit(FUNCTION)' respectively (*note Init and Deinit
     Functions::). This predicate should be defined entirely in terms
     of facts (unit clauses) and will be called in the relevant module,
     i.e. not necessarily in the `user' module.  For example:

          foreign_resource('terminal', [scroll,pos_cursor,ask]).

     specifies that functions `scroll()', `pos_cursor()' and `ask()'
     are to be found in the resource `terminal'.

`foreign(+CFUNCTIONNAME, +PREDICATE)  "hook"'
`foreign(+CFUNCTIONNAME, +LANGUAGE, +PREDICATE)  "hook"'
     Specify the Prolog interface to a C function.  LANGUAGE is at
     present constrained to the atom `c', so there is no advantage in
     using `foreign/3' over `foreign/2'.  CFUNCTIONNAME is the name of
     a C function.  PREDICATE specifies the name of the Prolog
     predicate that will be used to call CFUNCTION().  PREDICATE also
     specifies how the predicate arguments are to be translated to and
     from the corresponding C arguments. These predicates should be
     defined entirely in terms of facts (unit clauses) and will be
     called in the relevant module, i.e. not necessarily in the `user'
     module.  For example:

          foreign(pos_cursor, c, move_cursor(+integer, +integer)).

     The above example says that the C function `pos_cursor()' has two
     integer value arguments and that we will use the predicate
     `move_cursor/2' to call this function.  A goal `move_cursor(5,
     23)' would translate into the C call `pos_cursor(5,23);'.

     The third argument of the predicate `foreign/3' specifies how to
     translate between Prolog arguments and C arguments. A call to a
     foreign predicate will raise an exception if an input arguments is
     uninstantiated (`instantiation_error/2') or has the wrong type
     (`type_error/4') or domain (`domain_error/4').  The call will fail
     upon return from the function if the output arguments do not unify
     with the actual arguments.

     The available conversions are listed in the next subsection.


File: sicstus.info,  Node: Conversions between Prolog Arguments and C Types,  Next: Interface Predicates,  Prev: Conversion Declarations,  Up: Calling C from Prolog

6.2.3 Conversions between Prolog Arguments and C Types
------------------------------------------------------

The following table lists the possible values for the arguments in the
predicate specification of `foreign/[2,3]'. The value declares which
conversion between corresponding Prolog argument and C type will take
place.

`Prolog: +integer'
`C:      long'
     The argument should be a number.  It is converted to a C `long'
     and passed to the C function.

`Prolog: +float'
`C:      double'
     The argument should be a number.  It is converted to a C `double'
     and passed to the C function.

`Prolog: +atom'
`C:      SP_atom'
     The argument should be an atom.  Its canonical representation is
     passed to the C function.

`Prolog: +codes'
`C:      char const *'
     The argument should be a code-list.  The C function will be passed
     the address of an array with the encoded string representation of
     these characters.  The array is subject to reuse by other support
     functions, so if the value is going to be used on a more than
     temporary basis, it must be moved elsewhere.

`Prolog: +string'
`C:      char const *'
     The argument should be an atom.  The C function will be passed the
     address of an encoded string representing the characters of the
     atom.  *Please note*: The C function must not overwrite the string.

`Prolog: +address'
`C:      void *'
     The value passed will be a `void *' pointer.

`Prolog: +address(TYPENAME)'
`C:      TYPENAME *'
     The value passed will be a `TYPENAME *' pointer.

`Prolog: +term'
`C:      SP_term_ref'
     The argument could be any term. The value passed will be the
     internal representation of the term.

`Prolog: -integer'
`C:      long *'
     The C function is passed a reference to an uninitialized `long'.
     The value returned will be converted to a Prolog integer.

`Prolog: -float'
`C:      double *'
     The C function is passed a reference to an uninitialized `double'.
     The value returned will be converted to a Prolog float.

`Prolog: -atom'
`C:      SP_atom *'
     The C function is passed a reference to an uninitialized `SP_atom'.
     The value returned should be the canonical representation of a
     Prolog atom.

`Prolog: -codes'
`C:      char const **'
     The C function is passed the address of an uninitialized `char *'.
     The returned encoded string will be converted to a Prolog
     code-list.

`Prolog: -string'
`C:      char const **'
     The C function is passed the address of an uninitialized `char *'.
     The returned encoded string will be converted to a Prolog atom.
     Prolog will copy the string to a safe place, so the memory
     occupied by the returned string may be reused during subsequent
     calls to foreign code.

`Prolog: -address'
`C:      void **'
     The C function is passed the address of an uninitialized `void *'.

`Prolog: -address(TYPENAME)'
`C:      TYPENAME **'
     The C function is passed the address of an uninitialized `TYPENAME
     *'.

`Prolog: -term'
`C:      SP_term_ref'
     The C function is passed a new SP_term_ref, and is expected to set
     its value to a suitable Prolog term.  Prolog will try to unify the
     value with the actual argument.

`Prolog: [-integer]'
`C:      long F()'
     The C function should return a `long'.  The value returned will be
     converted to a Prolog integer.

`Prolog: [-float]'
`C:      double F()'
     The C function should return a `double'.  The value returned will
     be converted to a Prolog float.

`Prolog: [-atom]'
`C:      SP_atom F()'
     The C function should return an `SP_atom'.  The value returned
     must be the canonical representation of a Prolog atom.

`Prolog: [-codes]'
`C:      char const *F()'
     The C function should return a `char *'.  The returned encoded
     string will be converted to a Prolog code-list.

`Prolog: [-string]'
`C:      char const *F()'
     The C function should return a `char *'.  The returned encoded
     string will be converted to a Prolog atom.  Prolog will copy the
     string to a safe place, so the memory occupied by the returned
     string may be reused during subsequent calls to foreign code.

`Prolog: [-address]'
`C:      void *F()'
     The C function should return a `void *', which will be converted
     to a Prolog integer.

`Prolog: [-address(TYPENAME)]'
`C:      TYPENAME *F()'
     The C function should return a `TYPENAME *'.

`Prolog: [-term]'
`C:      SP_term_ref F()'
     The C function should return an SP_term_ref.  Prolog will try to
     unify its value with the actual argument.


File: sicstus.info,  Node: Interface Predicates,  Next: The Foreign Resource Linker,  Prev: Conversions between Prolog Arguments and C Types,  Up: Calling C from Prolog

6.2.4 Interface Predicates
--------------------------

`load_foreign_resource(:RESOURCE)'
     Unless a foreign resource with the same name as RESOURCE has been
     statically linked, the linked foreign resource specified by
     RESOURCE is linked into the Prolog load image.  In both cases, the
     predicates defined by RESOURCE are installed, and any init
     function is called.  Dynamic linking is not possible if the
     foreign resource was linked using the `--static' option.

     If a resource with the same name has been previously loaded, it
     will be unloaded, as if `unload_foreign_resource(RESOURCE)' were
     called, before RESOURCE is loaded.

`unload_foreign_resource(:RESOURCENAME)'
     Any deinit function associated with RESOURCENAME, a resource name,
     is called, and the predicates defined by RESOURCENAME are
     uninstalled.  If RESOURCENAME has been dynamically linked, it is
     unlinked from the Prolog load image.

     If no resource named `RESOURCENAME' is currently loaded, an
     existence error is raised.

     For backward compatibility, RESOURCENAME can also be of the same
     type as the argument to `load_foreign_resource/1'. In that case
     the resource name will be derived from the absolute file name in
     the same manner as for `load_foreign_resource/1'. Also for backward
     compatibility, `unload_foreign_resource/1' is a meta-predicate,
     but the module is ignored.

          *Please note*: all foreign resources are unloaded before
          Prolog exits.  This implies that the C library function
          `atexit(FUNC)' cannot be used if FUNC is defined in a
          dynamically linked foreign resource.



File: sicstus.info,  Node: The Foreign Resource Linker,  Next: Init and Deinit Functions,  Prev: Interface Predicates,  Up: Calling C from Prolog

6.2.5 The Foreign Resource Linker
---------------------------------

The foreign resource linker, `splfr', is used for creating foreign
resources (*note Foreign Resources::).  `splfr' reads terms from a
Prolog file, applying op declarations and extracting any
`foreign_resource/2' fact with first argument matching the resource
name and all `foreign/[2,3]' facts.  Based on this information, it
generates the necessary glue code, and combines it with any additional
C or object files provided by the user into a linked foreign resource.
The output file name will be the resource name with a suitable
extension.

* Menu:

* Customizing splfr:: Customizing `splfr' under UNIX
* Manual splfr:: Creating Dynamic Linked Foreign Resources Manually under UNIX


File: sicstus.info,  Node: Customizing splfr,  Next: Manual splfr,  Up: The Foreign Resource Linker

6.2.5.1 Customizing `splfr' under UNIX
......................................

The `splfr' tool is implemented as a Perl script and can be customized
in order to adapt to local variations. _Do not attempt this unless you
know what you are doing_.  Customization is done by editing their
common configuration file `spconfig-VERSION'. Follow these instructions:

  1. Locate the configuration file `spconfig-VERSION'. It should be
     located in the same directory as `splfr'.

  2. Make a copy for `spconfig-VERSION'; let's call it
     `hacked_splfr.config'. Do not edit the original file.

  3. The configuration file contains lines on the form `CFLAGS=-g -O2'.
     Edit these according to your needs. Do not add or remove any flags.

  4. You may now use the modified `spconfig-VERSION' together with
     `splfr' like this:
          % splfr [...] --config=/path/to/hacked_splfr.config

  5. Replace `/path/to' with the actual path to the hacked configuration
     file.


File: sicstus.info,  Node: Manual splfr,  Prev: Customizing splfr,  Up: The Foreign Resource Linker

6.2.5.2 Creating Dynamic Linked Foreign Resources Manually under UNIX
.....................................................................

The only supported method for building foreign resources is by
compiling and linking them with `splfr'. However, this is sometimes
inconvenient, for instance when writing a Makefile for use with `make'.
To figure out what needs to be done to build a foreign resource, you
should build it once with `splfr --verbose --keep ...', note what
compiler and linker flags are used, and save away any generated files.
You can then mimic the build commands used by `splfr' in your
`Makefile'. You should repeat this process each time you upgrade
SICStus Prolog.


File: sicstus.info,  Node: Init and Deinit Functions,  Next: Creating the Linked Foreign Resource,  Prev: The Foreign Resource Linker,  Up: Calling C from Prolog

6.2.6 Init and Deinit Functions
-------------------------------

An init function and/or a deinit function can be declared by
`foreign_resource/2'. If this is the case, these functions should have
the prototype:

`void FUNCTIONNAME (int when)'

   The init function is called by `load_foreign_resource/1' after the
resource has been loaded and the interfaced predicates have been
installed.  If the init function fails (using `SP_fail()') or raises an
exception (using `SP_raise_exception()'), the failure or exception is
propagated by `load_foreign_resource/1' and the foreign resource is
unloaded (without calling any deinit function). However, using
`SP_fail()' is not recommended, and operations that may require
`SP_raise_exception()' are probably better done in an init function
that is called explicitly after the foreign resource has been loaded.

   The deinit function is called by `unload_foreign_resource/1' before
the interfaced predicates have been uninstalled and the resource has
been unloaded.  If the deinit function fails or raises an exception,
the failure or exception is propagated by `unload_foreign_resource/1',
but the foreign resource is still unloaded.  However, neither
`SP_fail()' nor `SP_raise_exception()' should be called in a deinit
function.  Complex deinitialization should be done in an explicitly
called deinit function instead.

   The init and deinit functions may use the C-interface to call Prolog
etc.

   Foreign resources are unloaded when the saved-state is restored;
*note Saving::.  Foreign resources are also unloaded when exiting
Prolog execution. The parameter `when' reflects the context of the
`(un)load_foreign_resource/1' and is set as follows for init functions:

`SP_WHEN_EXPLICIT'
     Explicit call to `load_foreign_resource/1'.

`SP_WHEN_RESTORE'
     Resource is reloaded after restore.

   For deinit functions:

`SP_WHEN_EXPLICIT'
     Explicit call to `unload_foreign_resource/1' or a call to
     `load_foreign_resource/1' with the name of an already loaded
     resource.

`SP_WHEN_EXIT'
     Resource is unloaded before exiting Prolog.


File: sicstus.info,  Node: Creating the Linked Foreign Resource,  Prev: Init and Deinit Functions,  Up: Calling C from Prolog

6.2.7 Creating the Linked Foreign Resource
------------------------------------------

Suppose we have a Prolog source file `ex.pl' containing:

                                                              _% ex.pl_
     foreign(f1, p1(+integer,[-integer])).
     foreign(f2, p2(+integer,[-integer])).
     foreign_resource(ex, [f1,f2]).
     :- load_foreign_resource(ex).

and a C source file `ex.c' with definitions of the functions `f1' and
`f2', both returning `long' and having a `long' as the only parameter.
The conversion declarations in `ex.pl' state that these functions form
the foreign resource `ex'.

   To create the linked foreign resource, simply type (to the Shell):

     % splfr ex.pl ex.c

   The linked foreign resource `ex.so' (file suffix `.so' is system
dependent) has been created. It will be dynamically linked by the
directive `:- load_foreign_resource(ex).' when the file `ex.pl' is
loaded.

   Dynamic linking of foreign resources can also be used by runtime
systems.  On some platforms, however, the executable must not be
"stripped" for dynamic linking to work, i.e. its symbol table must
remain.


File: sicstus.info,  Node: Calling C++ from Prolog,  Next: Support Functions,  Prev: Calling C from Prolog,  Up: Mixing C and Prolog

6.3 Calling C++ from Prolog
===========================

Functions in C++ files that should be called from Prolog must use C
linkage, e.g.

     extern "C" {
     void myfun(long i)
     {...};
     };

   To build a dynamic linked foreign resource with C++ code, you may
(depending on platform) have to explicitly include certain libraries.
E.g. on Sparc/SunOS 5.X using `gcc':

     % splfr .... -LD -L/usr/gnu/lib/gcc-lib/sparc-sun-solaris2.4/2.7.0 -lgcc

   The library path is installation dependent, of course.


File: sicstus.info,  Node: Support Functions,  Next: Calling Prolog from C,  Prev: Calling C++ from Prolog,  Up: Mixing C and Prolog

6.4 Support Functions
=====================

The support functions include functions to manipulate SP_term_refs,
functions to convert data between the basic C types and Prolog terms,
functions to test whether a term can be converted to a specific C type,
and functions to unify or compare two terms.

* Menu:

* Creating and Manipulating SP_term_refs:: Creating and Manipulating SP_term_refs
* Atoms in C:: Atoms in C
* Creating Prolog Terms:: Creating Prolog Terms
* Accessing Prolog Terms:: Accessing Prolog Terms
* Testing Prolog Terms:: Testing Prolog Terms
* Unifying and Comparing Terms:: Unifying and Comparing Terms
* Operating System Services:: Operating System Services


File: sicstus.info,  Node: Creating and Manipulating SP_term_refs,  Next: Atoms in C,  Up: Support Functions

6.4.1 Creating and Manipulating SP_term_refs
--------------------------------------------

Normally, C functions only have indirect access to Prolog terms via
SP_term_refs.  C functions may receive arguments as unconverted Prolog
terms, in which case the actual arguments received will have the type
`SP_term_ref'.  Also, a C function may return an unconverted Prolog
term, in which case it must create an SP_term_ref.  Finally, any
temporary Prolog terms created by C code must be handled as
SP_term_refs.

   SP_term_refs are motivated by the fact that SICStus Prolog's memory
manager must have a means of reaching all live Prolog terms for memory
management purposes, including such terms that are being manipulated by
the user's C code.  Previous releases of SICStus Prolog provided direct
access to Prolog terms and the ability to tell the memory manager that
a given memory address points to a Prolog term, but this approach was
too low level and highly error-prone.  The current design is modeled
after and largely compatible with Quintus Prolog release 3.

   SP_term_refs are created dynamically.  At any given time, an
SP_term_ref has a value (a Prolog term, initially `[]').  This value
can be examined, accessed, and updated by the support functions
described in this section.

   It is important to understand the rules governing the scope of
SP_term_refs in conjunction with calls from Prolog to C and vice versa:

   * When a C function called from Prolog returns, all SP_term_refs
     passed to the function or dynamically created by the function
     become invalid.

   * When terms are passed to C as a result of calling Prolog, those
     terms and any SP_term_refs created since the start of the query
     are only valid until backtracking into the query or an enclosing
     one.

   A new SP_term_ref is created by calling `SP_new_term_ref()'.

   An SP_term_ref can be assigned the value of another SP_term_ref by
calling `SP_put_term()'.


File: sicstus.info,  Node: Atoms in C,  Next: Creating Prolog Terms,  Prev: Creating and Manipulating SP_term_refs,  Up: Support Functions

6.4.2 Atoms in C
----------------

Each Prolog atom is represented internally by a unique integer, its
"canonical representation", with the corresponding C type `SP_atom'.
This mapping between atoms and integers depends on the execution
history.  Certain functions require this representation as opposed to
an SP_term_ref.  It can be obtained by a special argument type
declaration when calling C from Prolog, by calling `SP_get_atom()', or
by looking up an encoded string `s' in the Prolog symbol table by
calling `SP_atom_from_string(s)' which returns the atom, or zero if the
given string is malformed (is not a valid sequence of UTF-8 encoded
characters).

   The encoded string containing the characters of a Prolog atom `a'
can be obtained by calling `SP_string_from_atom()'.

   The length of the encoded string representing a Prolog atom `a' can
be obtained by calling `SP_atom_length()'.

   Prolog atoms, and the space occupied by their print names, are
subject to garbage collection when the number of atoms has reached a
certain threshold, under the control of the `agc_margin' Prolog flag,
or when the atom garbage collector is called explicitly.  The atom
garbage collector will find all references to atoms from the Prolog
specific memory areas, including SP_term_refs and arguments passed from
Prolog to foreign language functions.  However, atoms created by
`SP_atom_from_string()' and merely stored in a local variable are
endangered by garbage collection.  The functions `SP_register_atom()'
and `SP_unregister_atom()' make it possible to protect an atom while it
is in use.  The operations are implemented using reference counters to
support multiple, independent use of the same atom in different foreign
resources.  


File: sicstus.info,  Node: Creating Prolog Terms,  Next: Accessing Prolog Terms,  Prev: Atoms in C,  Up: Support Functions

6.4.3 Creating Prolog Terms
---------------------------

The following functions create a term and store it as the value of an
SP_term_ref, which must exist prior to the call.  They return zero if
the conversion fails (as far as failure can be detected), and a nonzero
value otherwise, assigning to `t' the converted value.

`SP_put_variable()'
     Creates a variable.

`SP_put_integer()'
     Creates an integer.

`SP_put_float()'
     Creates a float.

`SP_put_atom()'
     Creates an atom.

`SP_put_string()'
     Creates an atom.

`SP_put_address()'
     Creates an integer representing a pointer.

`SP_put_list_codes()'
     Creates a char-list.

`SP_put_list_n_codes()'
     Creates a char-list.

`SP_put_list_n_bytes()'
     Creates a byte-list.

`SP_put_integer_bytes()'
     Creates an arbitrarily sized integer.

`SP_put_number_codes()'
     Creates a char-list denoting a number.

`SP_put_functor()'
     Creates a compound term.

`SP_put_list()'
     Creates a list.

`SP_cons_functor()'
     Creates a compound term with arguments filled in.

`SP_cons_list()'
     Creates a list with arguments filled in.

`SP_read_from_string() (C function)'
     Reads a term from its textual representation, replacing variables
     by specified terms.


File: sicstus.info,  Node: Accessing Prolog Terms,  Next: Testing Prolog Terms,  Prev: Creating Prolog Terms,  Up: Support Functions

6.4.4 Accessing Prolog Terms
----------------------------

The following functions will take an SP_term_ref and convert it to C
data.  They return zero if the conversion fails, and a nonzero value
otherwise, and store the C data in output arguments, except the last
two, which merely decompose compound terms.

`SP_get_integer()'
     Accesses an integer.

`SP_get_float()'
     Accesses a float.

`SP_get_atom()'
     Accesses an atom.

`SP_get_string()'
     Accesses an atom.

`SP_get_address()'
     Accesses an integer representing a pointer.

`SP_get_list_codes()'
     Accesses a code-list.

`SP_get_list_n_codes()'
     Accesses a code-list.

`SP_get_list_n_bytes()'
     Accesses a byte-list.

`SP_get_number_codes()'
     Accesses a code-list denoting a number.

`SP_get_integer_bytes()'
     Accesses an arbitrarily sized integer.

`SP_get_functor()'
     Accesses a compound term.

`SP_get_list()'
     Accesses a list.

`SP_get_arg()'
     Accesses an argument of a compound term.


File: sicstus.info,  Node: Testing Prolog Terms,  Next: Unifying and Comparing Terms,  Prev: Accessing Prolog Terms,  Up: Support Functions

6.4.5 Testing Prolog Terms
--------------------------

There is one general function for type testing of Prolog terms as well
as a set of specialized, more efficient, functions--one for each term
type:

`SP_term_type()'
     Accesses term type.

`SP_is_variable()'
     Checks whether term is a variable.

`SP_is_integer()'
     Checks whether term is an integer.

`SP_is_float()'
     Checks whether term is a float.

`SP_is_atom()'
     Checks whether term is an atom.

`SP_is_compound()'
     Checks whether term is compound.

`SP_is_list()'
     Checks whether term is a list.

`SP_is_atomic()'
     Checks whether term is atomic.

`SP_is_number()'
     Checks whether term is a number.


File: sicstus.info,  Node: Unifying and Comparing Terms,  Next: Operating System Services,  Prev: Testing Prolog Terms,  Up: Support Functions

6.4.6 Unifying and Comparing Terms
----------------------------------

The two functions are:

`SP_unify()'
     Unify terms.

`SP_compare()'
     Compare terms.


File: sicstus.info,  Node: Operating System Services,  Prev: Unifying and Comparing Terms,  Up: Support Functions

6.4.7 Operating System Services
-------------------------------

* Menu:

* OS Memory Management:: Memory Management
* OS File System:: File System
* OS Threads:: Threads


File: sicstus.info,  Node: OS Memory Management,  Next: OS File System,  Up: Operating System Services

6.4.7.1 Memory Management
.........................

The standard C library memory allocation functions (`malloc', `calloc',
`realloc', and `free') are available in foreign code, but cannot reuse
any free memory that SICStus Prolog's memory manager may have
available, and so may contribute to memory fragmentation.

   The following functions provide the same services via SICStus
Prolog's memory manager.

`SP_malloc()'
     Allocates a piece of memory.

`SP_calloc()'
     Allocates memory for an array of elements, and clears the
     allocated memory.

`SP_realloc()'
     Changes the size of an allocated piece of memory.

`SP_free()'
     Deallocates a piece of memory.

`SP_strdup()'
     Makes a copy of a string in allocated memory.


File: sicstus.info,  Node: OS File System,  Next: OS Threads,  Prev: OS Memory Management,  Up: Operating System Services

6.4.7.2 File System
...................

SICStus Prolog caches the name of the current working directory.  To
take advantage of the cache and to keep it consistent, foreign code
should call the following interface functions instead of calling
`chdir()' and `getcwd()' directly:

`SP_set_current_dir()'
     Obtains the absolute name of the current working directory.

`SP_get_current_dir()'
     Sets the current working directory.


File: sicstus.info,  Node: OS Threads,  Prev: OS File System,  Up: Operating System Services

6.4.7.3 Threads
...............

When running more that one SICStus run-time in the same process it is
often necessary to protect data with mutual exclusion locks. The
following functions implement recursive mutual exclusion locks, which
only need static initialization.

`SP_mutex_lock()'
     Locks the mutex.

`SP_mutex_unlock()'
     Unlocks the mutex.

   A (recursive) mutual exclusion lock is declared as type `SP_mutex'.
It should be initialized to (the static initializer)
`SP_MUTEX_INITIALIZER' before use.

   Note that the SICStus run-time is not thread safe in general.

   A dynamic foreign resource that is used by multiple SICStus
run-times in the same process may need to maintain a global state that
is kept separate for each SICStus run-time. Each SICStus run-time
maintains a location (containing a `void*') for each foreign resource.
By calling `SP_foreign_stash()', a foreign resource can then access
this location to store any data that is specific to the calling SICStus
run-time.


File: sicstus.info,  Node: Calling Prolog from C,  Next: SICStus Streams,  Prev: Support Functions,  Up: Mixing C and Prolog

6.5 Calling Prolog from C
=========================

In development and runtime systems alike, Prolog and C code may call
each other to arbitrary depths.

   Before calling a predicate from C you must look up the predicate
definition by module, name, and arity.  The function `SP_predicate()'
will return a pointer to this definition or return `NULL' if the
predicate is not visible in the module.  This definition can be used in
more than one call to the same predicate.

   The function `SP_pred()' may be used as an alternative to the above.
The only difference is that the name and module arguments are passed
as Prolog atoms rather than strings, and the module argument is
mandatory.  This saves the cost of looking up the two arguments in the
Prolog symbol table.  This cost dominates the cost of the operation.

* Menu:

* Finding One Solution of a Call:: Finding One Solution of a Call
* Finding Multiple Solutions of a Call:: Finding Multiple Solutions of a Call
* Calling Prolog Asynchronously:: Calling Prolog Asynchronously
* Exception Handling in C:: Exception Handling in C


File: sicstus.info,  Node: Finding One Solution of a Call,  Next: Finding Multiple Solutions of a Call,  Up: Calling Prolog from C

6.5.1 Finding One Solution of a Call
------------------------------------

The easiest way to call a predicate if you are only interested in the
first solution is to call the function `SP_query()'.  It will create a
goal from the predicate definition and the arguments, call it, and
commit to the first solution found, if any.

   If you are only interested in the side-effects of a predicate you
can call `SP_query_cut_fail()'.  It will try to prove the predicate,
cut away the rest of the solutions, and finally fail.  This will
reclaim any memory used after the call, and throw away any solution
found.


File: sicstus.info,  Node: Finding Multiple Solutions of a Call,  Next: Calling Prolog Asynchronously,  Prev: Finding One Solution of a Call,  Up: Calling Prolog from C

6.5.2 Finding Multiple Solutions of a Call
------------------------------------------

If you are interested in more than one solution a more complicated
scheme is used.  You find the predicate definition as above, but you
don't call the predicate directly.

  1. Set up a call with `SP_open_query()'

  2. Call `SP_next_solution()' to find a solution.  Call this predicate
     again to find more solutions if there are any.

  3. Terminate the call with `SP_close_query()' or `SP_cut_query()'

   The function `SP_open_query()' will return an identifier of type
`SP_qid' that you use in successive calls.  Note that if a new query is
opened while another is already open, the new query must be terminated
before exploring the solutions of the old one.  That is, queries must
be strictly nested.  

   The function `SP_next_solution()' will cause the Prolog engine to
backtrack over any current solution of an open query and look for a new
one.  

   A query must be terminated in either of two ways.  The function
`SP_cut_query()' will discard the choices created since the
corresponding `SP_open_query()', like the goal `!'.  The current
solution is retained in the arguments until backtracking into any
enclosing query.  

   Alternatively, the function `SP_close_query()' will discard the
choices created since the corresponding `SP_open_query()', and then
backtrack into the query, throwing away any current solution, like the
goal `!, fail'.

   A simple way to call arbitrary prolog code is to use
`SP_read_from_string()' (*note Creating Prolog Terms::) to create an
argument to `call/1'. It is a good idea to always explicitly specify
the module context when using `call/1' or other meta-predicates from C.


File: sicstus.info,  Node: Calling Prolog Asynchronously,  Next: Exception Handling in C,  Prev: Finding Multiple Solutions of a Call,  Up: Calling Prolog from C

6.5.3 Calling Prolog Asynchronously
-----------------------------------

* Menu:

* Signal Handling:: Signal Handling

   If you wish to call Prolog back from a signal handler or a thread
other than the thread that called `SP_initialize()', that is, the "main
thread", you cannot use `SP_query()' etc. directly.  The call to Prolog
has to be delayed until such time that the Prolog execution can accept
an interrupt and the call has to be performed from the main thread (the
Prolog execution thread).  The function `SP_event()' serves this
purpose, and installs the function `func' to be called from Prolog (in
the main thread) when the execution can accept a callback.

   A queue of functions, with corresponding arguments, is maintained;
that is, if several calls to `SP_event()' occur before Prolog can
accept an interrupt, the functions are queued and executed in turn at
the next possible opportunity. A `func' installed with `SP_event()'
will not be called until SICStus is actually running. One way of
ensuring that all pending functions installed with `SP_event()' are run
is to call, from the main thread, some dummy goal, such as,
`SP_query_cut_fail(SP_predicate("true",0,"user"))'.

   While `SP_event()' is safe to call from any thread, it is not safe
to call from arbitrary signal handlers. If you want to call
`SP_event()' when a signal is delivered, you need to install your
signal handler with `SP_signal()' (see below).

   Note that `SP_event()' is one of the _very_ few functions in the
SICStus API that can safely be called from another thread than the main
thread.  


File: sicstus.info,  Node: Signal Handling,  Up: Calling Prolog Asynchronously

6.5.3.1 Signal Handling
.......................

As noted above it is not possible to call e.g. `SP_query()' or even
`SP_event()' from an arbitrary signal handler. That is, from signal
handlers installed with `signal' or `sigaction'. Instead you need to
install the signal handler using `SP_signal()'.  

   When the OS delivers a signal `sig' for which
`SP_signal(sig,func,user_data)' has been called SICStus will _not_ call
`func' immediately. Instead the call to `func' will be delayed until it
is safe for Prolog to do so, in much the same way that functions
installed by `SP_event()' are handled (this is an incompatible change
from SICStus 3.8 and earlier).

   Since the signal handling function `func' will not be called
immediately upon delivery of the signal to the process it only makes
sense to use `SP_signal()' to handle certain asynchronous signals such
as `SIGINT', `SIGUSR1', `SIGUSR2'. Other asynchronous signals handled
specially by the OS, such as `SIGCHLD' are not suitable for handling
via `SP_signal()'.  Note that the development system installs a handler
for `SIGINT', and, under Windows, `SIGBREAK', to catch keyboard
interrupts. Under UNIX, `library(timeout)' currently uses `SIGVTALRM'.

   When `func' is called, it cannot call any SICStus API functions
except `SP_event()'. Note that `func' will be called in the main thread.


File: sicstus.info,  Node: Exception Handling in C,  Prev: Calling Prolog Asynchronously,  Up: Calling Prolog from C

6.5.4 Exception Handling in C
-----------------------------

When an exception has been raised, the functions `SP_query()',
`SP_query_cut_fail()' and `SP_next_solution()' return `SP_ERROR'.  To
access the "exception term" (the argument of the call to
`raise_exception/1'), which is asserted when the exception is raised,
the function `SP_exception_term()' is used.  As a side-effect, the
exception term is retracted, so if your code wants to pass the
exception term back to Prolog, use `SP_raise_exception()'.  

   To raise an exception from a C function called from Prolog, just call
`SP_raise_exception()'.  Upon return, Prolog will detect that an
exception has been raised, any value returned from the function will be
ignored, and the exception will be passed back to Prolog.  

   To propagate failure to Prolog, call `SP_fail()'. Upon return,
Prolog will backtrack.  

   Prolog error handling is mostly done by raising and catching
exceptions.  However, some "faults" are of a nature such that when they
occur, the internal program state may be corrupted, and it is not safe
to merely raise an exception.  In runtime systems, the C macro
`SP_on_fault()' provides an environment for handling faults.

   The function `SP_raise_fault()' can be used to raise a fault with an
encoded string explaining the reason.


File: sicstus.info,  Node: SICStus Streams,  Next: Stand-Alone Executables,  Prev: Calling Prolog from C,  Up: Mixing C and Prolog

6.6 SICStus Streams
===================

With the SICStus Prolog C interface, the user can define his/her own
streams as well as from C read or write on the predefined streams.  The
stream interface provides:

   * C functions to perform I/O on Prolog streams.  This way you can
     use the same stream from Prolog and C code.

   * User defined streams. You can define your own Prolog streams in C.

   * Bidirectional streams. A SICStus stream supports reading or
     writing or both.

   * Hookable standard input/output/error streams.

* Menu:

* Prolog Streams:: Prolog Streams
* Defining a New Stream:: Defining a New Stream
* Hookable Standard Streams:: Hookable Standard Streams


File: sicstus.info,  Node: Prolog Streams,  Next: Defining a New Stream,  Up: SICStus Streams

6.6.1 Prolog Streams
--------------------

From the Prolog level there is a unique number that identifies a
stream. This identifier can be converted from/to a Prolog stream:

`stream_code(?STREAM,?STREAMCODE)'
     STREAMCODE is the C stream identifier (an integer) corresponding
     to the Prolog stream STREAM.  This predicate is only useful when
     streams are passed between Prolog and C.


   The `STREAMCODE' is a Prolog integer representing an `SP_stream *'
pointer.

To read or write on a Prolog stream from C, the following functions and
macros can be used:
`SP_get_byte()'
     Read one byte from a binary stream.

`SP_get_code()'
     Read one character code from a text stream.

`SP_put_byte()'
     Write one byte to a binary stream.

`SP_put_code()'
     Write one character code to a text stream.

`SP_put_bytes()'
     Write multiple bytes to a binary stream.

`SP_put_codes()'
     Write multiple character codes to a text stream.

`SP_put_encoded_string()'
     Write a `NUL' terminated encoded string to a text stream.

`SP_printf()'

`SP_fprintf()'
     Perform formatted output.

`SP_flush_output()'
     Flush buffered data of an output stream.

`SP_fclose()'
     Close a stream.

   The following predefined streams are accessible from C:

`SP_stdin'
     Standard input. Refers to the same stream as `user_input' in
     Prolog. Which stream is referenced by `user_input' is controlled
     by the Prolog flag `user_input'.  

`SP_stdout'
     Standard output. Refers to the same stream as `user_output' in
     Prolog. Which stream is referenced by `user_output' is controlled
     by the Prolog flag `user_output'.  

`SP_stderr'
     Standard error. Refers to the same stream as `user_error' in
     Prolog. Which stream is referenced by `user_error' is controlled
     by the flag `user_error'.  

`SP_curin'
     Current input. It is initially set equal to `SP_stdin'.  It can be
     changed with the predicates `see/1' and `set_input/1'.

`SP_curout'
     Current output. It is initially set equal to `SP_stdout'.  It can
     be changed with the predicates `tell/1' and `set_output/1'.

   Note that these variables are read only.


File: sicstus.info,  Node: Defining a New Stream,  Next: Hookable Standard Streams,  Prev: Prolog Streams,  Up: SICStus Streams

6.6.2 Defining a New Stream
---------------------------

The following steps are required to define a new stream in C:

   * Define low level functions (byte or character reading, writing
     etc).

   * Initialize and open your stream.

   * Allocate memory needed for your particular stream.

   * Initialize and install a Prolog stream with `SP_create_stream()'.


   The following sample makes it possible to create read-only binary
streams that use the C `FILE*' API.

     #include <sicstus/sicstus.h>
     #include <stdio.h>
     #include <string.h>
     #include <errno.h>

     struct stdio_t_stream {
       FILE *f;
     };
     typedef struct stdio_t_stream stdio_t_stream;

     static spio_t_error_code SPCDECL stdio_read(void *user_data,
                                                 void *buf,
                                                 size_t *pbuf_size,
                                                 spio_t_bits read_options)
     {
       spio_t_error_code ecode = SPIO_E_ERROR;
       stdio_t_stream *s;
       size_t res;

       if (read_options & SPIO_DEVICE_READ_OPTION_NONBLOCKING)
         {
           ecode = SPIO_E_NOT_SUPPORTED;
           goto barf;
         }

       s = (stdio_t_stream *)user_data;

       res = fread(buf, 1, *pbuf_size, s->f);
       if (res == 0)                 /* error */
         {
           if (feof(s->f))
             {
               ecode = SPIO_E_END_OF_FILE;
             }
           else                      /* some other error */
             {
               ecode = SPIO_E_OS_ERROR;
             }
           goto barf;
         }
       *pbuf_size = res;             /* number of bytes read */

       return SPIO_S_NOERR;

      barf:
       return ecode;
     }

     static spio_t_error_code SPCDECL stdio_close(void **puser_data, spio_t_bits close_options)
     {
       stdio_t_stream *s;

       s = (stdio_t_stream *)*puser_data;
       /* we can ignore SPIO_DEVICE_CLOSE_OPTION_FORCE */

       if (close_options & SPIO_DEVICE_CLOSE_OPTION_READ)
         {
           *puser_data = NULL;       /* tell caller we are gone */
           if (fclose(s->f) != 0)
             {
               ;          /* ignore errors */
             }
         }
       return SPIO_S_NOERR;
     }

     /* Identify our streams with (an arbitrary) pointer that is unique to us */
     #define STDIO_STREAM_CLASS ((void*)&stdio_open_c)

     long SPCDECL stdio_open_c(char const *path,
                               char const *direction,
                               SP_stream **pstream)
     {
       spio_t_error_code ecode = SPIO_E_ERROR;
       stdio_t_stream *s = NULL;
       SP_stream *stream = NULL;

       if (strcmp(direction, "read") != 0)
         {
           goto not_supported;
         }
       /* read */

       s = (stdio_t_stream*)SP_malloc(sizeof *s);
       if (s == NULL) goto out_of_memory;

       /* open binary */
       s->f = fopen(path, "rb");
       if (s->f == NULL)
         {
           ecode = SPIO_E_OPEN_ERROR;
           goto barf;
         }
       ecode = SP_create_stream((void*)s,
                                STDIO_STREAM_CLASS,
                                stdio_read,
                                NULL, /* write */
                                NULL, /* flush_output */
                                NULL, /* seek */
                                stdio_close,
                                NULL, /* interrupt */
                                NULL, /* ioctl */
                                NULL, /* args */
                                SP_CREATE_STREAM_OPTION_BINARY,
                                &stream);
       if (SPIO_FAILED(ecode)) goto barf;

       *pstream = stream;
       return 0;                     /* success */

      barf:
       if (s != NULL)
         {
           if (s->f != NULL) fclose(s->f);
           SP_free(s);
         }
       return ecode;
      out_of_memory:
       ecode = SPIO_E_OUT_OF_MEMORY;
       goto barf;
      not_supported:
       ecode = SPIO_E_NOT_IMPLEMENTED;
       goto barf;
     }

   Calling `stdio_open_c("foo", "read", &stream)' will open the file
`foo' as binary stream that can be read by all SICStus stream
operations.

   There are several stream implementions in the SICStus Prolog library
that can serve as sample, e.g. `library(codesio)' and `library(tcltk)'.

   *Note cpg-ref-SP_create_stream::, for details.

* Menu:

* Low Level I/O Functions:: Low Level I/O Functions


File: sicstus.info,  Node: Low Level I/O Functions,  Up: Defining a New Stream

6.6.2.1 Low Level I/O Functions
...............................

For each new stream the appropriate low level I/O functions have to be
defined.  Error handling, prompt handling and character counting is
handled in a layer above these functions.  They all operate on a user
defined private data structure specified when the stream is created.

`int USER_READ()'
     Should fill a buffer with data available from the stream. *Note
     cpg-ref-user_read::.

`int USER_WRITE()'
     Should write data from a buffer to the stream. *Note
     cpg-ref-user_write::.

`int USER_FLUSH_OUTPUT()'
     Should flush the (output) stream.

`int USER_CLOSE()'
     Should close the stream in the specified directions. Note that
     bi-directional streams can be closed one direction at a time.

   *Please note:* A foreign resource that defines user defined streams
must ensure that all its streams are closed when the foreign resource
is unloaded. Failure to do this will lead to crashes when sicstus tries
to close the stream using a `user_close' method that is no longer
present.

   The easiest way to ensure that all user defined streams of a
particular class is closed is to use `SP_fclose' with the
`SP_FCLOSE_OPTION_USER_STREAMS'. Another way is to use `SP_next_stream'
and `SP_get_stream_user_data' to find all your streams and close them
one by one. *Note cpg-ref-SP_fclose::, *Note cpg-ref-SP_next_stream::
and *Note cpg-ref-SP_get_stream_user_data::.


File: sicstus.info,  Node: Hookable Standard Streams,  Prev: Defining a New Stream,  Up: SICStus Streams

6.6.3 Hookable Standard Streams
-------------------------------

The standard I/O streams (input, output, and error) are hookable, i.e.
the streams can be redefined by the user by calling
`SP_set_user_stream_hook()' and/or `SP_set_user_stream_post_hook()'.
These hook functions must be called before `SP_initialize()' (*note
Initializing the Prolog Engine::).  In custom built systems, they may
be called in the hook function `SU_initialize()'.  *Note The
Application Builder::.

* Menu:

* Writing User-stream Hooks:: Writing User-stream Hooks
* Writing User-stream Post-hooks:: Writing User-stream Post-hooks


File: sicstus.info,  Node: Writing User-stream Hooks,  Next: Writing User-stream Post-hooks,  Up: Hookable Standard Streams

6.6.3.1 Writing User-stream Hooks
.................................

The user-stream hook is, if defined, called during `SP_initialize()'.
It has the following prototype:

     SP_stream *user_stream_hook(void *user_data, int which)

   If the hook is not defined, SICStus will attempt to open the
standard TTY/console versions of these streams. If they are unavailable
(such as for non-console executables under Windows), the result is
undefined.

   It is called once for each stream. The `which' argument indicates
which stream it is called for. The value of `which' is one of the
following:

`SP_STREAMHOOK_STDIN'
     Create stream for standard input.

`SP_STREAMHOOK_STDOUT'
     Create stream for standard output.

`SP_STREAMHOOK_STDERR'
     Create stream for standard error.

The set of possible values for `which' may be expanded in the future.

   The hook should return a standard SICStus I/O stream, as described
in *Note Defining a New Stream::.

   *Note cpg-ref-SP_set_user_stream_hook::, for details.


File: sicstus.info,  Node: Writing User-stream Post-hooks,  Prev: Writing User-stream Hooks,  Up: Hookable Standard Streams

6.6.3.2 Writing User-stream Post-hooks
......................................

If defined, the user-stream post-hook is called after all the streams
have been defined, once for each of the standard streams. It has a
slightly different prototype:

     void user_stream_post_hook(void *user_data, int which, SP_stream *str)

where `str' is a pointer to the corresponding `SP_stream' structure.
There are no requirements as to what this hook must do; the default
behavior is to do nothing at all.

   The post-hook is intended to be used to do things that may require
that all streams have been created.

   *Note cpg-ref-SP_set_user_stream_post_hook::, for details.


File: sicstus.info,  Node: Stand-Alone Executables,  Next: Mixing Examples,  Prev: SICStus Streams,  Up: Mixing C and Prolog

6.7 Stand-Alone Executables
===========================

So far, we have only discussed foreign code as pieces of code loaded
into a Prolog executable. This is often not the desired situation.
Instead, one often wants to create "stand-alone executables", i.e. an
application where Prolog is used as a component, accessed through the
API described in the previous sections.

* Menu:

* Runtime Systems:: Runtime Systems
* Runtime Systems on Target Machines:: Runtime Systems on Target Machines
* The Application Builder:: The Application Builder
* User-defined Main Programs:: User-defined Main Programs
* Generic Runtime Systems under Windows:: Generic Runtime Systems under Windows


File: sicstus.info,  Node: Runtime Systems,  Next: Runtime Systems on Target Machines,  Up: Stand-Alone Executables

6.7.1 Runtime Systems
---------------------

Stand-alone applications containing debugged Prolog code and destined
for end-users are typically packaged as runtime systems.  No SICStus
license is needed by a runtime system.  A runtime system has the
following limitations:

   * No top-level.  The executable will restore a saved-state and/or
     load code, and call `user:runtime_entry(start)'.  Alternatively,
     you may supply a main program and explicitly initialize the Prolog
     engine with `SP_initialize()'.  `break/0' and `require/1' are
     unavailable.

   * No debugger.  The Prolog flags `debug' and
     `debugger_print_options' have no effect.  Predicates annotated as
     "[development]" in the reference pages are unavailable.  

   * Except in extended runtime systems: no compiler; compiling is
     replaced by consulting.  Extended runtime system contains the
     compiler.

   * The Prolog flags `discontiguous_warnings', `redefine_warnings',
     `single_var_warnings' have no effect.  The user is not prompted in
     the event of name clashes.  

   * The `informational' Prolog flag is off by default, suppressing
     informational messages.

   * No profiler.  The predicates `profile_data/4' and
     `profile_reset/1' are unavailable.

   * No signal handling except as installed by `SP_signal()'.


File: sicstus.info,  Node: Runtime Systems on Target Machines,  Next: The Application Builder,  Prev: Runtime Systems,  Up: Stand-Alone Executables

6.7.2 Runtime Systems on Target Machines
----------------------------------------

When a runtime system is delivered to the end user, chances are that
the user does not have an existing SICStus installation. To deliver
such an executable, you need:

the executable
     This is your executable program, usually created by `spld' (*note
     The Application Builder::).

the runtime kernel
     This is a shared object or a DLL, usually
     `$SP_PATH/../libsprt4-0-2.so' under UNIX, or
     `%SP_PATH%\..\sprt4-0-2.dll' under Windows.

the (extended) runtime library
     The saved-state `$SP_PATH/bin/sprt.sav' contains the built-in
     predicates written in Prolog.  It is restored into the program at
     runtime by the function `SP_initialize()'.  Extended runtime
     systems restore `$SP_PATH/bin/spre.sav' instead, available from
     SICS as an add-on product.

your Prolog code
     As a saved-state, `.po' files, or source code (`.pl' files).  They
     must be explicitly loaded by the program at runtime (*note Loading
     Prolog Code::).

your linked foreign resources
     Any dynamically linked foreign resources, including any linked
     foreign resources for library modules located in
     `$SP_PATH/library'.

   The following two sections describe how to package the above
components for UNIX and Windows "target machines", i.e. machines that
do not have SICStus Prolog installed, respectively.  It is also
possible to package all the above components into a single executable
file, an all-in-one executable. *Note All-in-one Executables::.

* Menu:

* Runtime Systems on UNIX Target Machines:: Runtime Systems on UNIX Target Machines
* Runtime Systems on Windows Target Machines:: Runtime Systems on Windows Target Machines


File: sicstus.info,  Node: Runtime Systems on UNIX Target Machines,  Next: Runtime Systems on Windows Target Machines,  Up: Runtime Systems on Target Machines

6.7.2.1 Runtime Systems on UNIX Target Machines
...............................................

In order to build a runtime system for distribution on a target machine,
the option `--moveable' must be passed to `spld'. This option prevents
`spld' from hardcoding any (absolute) paths into the executable.

   Next, in order for SICStus to be able to locate all relevant files,
the following directory structure should be used.

     myapp.exe
     sp-4.0.2/
     +--- libsprt4-0-2.so
     +--- sicstus-4.0.2/
          +--- bin/
          |    +--- sprt.sav
          +--- library/
               +--- <files from $SP_PATH/library>
If support for multiple SICStus instances is needed, the run-times
named e.g. `libsprt4-0-2_instance_01_.so' need to be available as well,
in the same place as `libsprt4-0-2.so'.

   If SICStus Prolog is installed on the target machine, a symbolic
link named `sp-4.0.2' can be used, in which case it should point to the
directory of the SICStus installation that contains the
`libsprt4-0-2.so' (or equivalent).

   `myapp.exe' is typically created by a call to `spld':

     % spld --main=user --moveable [...] -o ./myapp.exe

   On most platforms, the above directory layout will enable the
executable to find the SICStus run-time (e.q., `libsprt4-0-2.so') as
well as the boot file `sprt.sav' (`spre.sav'). In addition, application
specific files, e.g. a `.sav' file, can be found using the
automatically set environment variables `SP_APP_DIR' or `SP_RT_DIR'. On
some platforms a wrapper script, generated by `spld', is needed to
ensure that the files are found.

   On some platforms, the executable will not be able to locate
`sprt.sav' (`spre.sav') unless the environment variable `SP_PATH' is
set.  If the example above is rooted in `/home/joe', `SP_PATH' should
be set to `/home/joe/lib/sicstus-4.0.2'. This is not needed on
platforms where `SP_APP_DIR' or `SP_RT_DIR' can be used, e.g. on Linux,
Solaris or Win32 and most others.

   Unless the `--static' option is passed to `spld', it might also be
necessary to set `LD_LIBRARY_PATH' (or equivalent) to `/home/joe/lib'
(in the example above) in order for the dynamic linker to find
`libsprt4-0-2.so'. If the `--static' option is used, this is not
necessary. Setting `LD_LIBRARY_PATH' is not needed, nor recommended, on
Linux and Solaris (and Win32).

   When a runtime system is redistributed to third parties, only the
following files may be included in the distribution.  All filenames are
relative to `<prefix>/lib/sicstus-4.0.2':

`../*.{a,so,sl,dylib}'

`bin/sprt.sav'

`bin/spre.sav'

`bin/prologbeans.jar'

`library/*.{tcl,po,pl}'
     Except `license.pl'!

`library/*/*.{s.o,so,sl,dylib}'

`library/*/*.{po,pl}'

`sp_platform'
     (Located with `InstallSICStus')


File: sicstus.info,  Node: Runtime Systems on Windows Target Machines,  Prev: Runtime Systems on UNIX Target Machines,  Up: Runtime Systems on Target Machines

6.7.2.2 Runtime Systems on Windows Target Machines
..................................................

In order to locate all relevant files, the following directory structure
should be used.

     myapp.exe
     sprt4-0-2.dll
     sp-4.0.2\
     +--- bin\
     |    +--- sprt.sav
     +--- library\
          +--- <files from %SP_PATH%\library>

   If support for multiple SICStus instances is needed, the run-times
named e.g. `sprt4-0-2_instance_01_.dll' need to be available as well,
in the same place as `sprt4-0-2.dll'.

   `myapp.exe' is typically created by a call to `spld':

     % spld --main=user [...] -o ./myapp.exe

   If the directory containing `sprt4-0-2.dll' contains a directory
called `sp-4.0.2', SICStus assumes that it is part of a runtime system
as described in the picture below. The (extended) runtime library,
`sprt.sav' (`spre.sav'), is then looked up in the directory
(`sp-4.0.2/bin'), as in the picture. Furthermore, the initial
`library_directory/1' fact will be set to the same directory with
`sp-4.0.2/library' appended.

   The directory structure under `library/' should look like in a
regularly installed SICStus, including the platform-specific
subdirectory (`x86-win32-nt-4' in this case). If your application needs
to use `library(system)' and `library(random)', your directory
structure may look like:

     myapp.exe
     sprt4-0-2.dll
     sp-4.0.2\
     +--- bin\
     |    +--- sprt.sav
     +--- library\
          +--- random.po
          +--- system.po
          +--- x86-win32-nt-4 \
               +--- random.dll
               +--- system.dll

   The `sp*' files can also be put somewhere else in order to be shared
by several applications provided the `sprt4-0-2.dll' can be located by
the DLL search.

   Naming the files with version number enables applications using
different SICStus versions to install the `sp*' files in the same
directory.

   When a runtime system is redistributed to third parties, only the
following files may be included in the distribution.  All filenames are
relative to `%SP_PATH%':

`bin\sprt.sav'

`bin\spre.sav'

`bin\prologbeans.jar'

`bin\*.dll'

`bin\*.po'

`library\*.{tcl,po,pl,bas}'
     Except `license.pl'!

`library\*\*.dll'

`library\*\*.{po,pl}'


File: sicstus.info,  Node: The Application Builder,  Next: User-defined Main Programs,  Prev: Runtime Systems on Target Machines,  Up: Stand-Alone Executables

6.7.3 The Application Builder
-----------------------------

* Menu:

* Customizing spld:: Customizing `spld' under UNIX
* All-in-one Executables:: All-in-one Executables
* spld Examples:: Examples

   The application builder, `spld', is used for creating stand-alone
executables.  `spld' takes the files specified on the command line and
combines them into an executable file, much like the UNIX `ld' or the
Windows `link' commands.

   Note that no pathnames passed to `spld' should contain spaces.
Under Windows, this can be avoided by using the short version of
pathnames as necessary.


File: sicstus.info,  Node: Customizing spld,  Next: All-in-one Executables,  Up: The Application Builder

6.7.3.1 Customizing `spld' under UNIX
.....................................

The `spld' tool is implemented as a Perl script and can be customized
in order to adapt to local variations. _Do not attempt this unless you
know what you are doing_.  Customization is done by editing their
common configuration file `spconfig-VERSION'. Follow these instructions:

  1. Locate the configuration file `spconfig-VERSION'. It should be
     located in the same directory as `spld'.

  2. Make a copy for `spconfig-VERSION'; let's call it
     `hacked_spld.config'. Do not edit the original file.

  3. The configuration file contains lines on the form `CFLAGS=-g -O2'.
     Edit these according to your needs. Do not add or remove any
     options.

  4. You may now use the modified `spconfig-VERSION' together with
     `spld' like this:
          % spld [...] --config=/path/to/hacked_spld.config

  5. Replace `/path/to' with the actual path to the hacked configuration
     file.


File: sicstus.info,  Node: All-in-one Executables,  Next: spld Examples,  Prev: Customizing spld,  Up: The Application Builder

6.7.3.2 All-in-one Executables
..............................

It is possible to embed saved-states into an executable. Together with
static linking, this gives an all-in-one executable, an executable that
does not depend on external SICStus files.

   In the simplest case, creating an all-in-one executable `main.exe'
from a saved state `main.sav' can be done with a command like
     % spld --output=main.exe --static main.sav

   This will automatically embed the saved state, any foreign resources
needed by the saved state as well the SICStus run-time and its run-time
saved state.

   The keys to this feature are:
   * Static linking. By linking an application with a static version of
     the SICStus run-time, you avoid any dependency on e.g.
     `sprt4-0-2.dll' (Windows) or `libsprt4-0-2.so' (UNIX). Note that,
     as of SICStus 3.9, static linking is supported under Windows.

     If the application needs foreign resources (predicates written in
     C code), as used for example by `library(system)' and
     `library(clpfd)', these foreign resources can be linked statically
     with the application as well.

     The remaining component is the Prolog code itself; see the next
     item.

   * Data Resources (in-memory files). It is possible to link an
     application with data resources that can be read directly from
     memory. In particular, saved-states can be embedded in an
     application and used when restoring the saved-state of the
     application.

     An application needs two saved-states:
       1. The SICStus run-time system (`sprt.sav').

          This is added automatically when `spld' is invoked with the
          `--static' (or `-S') option unless the `spld'-option
          `--no-embed-rt-sav' is specified. It can also be added
          explicitly with the option `--embed-rt-sav'.

       2. The user written code of the application as well as any
          SICStus libraries.

          This saved-state is typically created by loading all
          application code using `compile/1' and then creating the
          saved-state with `save_program/2'.



   Data resources are added by specifying their internal name and the
path to a file as part of the comma separated list of resources passed
with the `spld' option `--resources'. Each data resource is specified
as FILE=NAME where FILE is the path to the file containing the data (it
must exist during the call to `spld') and NAME is the name used to
access the content of FILE during run-time. A typical choice of NAME
would be the base name, i.e. without directories, of FILE, preceded by
a slash (`/').  NAME should begin with a slash (`/') and look like an
ordinary lowercase file path made up of `/'-separated, non-empty, names
consisting of `a' to `z', underscore (`_', period (`.'), and digits.

   Typically, you would use `spld --main=restore', which will
automatically restore the first `.sav' argument.  To manually restore
an embedded saved-state you should use the syntax
`URL:x-sicstus-resource:NAME', e.g.
`SP_restore("URL:x-sicstus-resource:/main.sav")'.

   An example will make this clearer. Suppose we create a run-time
system that consists of a single file `main.pl' that looks like:
                                                            _% main.pl_
     :- use_module(library(system)).
     :- use_module(library(clpfd)).

     % This will be called when the application starts:
     user:runtime_entry(start) :-
        %% You may consider putting some other code here...
        write('hello world'),nl,
        write('Getting date:'),nl,
        datime(Date),             % from system
        write(Date),nl,
        ( all_different([3,9]) ->        % from clpfd
            write('3 != 9'),nl
        ; otherwise ->
            write('3 = 9!?'),nl
        ).

   Then create the saved-state `main.sav', which will contain the
compiled code of `main.pl' as well as the Prolog code of
`library(system)' and `library(clpfd)' and other Prolog libraries
needed by `library(clpfd)'.

     % sicstus -i -f
     SICStus 4.0.2 ...
     Licensed to SICS
     | ?- compile(main).
     % compiling .../main.pl...
     % ... loading several library modules
     | ?- save_program('main.sav').
     % .../main.sav created in 201 msec

     | ?- halt.

   Finally, tell `spld' to build an executable statically linked with
the SICStus run-time and the foreign resources needed by
`library(system)' and `library(clpfd)'. Also, embed the Prolog run-time
saved-state and the application specific saved-state just created. Note
that the `random' foreign resource is needed since it is used by
`library(clpfd)'.

   As noted above, it is possible to build the all-in-one executable
with the command line
     % spld --output=main.exe --static main.sav
but for completeness the example below uses all options as if no
options were added automatically.

   The example is using Cygwin `bash' (`http://www.cygwin.com') under
Windows but would look much the same on other platforms. The command
should be given on a single line; it is broken up here for better
layout.

     % spld
       --output=main.exe
       --static
       --embed-rt-sav
       --main=restore
       --resources=main.sav=/main.sav,clpfd,system,random

   The arguments are as follows:
`--output=main.exe'
     This tells `spld' where to put the resulting executable.

`--static'
     Link statically with the SICStus run-time and foreign resources
     (`system' and `clpfd' in this case).

`--embed-rt-sav'
     This option embeds the SICStus run-time `.sav' file (`sprt.sav').
     This option is not needed since it is added automatically by
     `--static'.

`--main=restore'
     Start the application by restoring the saved-state and calling
     `user:runtime_entry(start)'. This is not strictly needed in the
     above example since it is the default if any file with extension
     `.sav' or a data resource with a _name_ where the extension is
     `.sav' is specified.

`--resources=...'
     This is followed by comma-separated resource specifications:

    `main.sav=/main.sav'
          This tells `spld' to make the content (at the time `spld' is
          invoked) of the file `main.sav' available at run-time in a
          data resource named `/main.sav'.  That is, the data resource
          name corresponding to `"URL:x-sicstus-resource:/main.sav"'.

          Alternatively, `spld' can create a default data resource
          specification when passed a `.sav' file argument and the
          option `--embed-sav-file' (which is the default with
          `--static').

    `clpfd'
    `system'
    `random'
          These tell `spld' to link with the foreign resources (that
          is, C-code) associated with `library(system)',
          `library(clpfd)' and `library(random)'.  Since `--static' was
          specified the static versions of these foreign resources will
          be used.

          Alternatively, `spld' can extract the information about the
          required foreign resources from the saved-state (`main.sav').
          This feature is enabled by adding the option
          `--resources-from-sav' (which is the default with
          `--static'). Using `--resources-from-sav' instead of an
          explicit list of foreign resources is preferred since it is
          hard to know what foreign resources are used by the SICStus
          libraries.


     Since both `--embed-sav-file' and `--resources-from-sav' are the
     default when `--static' is used the example can be built simply by
     doing
          % spld --output=main.exe --static main.sav


   Finally, we may run this executable on any machine, even if SICStus
is not installed:

     bash-2.04$ ./main.exe
     hello world
     Getting date:
     datime(2006,4,21,1,4,55)
     3 != 9
     bash-2.04$


File: sicstus.info,  Node: spld Examples,  Prev: All-in-one Executables,  Up: The Application Builder

6.7.3.3 Examples
................

  1. The character-based SICStus development system executable
     (`sicstus') can be created using

          % spld --main=prolog -o sicstus

     This will create a development system that is dynamically linked
     and has no pre-linked foreign resources.

  2.      % spld --static -D --resources=random -o main -ltk8.0 -ltcl8.0

     This will create a statically linked executable called `main' that
     has the resource `random' pre-linked (statically). The linker will
     receive `-ltk8.0 -ltcl8.0', which will work under UNIX (if Tcl/Tk
     is installed correctly) but will probably fail under Windows.

  3. An all-in-one executable with a home-built foreign resource.

     This example is similar to the example in *Note All-in-one
     Executables::, with the addition of a foreign resource of our own.

                                                             _% foo.pl_
          :- use_module(library(system)).
          :- use_module(library(clpfd)).

          :- load_foreign_resource(bar).

          % This will be called when the application starts:
          user:runtime_entry(start) :-
             %% You may consider putting some other code here...
             write('hello world'),nl,
             write('Getting date:'),nl,
             datime(Date),             % from system
             write(Date),nl,
             ( all_different([3,9]) ->        % from clpfd
                 write('3 != 9'),nl
             ; otherwise ->
                 write('3 = 9!?'),nl
             ),
             '$pint'(4711).                   % from our own foreign resource 'bar'

                                                             _% bar.pl_
          foreign(print_int, '$pint'(+integer)).
          foreign_resource(bar, [print_int]).

                                                          _/* bar.c */_
          #include <sicstus/sicstus.h>
          #include <stdio.h>
          #include "bar_glue.h"

          extern void print_int(long a);

          void print_int(long a)
          {
            printf("a=%lu\n", a);
          }

     To create the saved-state `foo.sav' we will compile the file
     `foo.pl' and save it with `save_program('foo.sav').' When
     compiling the file the directive `:- load_foreign_resource(bar).'
     is called so a dynamic foreign resource must be present.

     Thus, first we build a dynamic foreign resource.

          % splfr bar.c bar.pl

     Then we create the saved-state.

          % sicstus --goal "compile(foo), save_program('foo.sav'), halt."

     We also need a static foreign resource to embed in our all-in-one
     executable.

          % splfr --static bar.c bar.pl

     Lastly we build the all-in-one executable with `spld'. We do not
     need to list the foreign resources needed. `spld' will extract
     their names from the `.sav' file. Adding the `--verbose' option
     will make `spld' output lots of progress information, among which
     are the names of the foreign resources that are needed. Look for
     "Found resource name" in the output.

          % spld --verbose --static --main=restore --respath=. --resources=foo.sav=/mystuff/foo.sav --output=foo

     In this case four foreign resource names are extracted from the
     `.sav' file: `bar', `clpfd', `random' and `system'. The source
     file `foo.pl' loads the foreign resource named `bar'.  It also
     uses `library(system)' module, which loads the foreign resource
     named `system', and `library(clpfd)' module, which loads the
     foreign resources named `clpfd' and `random'.

     By not listing foreign resources when running `spld', we avoid the
     risk of omitting a required resource.



File: sicstus.info,  Node: User-defined Main Programs,  Next: Generic Runtime Systems under Windows,  Prev: The Application Builder,  Up: Stand-Alone Executables

6.7.4 User-defined Main Programs
--------------------------------

Runtime systems may or may not have an automatically generated main
program.  This is controlled by the `--main' option to `spld'.  If
`--main=user' is given, a function `user_main()' must be supplied:

     int user_main(int argc, char *argv[])

   `user_main()' is responsible for initializing the Prolog engine,
loading code, and issuing any Prolog queries. An alternative is to use
`--main=none' and write your own `main()' function.

* Menu:

* Initializing the Prolog Engine:: Initializing the Prolog Engine
* Loading Prolog Code:: Loading Prolog Code


File: sicstus.info,  Node: Initializing the Prolog Engine,  Next: Loading Prolog Code,  Up: User-defined Main Programs

6.7.4.1 Initializing the Prolog Engine
......................................

The Prolog Engine is initialized by calling `SP_initialize()'. This
must be done before any interface functions are called, except those
marked `preinit' in this manual.

   The function will allocate data areas used by Prolog, initialize
command line arguments so that they can be accessed by the `argv'
Prolog flag, and load the Runtime Library.  

   To unload the SICStus emulator, `SP_deinitalize()' can be called.  

   You may also call `SP_force_interactive()' before calling
`SP_initialize()'.  This will force the I/O built-in predicates to
treat the standard input stream as a terminal, even if it does not
appear to be a terminal.  Same as the `-i' option in development
systems (*note Start::).

   You may also call `SP_set_memalloc_hooks()' before calling
`SP_initialize()'.  This will define one layer of Prolog's memory
manager, in case your application has special requirements.

   The SICStus Prolog memory manager has a two-layer structure.  The top
layer has roughly the same functionality as the standard UNIX functions
`malloc' and `free', whereas the bottom layer is an interface to the
operating system.  It's the bottom layer that can be customized by
setting these hooks.


File: sicstus.info,  Node: Loading Prolog Code,  Prev: Initializing the Prolog Engine,  Up: User-defined Main Programs

6.7.4.2 Loading Prolog Code
...........................

You can load your Prolog code with the call `SP_load()'.  This is the C
equivalent of the Prolog predicate `load_files/1'.  

   Alternatively, you can restore a saved-state with the call
`SP_restore()', which is the C equivalent of the Prolog predicate
`restore/1'.  


File: sicstus.info,  Node: Generic Runtime Systems under Windows,  Prev: User-defined Main Programs,  Up: Stand-Alone Executables

6.7.5 Generic Runtime Systems under Windows
-------------------------------------------

There are three ready-made runtime systems provided with the
distributions, `%SP_PATH%\bin\sprt.exe', `%SP_PATH%\bin\sprtw.exe', and
`%SP_PATH%\bin\sprti.exe'. These have been created using `spld':

     % spld --main=restore '$SP_APP_DIR/main.sav' -o sprt.exe
     % spld --main=restore '$SP_APP_DIR/main.sav' -i -o sprti.exe
     % spld --main=restore '$SP_APP_DIR/main.sav' --window -o sprtw.exe

   These are provided for users who do not have a C-compiler available.
Each program launches a runtime system by restoring the saved-state
`main.sav' (located in the same folder as the program).

   The saved-state is created by `save_program/[1,2]'.  If it was
created by `save_program/2', the given startup goal is run.  Then,
`user:runtime_entry(start)' is run.  The program exits with 0 upon
normal temination and with 1 on failure or exception.

   The program `sprti' assumes that the standard streams are connected
to a terminal, even if they do not seem to be (useful under Emacs, for
example). `sprtw' is a windowed executable, corresponding to `spwin'.


File: sicstus.info,  Node: Mixing Examples,  Prev: Stand-Alone Executables,  Up: Mixing C and Prolog

6.8 Examples
============

* Menu:

* Train Example:: Train Example (connections)
* Exceptions from C:: Exceptions from C
* Stream Example:: Stream Example


File: sicstus.info,  Node: Train Example,  Next: Exceptions from C,  Up: Mixing Examples

6.8.1 Train Example (connections)
---------------------------------

This is an example of how to create a runtime system.  The Prolog
program `train.pl' will display a route from one train station to
another.  The C program `train.c' calls the Prolog code and writes out
all the routes found between two stations:

                                                           _% train.pl_
     connected(From, From, [From], _):- !.
     connected(From, To, [From| Way], Been):-
             (   no_stop(From, Through)
             ;
                 no_stop(Through, From)
             ),
             not_been_before(Been, Through),
             connected(Through, To, Way, Been).

     no_stop('Stockholm', 'Katrineholm').
     no_stop('Stockholm', 'Vasteras').
     no_stop('Katrineholm', 'Hallsberg').
     no_stop('Katrineholm', 'Linkoping').
     no_stop('Hallsberg', 'Kumla').
     no_stop('Hallsberg', 'Goteborg').
     no_stop('Orebro', 'Vasteras').
     no_stop('Orebro', 'Kumla').

     not_been_before(Way, _) :- var(Way),!.
     not_been_before([Been| Way], Am) :-
             Been \== Am,
             not_been_before(Way, Am).

                                                        _/* train.c */_
     #include <stdio.h>
     #include <sicstus/sicstus.h>

     void write_path(SP_term_ref path)
     {
       char *text = NULL;
       SP_term_ref
         tail = SP_new_term_ref(),
         via = SP_new_term_ref();

       SP_put_term(tail,path);

       while (SP_get_list(tail,via,tail))
       {
         if (text)
           printf(" -> ");

         SP_get_string(via, &text);
         printf("%s",text);
       }
       printf("\n");
     }

     int user_main(int argc, char **argv)
     {
       int rval;
       SP_pred_ref pred;
       SP_qid goal;
       SP_term_ref from, to, path;

       /* Initialize Prolog engine. The third arg to SP_initialize is
          reserved and should always be NULL */
       if (SP_FAILURE == SP_initialize(argc, argv, NULL))
         {
           fprintf(stderr, "SP_initialize failed: %s\n",
                   SP_error_message(SP_errno));
           exit(1);
         }

       rval = SP_restore("train.sav");

       if (rval == SP_ERROR || rval == SP_FAILURE)
         {
           fprintf(stderr, "Could not restore \"train.sav\".\n");
           exit(1);
         }

                                                        _/* train.c */_
       /* Look up connected/4. */
       if (!(pred = SP_predicate("connected",4,"user")))
         {
           fprintf(stderr, "Could not find connected/4.\n");
           exit(1);
         }

       /* Create the three arguments to connected/4. */
       SP_put_string(from = SP_new_term_ref(), "Stockholm");
       SP_put_string(to = SP_new_term_ref(), "Orebro");
       SP_put_variable(path = SP_new_term_ref());

       /* Open the query. In a development system, the query would look like:
        *
        * | ?- connected('Stockholm','Orebro',X).
        */
       if (!(goal = SP_open_query(pred,from,to,path,path)))
         {
           fprintf(stderr, "Failed to open query.\n");
           exit(1);
         }

       /*
        * Loop through all the solutions.
        */
       while (SP_next_solution(goal)==SP_SUCCESS)
         {
           printf("Path: ");
           write_path(path);
         }

       SP_close_query(goal);

       exit(0);
     }

   Create the saved-state containing the Prolog code:
     % sicstus
     SICStus 4.0.2 ...
     Licensed to SICS
     | ?- compile(train),save_program('train.sav').
     % compiling [...]/train.pl...
     % compiled [...]/train.pl in module user, 10 msec 2848 bytes
     % [...]/train.sav created in 0 msec

     | ?- halt.

   Create the executable using the application builder:

     % spld --main=user train.c -o train.exe

   And finally, run the executable:

     % ./train
     Path: Stockholm -> Katrineholm -> Hallsberg -> Kumla -> Orebro
     Path: Stockholm -> Vasteras -> Orebro


File: sicstus.info,  Node: Exceptions from C,  Next: Stream Example,  Prev: Train Example,  Up: Mixing Examples

6.8.2 Exceptions from C
-----------------------

Consider, for example, a function returning the square root of its
argument after checking that the argument is valid.  If the argument is
invalid, the function should raise an exception instead.

                                                         _/* math.c */_
     #include <math.h>
     #include <stdio.h>
     #include <sicstus/sicstus.h>

     extern double sqrt_check(double d);
     double sqrt_check(double d)
     {
       if (d < 0.0)
         {    /* build a domain_error/4 exception term */
           SP_term_ref culprit=SP_new_term_ref();
           SP_term_ref argno=SP_new_term_ref();
           SP_term_ref expdomain=SP_new_term_ref();
           SP_term_ref t1=SP_new_term_ref();

           SP_put_float(culprit, d);
           SP_put_integer(argno, 1);
           SP_put_string(expdomain, ">=0.0");
           SP_cons_functor(t1, SP_atom_from_string("sqrt"), 1, culprit);
           SP_cons_functor(t1, SP_atom_from_string("domain_error"), 4,
                           t1, argno, expdomain, culprit);
           SP_raise_exception(t1);    /* raise the exception */
           return 0.0;
         }
       return sqrt(d);
     }

   The Prolog interface to this function is defined in a file
`math.pl'.  The function uses the `sqrt()' library function, and so the
math library `-lm' has to be included:

                                                            _% math.pl_
     foreign_resource(math, [sqrt_check]).

     foreign(sqrt_check, c, sqrt(+float, [-float])).

     :- load_foreign_resource(math).

   A linked foreign resource is created:
     % splfr math.pl math.c -lm

   A simple session using this function could be:

     % sicstus
     SICStus 4.0.2 ...
     Licensed to SICS
     | ?- [math].
     % compiling /home/san/pl/math.pl...
     % /home/san/pl/math.pl compiled, 10 msec 816 bytes

     | ?- sqrt(5.0,X).

     X = 2.23606797749979

     | ?- sqrt(a,X).
     ! Type error in argument 1 of user:sqrt/2
     ! number expected, but a found
     ! goal:  sqrt(a,_143)

     | ?- sqrt(-5,X).
     ! Domain error in argument 1 of user:sqrt/1
     ! expected '>=0.0', found -5.0
     ! goal:  sqrt(-5.0)

   The above example used the foreign language interface with dynamic
linking.  To statically link `math.s.o' with the Prolog emulator, the
following steps would have been taken:

     % splfr -S math.pl math.c -lm
     SICStus 4.0.2 ...
     Licensed to SICS
     % spXxQwsr.c generated, 0 msec

     % spld -D -o mathsp --resources=./math.s.o
     SICStus 4.0.2 ...
     Licensed to SICS
     % spYdLTgi1.c generated, 0 msec

     Created "mathsp"
     % ./mathsp
     SICStus 4.0.2 ...
     Licensed to SICS
     | ?- [math].
     % compiling /a/filur/export/labs/isl/sicstus/jojo/sicstus38p/math.pl...
     % compiled /a/filur/export/labs/isl/sicstus/jojo/sicstus38p/math.pl in module user, 0 msec 960 bytes

     | ?- sqrt(5.0,X).

     X = 2.23606797749979


File: sicstus.info,  Node: Stream Example,  Prev: Exceptions from C,  Up: Mixing Examples

6.8.3 Stream Example
--------------------

`library(codesio)' implements a stream that can return a list of all
characters written to it. The source code for this library is located
in `library/codesio.pl' and `library/codesio.c' and can serve as a
useful sample for user defined streams both for input and output. That
code also illustrates other important features of user defined streams,
for instance ensuring that all the streams has been closed when the
foreign resource is unloaded.


File: sicstus.info,  Node: Interfacing .NET and Java,  Next: Multiple SICStus Run-Times,  Prev: Mixing C and Prolog,  Up: Top

7 Interfacing .NET and Java
***************************

SICStus Prolog provides a uniform way of interfacing to Java and .NET
clients via the "PrologBeans" (*note lib-prologbeans::) interface.
This is a loosely coupled interface, which means that the client code
runs in a different process from the Prolog code. In fact, the client
program and the Prolog program can run on separate machines, since the
communication is done via TCP/IP sockets. This design has the following
advantages over a tightly coupled interface, where they run in the same
process:

   * There is no competition for memory or other process-wide resources
     between the virtual machines of the client (.NET or JVM) and of
     Prolog.

   * Distribution over a network is trivial when using PrologBeans. The
     application is distributable from the beginning.

   * PrologBeans has support for user session handling both at the Java
     level (with support for HTTP sessions and JNDI lookup) and at the
     Prolog level. This makes it easy to integrate Prolog applications
     into applications based on Java servers.

   The main limitation of the design is that callbacks from Prolog to
the client is not provided for.


File: sicstus.info,  Node: Multiple SICStus Run-Times,  Next: Writing Efficient Programs,  Prev: Interfacing .NET and Java,  Up: Top

8 Multiple SICStus Run-Times in a Process
*****************************************

* Menu:

* Memory Considerations:: Memory Considerations
* Multiple SICStus Run-Times in C:: Multiple SICStus Run-Times in C
* Foreign Resources and Multiple SICStus Run-Times:: Foreign Resources and Multiple SICStus Run-Times
* Threads:: Multiple Run-Times and Threads

   It is possible to have more than one SICStus run-time in a single
process. These are completely independent (except that they dynamically
load the same foreign resources; see *Note Foreign Resources and
Multiple SICStus Run-Times::).

   Even though the SICStus run-time can only be run in a single thread,
it is now possible to start several SICStus run-times, optionally each
in its own thread.

   SICStus run-times are rather heavy weight and you should not expect
to be able to run more than a handful.


File: sicstus.info,  Node: Memory Considerations,  Next: Multiple SICStus Run-Times in C,  Up: Multiple SICStus Run-Times

8.1 Memory Considerations
=========================

The most pressing restriction when using more than one SICStus run-time
in a process is that (on 32bit machines) all these run-times must
compete for the the _address-constrained_ range of virtual memory,
typically the lower 256MB of memory.

   This is worsened by the fact that, on some platforms, each SICStus
run-time will attempt to grow its memory area as needed, leading to
fragmentation. A fix that removes the restriction on useable memory is
planned for a later release.

   One way to avoid the fragmentation issue to some extent is to make
each SICStus run-time preallocate a large enough memory area so it will
not have to grow during run-time. This can be effected by setting the
environment variables `GLOBALSTKSIZE', `PROLOGINITSIZE' and
`PROLOGMAXSIZE'.

   On some platforms, currently `Linux' and Windows, the default bottom
memory manager layer will pre-allocate as large a chunk of
_address-constrained_ memory as possible when the SICStus run-time is
initialized. In order to use more than one run-time you therefore
should set the environment variable `PROLOGMAXSIZE' to limit this
greedy pre-allocation.

     bash> GLOBALSTKSIZE=10MB; export GLOBALSTKSIZE;
     bash> PROLOGINITSIZE=20MB; export PROLOGINITSIZE;
     bash> PROLOGMAXSIZE=30MB; export PROLOGMAXSIZE;

   You can use `statistics/2' to try to determine suitable values for
thes, but it is bound to be a trial-and-error process.


File: sicstus.info,  Node: Multiple SICStus Run-Times in C,  Next: Foreign Resources and Multiple SICStus Run-Times,  Prev: Memory Considerations,  Up: Multiple SICStus Run-Times

8.2 Multiple SICStus Run-Times in C
===================================

Unless otherwise noted, this section documents the behavior when using
dynamic linking to access a SICStus run-time.

   The key implementation feature that makes it possible to use multiple
run-times is that all calls from C to the SICStus API (`SP_query()',
etc.) go through a dispatch vector. Two run-times can be loaded at the
same time since their APIs are accessed through different dispatch
vectors.

   By default, there will be a single dispatch vector, referenced from a
global variable (`sp_GlobalSICStus'). A SICStus API functions, such as
`SP_query()', is then defined as a macro that expands to something
similar to `sp_GlobalSICStus->SP_query_pointer'.  The name of the
global dispatch vector is subject to change without notice; it should
not be referenced directly. If you need to access the dispatch vector,
use the C macro `SICStusDISPATCHVAR' instead; see below.

* Menu:

* MT Single:: Using a Single SICStus Run-Time
* MT Multiple:: Using More than One SICStus Run-Time


File: sicstus.info,  Node: MT Single,  Next: MT Multiple,  Up: Multiple SICStus Run-Times in C

8.2.1 Using a Single SICStus Run-Time
-------------------------------------

When building an application with `spld', by default only one SICStus
run-time can be loaded in the process. This is similar to the case in
SICStus versions prior to 3.9. For most applications built with `spld',
the changes necessary to support multiple SICStus run-times should be
invisible, and old code should only need to be rebuilt with `spld'.

   In order to maintain backward compatibility, the global dispatch
vector is automatically set up by `SP_initialize()'. Other SICStus API
functions will not set up the dispatch vector, and will therefore lead
to memory access errors if called before `SP_initialize()'. Currently,
hook functions such as `SP_set_memalloc_hooks()' also set up the
dispatch vector to allow them to be called before `SP_initialize()'.
However, only `SP_initialize()' is guaranteed to set up the dispatch
vector. The hook installation functions may change to use a different
mechanism in the future. The SICStus API functions that perform
automatic setup of the dispatch vector are marked with
`SPEXPFLAG_PREINIT' in `sicstus.h'.


File: sicstus.info,  Node: MT Multiple,  Prev: MT Single,  Up: Multiple SICStus Run-Times in C

8.2.2 Using More than One SICStus Run-Time
------------------------------------------

Using more than one SICStus run-time in a process is only supported when
the dynamic library version of the SICStus run-time is used (e.g,
`sprt4-0-2.dll', `libsprt4-0-2.so').

   An application that wants to use more than one SICStus run-time
needs to be built using the `--multi-sp-aware' option to `spld'. C-code
compiled by `spld --multi-sp-aware' will have the C preprocessor macro
`MULTI_SP_AWARE' defined and non-zero.

   Unlike the single run-time case described above, an application built
with `--multi-sp-aware' will not have a global variable that holds the
dispatch vector. Instead, your code will have to take steps to ensure
that the appropriate dispatch vector is used when switching between
SICStus run-times.

   There are several steps needed to access a SICStus run-time from an
application built with `--multi-sp-aware'.

  1. You must obtain the dispatch vector of the initial SICStus run-time
     using `SP_get_dispatch()'. Note that this function is special in
     that it is not accessed through the dispatch vector; instead, it is
     exported in the ordinary manner from the SICStus run-time dynamic
     library (`sprt4-0-2.dll' under Windows and, typically,
     `libsprt4-0-2.so' under UNIX).

  2. You must ensure that `SICStusDISPATCHVAR' expands to something
     that references the dispatch vector obtained in step 1.

     The C pre-processor macro `SICStusDISPATCHVAR' should expand to a
     `SICSTUS_API_STRUCT_TYPE *', that is, a pointer to the dispatch
     vector that should be used. When `--multi-sp-aware' is not used
     `SICStusDISPATCHVAR' expands to `sp_GlobalSICStus' as described
     above. When using `--multi-sp-aware' it is probably best to let
     `SICStusDISPATCHVAR' expand to a local variable.

  3. Once you have access to the SICStus API of the initial SICStus
     run-time you can call the SICStus API function
     `SP_load_sicstus_run_time()' to load additional run-times.


     SICSTUS_API_STRUCT_TYPE *SP_get_dispatch(void *reserved);

   `SP_get_dispatch()' returns the dispatch vector of the SICStus
run-time. The argument `reserved' should be `NULL'. This function can
be called from any thread.

     typedef SICSTUS_API_STRUCT_TYPE *SP_get_dispatch_type(void *);

     int SP_load_sicstus_run_time(SP_get_dispatch_type **ppfunc, void **phandle);

   `SP_load_sicstus_run_time()' loads a new SICStus run-time.
`SP_load_sicstus_run_time()' returns zero if a new run-time could not
be loaded. If a new run-time could be loaded a non-zero value is
returned and the address of the `SP_get_dispatch()' function of the
newly loaded SICStus run-time is stored at the address `ppfunc'. The
second argument, `phandle', is reserved and should be `NULL'.

   As a special case, if `SP_load_sicstus_run_time()' is called from a
SICStus run-time that has not been initialized (with `SP_initialize()')
and that has not previously been loaded as the result of calling
`SP_load_sicstus_run_time()', no new run-time is loaded. Instead, the
`SP_get_dispatch()' of the run-time itself is returned. In particular,
the first time `SP_load_sicstus_run_time()' is called on the initial
SICStus run-time, and if this happens before the initial SICStus
run-time is initialized, no new run-time is loaded.

   Calling `SP_load_sicstus_run_time()' from a particular run-time can
be done from any thread.

   An application that links statically with the SICStus run-time should
not call `SP_load_sicstus_run_time()'.

   You should not use pre-linked foreign resources when using multiple
SICStus run-times in the same process.


File: sicstus.info,  Node: Foreign Resources and Multiple SICStus Run-Times,  Next: Threads,  Prev: Multiple SICStus Run-Times in C,  Up: Multiple SICStus Run-Times

8.3 Foreign Resources and Multiple SICStus Run-Times
====================================================

Foreign resources access the SICStus C API in the same way as an
embedding application, that is, through a dispatch vector. As for
applications, the default and backward compatible mode is to only
support a single SICStus run-time.  An alternative mode makes it
possible for a foreign resource to be shared between several SICStus
run-times in the same process.

   Unless otherwise noted, this section documents the behavior when
using dynamically linked foreign resources. That is, shared objects
(.so-files) under UNIX, dynamic libraries (DLLs) under Windows.

* Menu:

* MT Foreign Single:: Foreign Resources Supporting Only One SICStus Run-Time
* MT Foreign Multiple:: Foreign Resources Supporting Multiple SICStus Run-Times


File: sicstus.info,  Node: MT Foreign Single,  Next: MT Foreign Multiple,  Up: Foreign Resources and Multiple SICStus Run-Times

8.3.1 Foreign Resources Supporting Only One SICStus Run-Time
------------------------------------------------------------

A process will only contain one instance of the code and data of a
(dynamic) foreign resource even if the foreign resource is loaded and
used from more than one SICStus run-time.

   This presents a problem in the likely event that the foreign
resource maintains some state, e.g. global variables, between
invocations of functions in the foreign resource. The global state will
probably need to be separate between SICStus run-times.  Requiring a
foreign resource to maintain its global state on a per SICStus run-time
basis would be an incompatible change. Instead, by default, only the
first SICStus run-time that loads a foreign resource will be allowed to
use it. If a subsequent SICStus run-time (in the same process) tries to
load the foreign resource, an error will be reported to the second
SICStus run-time.

   When `splfr' builds a foreign resource, it will also generate glue
code. When the foreign resource is loaded, the glue code will set up a
global variable pointing to the dispatch vector used in the foreign
resource to access the SICStus API. This is similar to how an embedding
application accesses the SICStus API.

   The glue code will also detect if a subsequent SICStus run-time in
the same process tries to initialize the foreign resource. In this
case, an error will be reported.

   This means that pre 3.9 foreign code should only need to be rebuilt
with `splfr' to work with the latest version of SICStus. However, a
recommended change is that all C files of a foreign resource include
the header file generated by `splfr'. Inclusion of this generated
header file may become mandatory in a future release.  *Note The
Foreign Resource Linker::.


File: sicstus.info,  Node: MT Foreign Multiple,  Prev: MT Foreign Single,  Up: Foreign Resources and Multiple SICStus Run-Times

8.3.2 Foreign Resources Supporting Multiple SICStus Run-Times
-------------------------------------------------------------

A foreign resource that wants to be shared between several SICStus
run-times must somehow know which SICStus run-time is calling it so that
it can make callbacks using the SICStus API into the right SICStus
run-time. In addition, the foreign resource may have global variables
that should have different values depending on which SICStus run-time
is calling the foreign resource.

   A header file is generated by `splfr' when it builds a foreign
resource (before any C code is compiled). This header file provides
prototypes for any `foreign'-declared function, but it also provides
other things needed for multiple SICStus run-time support. This header
file must be included by any C file that contains code that either
calls any SICStus API function or that contains any of the functions
called by SICStus.  *Note The Foreign Resource Linker::.

* Menu:

* MT Foreign Multiple Simple:: Simplified Support for Multiple SICStus Run-Times
* MT Foreign Multiple Full:: Full Support for Multiple SICStus Run-Times


File: sicstus.info,  Node: MT Foreign Multiple Simple,  Next: MT Foreign Multiple Full,  Up: MT Foreign Multiple

8.3.2.1 Simplified Support for Multiple SICStus Run-Times
.........................................................

To make it simpler to convert old foreign resources, there is an
intermediate level of support for multiple SICStus run-times. This level
of support makes it possible for several SICStus run-times to call the
foreign resource, but a mutual exclusion lock ensures that only one
SICStus run-time at a time can execute code in the foreign resource.
That is, the mutex is locked upon entry to any function in the foreign
resource and unlocked when the function returns. This makes it possible
to use a global variable to hold the SICStus dispatch vector, in much
the same way as is done when only a single SICStus run-time is
supported. In addition, a special hook function in the foreign resource
will be called every time the foreign resource is entered. This hook
function can then make arrangements to ensure that any global variables
are set up as appropriate.

   To build a foreign resource in this way, use
`splfr --exclusive-access'.  In addition to including the generated
header file, your code needs to define the context switch function. If
the resource is named RESNAME, the context switch hook should look like:

     void sp_context_switch_hook_RESNAME(int entering)

   The context switch hook will be called with the SICStus API dispatch
vector already set up, so calling any SICStus API function from the
context switch hook will work as expected. The argument `entering' will
be non-zero when a SICStus run-time is about to call a function in the
foreign resource. The hook will be called with `entering' zero when the
foreign function is about to return to SICStus.

   It is possible to specify a name for the context switch hook with
the `splfr' option `--context-hook=NAME'. If you do not require a
context switch hook you can specify the `splfr' option
`--no-context-hook'.

   Due to the use of mutual exclusion lock to protect the foreign
resource, there is a remote possibility of dead-lock. This would happen
if the foreign resource calls back to SICStus and then passes control
to a different SICStus run-time in the same thread, which then calls
the foreign resource.  For this reason it is best to avoid
`--exclusive-access' for foreign resources that makes call-backs into
Prolog.

   The new SICStus API function `SP_foreign_stash()' provides access to
a location where the foreign resource can store anything that is
specific to the calling SICStus run-time. The location is specific to
each foreign resource and each SICStus run-time. *Note OS Threads::.

   C code compiled by `splfr --exclusive-access' will have the C
pre-processor macro `SP_SINGLE_THREADED' defined to a non-zero value.

   Some of the foreign resources in the SICStus library use this
technique; see for instance `library(system)'.


File: sicstus.info,  Node: MT Foreign Multiple Full,  Prev: MT Foreign Multiple Simple,  Up: MT Foreign Multiple

8.3.2.2 Full Support for Multiple SICStus Run-Times
...................................................

To fully support multiple SICStus run-times, a foreign resource should
be built with `splfr --multi-sp-aware'.

   C code compiled by `splfr --multi-sp-aware' will have the C
pre-processor macro `MULTI_SP_AWARE' defined to a non-zero value.

   Full support for multiple SICStus run-times means that more than one
SICStus run-time can execute code in the foreign resource at the same
time. This rules out the option to use any global variables for
information that should be specific to each SICStus run-time.  In
particular, the SICStus dispatch vector cannot be stored in a global
variable. Instead, the SICStus dispatch vector is passed as an extra
first argument to each foreign function.

   To ensure some degree of link time type checking, the name of each
foreign function will be changed (using `#define' in the generated
header file).

   The extra argument is used in the same way as when using multiple
SICStus run-times from an embedding application. It must be passed on to
any function that needs access to the SICStus API.

   To simplify the handling of this extra argument, several macros are
defined so that the same foreign resource code can be compiled both
with and without support for multiple SICStus run-times:
   * `SPAPI_ARG0'

   * `SPAPI_ARG'

   * `SPAPI_ARG_PROTO_DECL0'

   * `SPAPI_ARG_PROTO_DECL'

   Their use is easiest to explain with an example. Suppose the original
foreign code looked like:
     static int f1(void)
     {
             SOME SICSTUS API CALLS
     }

     static int f2(SP_term_ref t, int x)
     {
             SOME SICSTUS API CALLS
     }

     /* :- foreign(foreign_fun, c, foreign_pred(+integer)). */
     void foreign_fun(long x)
     {
       ... SOME SICSTUS API CALLS ...
       f1();
       ...
       f2(SP_new_term_ref(), 42);
       ...
     }

   Assuming no global variables are used, the following change will
ensure that the SICStus API dispatch vector is passed around to all
functions:

     static int f1(SPAPI_ARG_PROTO_DECL0) // _DECL<ZERO> for no-arg functions
     {
             SOME SICSTUS API CALLS
     }

     static int f2(SPAPI_ARG_PROTO_DECL SP_term_ref t, int x) // Note: no comma
     {
             SOME SICSTUS API CALLS
     }

     /* :- foreign(foreign_fun, c, foreign_pred([-integer])). */
     void foreign_fun(SPAPI_ARG_PROTO_DECL long x) // Note: no comma
     {
       ... SOME SICSTUS API CALLS ...
       f1(SPAPI_ARG0);               // ARG<ZERO> for no-arg functions
       ...
       f2(SPAPI_ARG SP_new_term_ref(), 42);       // Note: no comma
       ...
     }

   If `MULTI_SP_AWARE' is not defined, i.e. `--multi-sp-aware' is not
specified to `splfr', all these macros expand to nothing, except
`SPAPI_ARG_PROTO_DECL0', which will expand to `void'.

   You can use `SP_foreign_stash()' to get access to a location,
initially set to NULL, where the foreign resource can store a `void*'.
Typically this would be a pointer to a C struct that holds all
information that need to be stored in global variables. This struct can
be allocated and initialized by the foreign resource init function.  It
should be deallocated by the foreign resource deinit function. *Note OS
Threads::, for details.

   Most foreign resources that come with SICStus fully support multiple
SICStus run-times. For a particularly simple example, see the code for
`library(random)'.  For an example that hides the passing of the extra
argument by using the C pre-processor, see the files in
`library/clpfd/'.


File: sicstus.info,  Node: Threads,  Prev: Foreign Resources and Multiple SICStus Run-Times,  Up: Multiple SICStus Run-Times

8.4 Multiple Run-Times and Threads
==================================

Perhaps the primary reason to use more than one SICStus run-time in a
process is to have each run-time running in a separate thread. To this
end, a few mutual exclusion primitives are available. *Note Operating
System Services::, for details on mutual exclusion locks.

     *Please note*: the SICStus run-time is not thread safe in general.
     *Note Calling Prolog Asynchronously::, for ways to safely interact
     with a running SICStus from arbitrary threads.


File: sicstus.info,  Node: Writing Efficient Programs,  Next: The Prolog Library,  Prev: Multiple SICStus Run-Times,  Up: Top

9 Writing Efficient Programs
****************************

* Menu:

* Eff Overview:: Overview
* Execution Profiling:: Execution Profiling::
* The Cut:: The Cut
* Indexing:: Indexing
* Last Clause Determinacy Detection:: Last Clause Determinacy Detection
* The Determinacy Checker:: The Determinacy Checker
* Last Call Optimization:: Last Call Optimization
* Building and Dismantling Terms:: Building and Dismantling Terms
* Conditionals and Disjunction:: Conditionals and Disjunction
* Programming Examples:: Programming Examples
* The Cross-Referencer:: The Cross-Referencer


File: sicstus.info,  Node: Eff Overview,  Next: Execution Profiling,  Up: Writing Efficient Programs

9.1 Overview
============

This chapter gives a number of tips on how to organize your programs
for increased efficiency.  A lot of clarity and efficiency is gained by
sticking to a few basic rules.  This list is necessarily very
incomplete.  The reader is referred to textbooks such as [O'Keefe 90]
for a thorough exposition of the elements of Prolog programming style
and techniques.

   * Don't write code in the first place if there is a library
     predicate that will do the job.

   * Write clauses representing base case before clauses representing
     recursive cases.

   * Input arguments before output arguments in clause heads and goals.

   * Use pure data structures instead of database changes.

   * Use cuts sparingly, and _only_ at proper places (*note
     ref-sem-ctr-cut::).  A cut should be placed at the exact point
     that it is known that the current choice is the correct one: no
     sooner, no later.

   * Make cuts as local in their effect as possible.  If a predicate is
     intended to be determinate, define _it_ as such; do not rely on
     its callers to prevent unintended backtracking.

   * Binding output arguments before a cut is a common source of
     programming errors.  If a predicate is not steadfast, it is
     usually for this reason.

   * Replace cuts by if-then-else constructs if the test is simple
     enough (*note Conditionals and Disjunction::).

   * Use disjunctions sparingly, _always_ put parentheses around them,
     _never_ put parentheses around the individual disjuncts, _never_
     put the `;' at the end of a line.

   * Write the clauses of a predicate so that they discriminate on the
     principal functor of the first argument (see below).  For maximum
     efficiency, avoid "defaulty" programming ("catch-all" clauses).

   * Don't use lists (`[...]'), "round lists" (`(...)'), or braces
     (`{...}') to represent compound terms, or "tuples", of some fixed
     arity.  The name of a compound term comes for free.

   * Before trying to optimize your program for speed, use execution
     profiling to get an idea of where most of the time is being spent,
     and, more importantly, why.


File: sicstus.info,  Node: Execution Profiling,  Next: The Cut,  Prev: Eff Overview,  Up: Writing Efficient Programs

9.2 Execution Profiling
=======================

Execution profiling is a common aid for improving software performance.
The SICStus Prolog compiler has the capability of instrumenting
compiled code with "counters", which are initially zero and incremented
whenever the flow of control passes a given point in the compiled code.
This way the number of calls, backtracks, choicepoints created, etc.,
can be counted for the instrumented predicates, and an estimate of the
time spent in individual clauses and disjuncts can be calculated.

   Gauge is a graphical user interface for inspecting execution
profiles.  It is available as a library module (*note lib-gauge::).

   The original version of the profiling package was written by M.M.
Gorlick and C.F. Kesselman at the Aerospace Corporation [Gorlick &
Kesselman 87].

   Only compiled code can be instrumented.  To get an execution profile
of a program, the compiler must first be told to produce instrumented
code.  This is done by issuing the query: 

     | ?- prolog_flag(compiling,_,profiledcode).

after which the program to be analyzed can be compiled as usual.  Any
new compiled code will be instrumented while the `compiling' Prolog
flag has the value `profiledcode'.

   The profiling data is generated by simply running the program.  The
predicate `profile_data/4' (see below) makes available a selection of
the data as a Prolog term.  The predicate `profile_reset/1' zeroes the
profiling counters for a selection of the currently instrumented
predicates.  For more information, see the respective reference page.

`profile_data(:SPEC,?SELECTION,?RESOLUTION,-DATA)  "development"'
     DATA is the profiling data collected from the instrumented
     predicates covered by SPEC with selection and resolution SELECTION
     and RESOLUTION respectively.

`profile_reset(:SPEC)  "development"'
     The profiling counters for the instrumented predicates covered by
     SPEC are zeroed.


File: sicstus.info,  Node: The Cut,  Next: Indexing,  Prev: Execution Profiling,  Up: Writing Efficient Programs

9.3 The Cut
===========

* Menu:

* Cut Overview:: Overview
* Making Predicates Determinate:: Making Predicates Determinate
* Placement of Cuts:: Placement of Cuts
* Terminating a Backtracking Loop:: Terminating a Backtracking Loop


File: sicstus.info,  Node: Cut Overview,  Next: Making Predicates Determinate,  Up: The Cut

9.3.1 Overview
--------------

One of the more difficult things to master when learning Prolog is the
proper use of the cut.  Often, when beginners find unexpected
backtracking occurring in their programs, they try to prevent it by
inserting cuts in a rather random fashion.  This makes the programs
harder to understand and sometimes stops them from working.  

   During program development, each predicate in a program should be
considered _independently_ to determine whether or not it should be
able to succeed more than once.  In most applications, many predicates
should at most succeed only once; that is, they should be determinate.
Having decided that a predicate should be determinate, it should be
verified that, in fact, it is.  The debugger can help in verifying that
a predicate is determinate (*note The Determinacy Checker::).


File: sicstus.info,  Node: Making Predicates Determinate,  Next: Placement of Cuts,  Prev: Cut Overview,  Up: The Cut

9.3.2 Making Predicates Determinate
-----------------------------------

Consider the following predicate, which calculates the factorial of a
number:

     fac(0, 1).
     fac(N, X) :-
             N1 is N - 1,
             fac(N1, Y),
             X is N * Y.

   The factorial of 5 can be found by typing:

     | ?- fac(5, X).

     X = 120

   However, backtracking into the above predicate by typing a semicolon
at this point, causes an infinite loop because the system starts
attempting to satisfy the goals `fac(-1, X).', `fac(-2, X).', etc.  The
problem is that there are two clauses that match the goal `fac(0, F).',
but the effect of the second clause on backtracking has not been taken
into account.  There are at least three possible ways of fixing this:

  1. Efficient solution: rewrite the first clause as
          fac(0,1) :- !.

     Adding the cut essentially makes the first solution the only one
     for the factorial of 0 and hence solves the immediate problem.
     This solution is space-efficient because as soon as Prolog
     encounters the cut, it knows that the predicate is determinate.
     Thus, when it tries the second clause, it can throw away the
     information it would otherwise need in order to backtrack to this
     point.  Unfortunately, if this solution is implemented, typing
     `fac(-1, X)' still generates an infinite search.

  2. Robust solution: rewrite the second clause as
          fac(N, X) :-
                  N > 0,
                  N1 is N - 1,
                  fac(N1, Y),
                  X is N * Y.

     This also solves the problem, but it is a more robust solution
     because this way it is impossible to get into an infinite loop.

     This solution makes the predicate _logically_ determinate--there
     is only one possible clause for any input--but the Prolog system
     is unable to detect this and must waste space for backtracking
     information.  The space-efficiency point is more important than it
     may at first seem; if `fac/2' is called from another determinate
     predicate, and if the cut is omitted, Prolog cannot detect the
     fact that `fac/2' is determinate. Therefore, it will not be able
     to detect the fact that the calling predicate is determinate, and
     space will be wasted for the calling predicate as well as for
     `fac/2' itself.  This argument applies again if the calling
     predicate is itself called by a determinate predicate, and so on,
     so that the cost of an omitted cut can be very high in certain
     circumstances.

  3. Preferred solution: rewrite the entire predicate as the single
     clause
          fac(N, X) :-
              (   N > 0 ->
                      N1 is N - 1,
                      fac(N1, Y),
                      X is N * Y
              ;   N =:= 0 ->
                      X = 1
              ).

     This solution is as robust as solution 2, and more efficient than
     solution 1, since it exploits conditionals with arithmetic tests
     (*note Conditionals and Disjunction:: for more information on
     optimization using conditionals).


File: sicstus.info,  Node: Placement of Cuts,  Next: Terminating a Backtracking Loop,  Prev: Making Predicates Determinate,  Up: The Cut

9.3.3 Placement of Cuts
-----------------------

Programs can often be made more readable by the placing of cuts as
early as possible in clauses.  For example, consider the predicate
`p/0' defined by
     p :- a, b, !, c, d.
     p :- e, f.

   Suppose that `b/0' is a test that determines which clause of `p/0'
applies; `a/0' may or may not be a test, but `c/0' and `d/0' are not
supposed to fail under any circumstances.  A cut is most appropriately
placed after the call to `b/0'.  If in fact `a/0' is the test and `b/0'
is not supposed to fail, it would be much clearer to move the cut
before the call to `b/0'.

   A tool to aid in determinacy checking is included in the
distribution.  It is described in depth in *Note The Determinacy
Checker::.


File: sicstus.info,  Node: Terminating a Backtracking Loop,  Prev: Placement of Cuts,  Up: The Cut

9.3.4 Terminating a Backtracking Loop
-------------------------------------

Cut is also commonly used in conjunction with the generate-and-test
programming paradigm.  For example, consider the predicate
`find_solution/1' defined by
     find_solution(X) :-
             candidate_solution(X),
             test_solution(X),
             !.

where `candidate_solution/1' generates possible answers on
backtracking.  The intent is to stop generating candidates as soon as
one is found that satisfies `test_solution/1'.  If the cut were
omitted, a future failure could cause backtracking into this clause and
restart the generation of candidate solutions.  A similar example is
shown below:

     process_file(F) :-
             see(F),
             repeat,
                 read(X),
                 process_and_fail(X),
             !,
             seen.

     process_and_fail(end_of_file) :- !.
     process_and_fail(X) :-
             process(X),
             fail.

   The cut in `process_file/1' is another example of terminating a
generate-and-test loop.  In general, a cut should always be placed
after a `repeat/0' so that the backtracking loop is clearly terminated.
If the cut were omitted in this case, on later backtracking Prolog
might try to read another term after the end of the file had been
reached.

   The cut in `process_and_fail/1' might be considered unnecessary
because, assuming the call shown is the only call to it, the cut in
`process_file/1' ensures that backtracking into `process_and_fail/1'
can never happen.  While this is true, it is also a good safeguard to
include a cut in `process_and_fail/1' because someone may unwittingly
change `process_file/1' in the future.


File: sicstus.info,  Node: Indexing,  Next: Last Clause Determinacy Detection,  Prev: The Cut,  Up: Writing Efficient Programs

9.4 Indexing
============

* Menu:

* Indexing Overview:: Overview
* Data Tables:: Data Tables
* Determinacy Detection:: Determinacy Detection


File: sicstus.info,  Node: Indexing Overview,  Next: Data Tables,  Up: Indexing

9.4.1 Overview
--------------

In SICStus Prolog, predicates are indexed on their first arguments.
This means that when a predicate is called with an instantiated first
argument, a hash table is used to gain fast access to only those
clauses having a first argument with the same primary functor as the
one in the predicate call.  If the first argument is atomic, only
clauses with a matching first argument are accessed.  Indexes are
maintained automatically by the built-in predicates manipulating the
Prolog database (for example, `assert/1', `retract/1', and `compile/1'.

   Keeping this feature in mind when writing programs can help speed
their execution.  Some hints for program structuring that will best use
the indexing facility are given below.  Note that dynamic predicates as
well as static predicates are indexed.  The programming hints given in
this section apply equally to static and dynamic code.


File: sicstus.info,  Node: Data Tables,  Next: Determinacy Detection,  Prev: Indexing Overview,  Up: Indexing

9.4.2 Data Tables
-----------------

The major advantage of indexing is that it provides fast access to
tables of data.  For example, a table of employee records might be
represented as shown below in order to gain fast access to the records
by employee name:

     %  employee(LastName,FirstNames,Department,Salary,DateOfBirth)

     employee('Smith', ['John'], sales,       20000, 1-1-59).
     employee('Jones', ['Mary'], engineering, 30000, 5-28-56).
     ...

   If fast access to the data via department is also desired, the data
can be organized little differently.  The employee records can be
indexed by some unique identifier, such as employee number, and
additional tables can be created to facilitate access to this table, as
shown in the example below.  For example,

     %  employee(Id,LastName,FirstNames,Department,Salary,DateOfBirth)

     employee(1000000, 'Smith', ['John'], sales,       20000, 1-1-59).
     employee(1000020, 'Jones', ['Mary'], engineering, 30000, 5-28-56).
     ...

     %  employee_name(LastName,EmpId)

     employee_name('Smith', 1000000).
     employee_name('Jones', 1000020).
     ...

     %  department_member(Department,EmpId)

     department_member(sales,       1000000).
     department_member(engineering, 1000020).
     ...

   Indexing would now allow fast access to the records of every
employee named Smith, and these could then be backtracked through
looking for John Smith.  For example:
     | ?- employee_name('Smith', Id),
          employee(Id, 'Smith', ['John'], Dept, Sal, DoB).

   Similarly, all the members of the engineering department born since
1965 could be efficiently found like this:
     | ?- department_member(engineering, Id),
          employee(Id, LN, FN, engineering, _, M-D-Y),
          Y > 65.


File: sicstus.info,  Node: Determinacy Detection,  Prev: Data Tables,  Up: Indexing

9.4.3 Determinacy Detection
---------------------------

The other advantage of indexing is that it often makes possible early
detection of determinacy, even if cuts are not included in the program.
For example, consider the following simple predicate, which joins two
lists together:

     concat([], L, L).
     concat([X|L1], L2, [X|L3]) :- concat(L1, L2, L3).

   If this predicate is called with an instantiated first argument, the
first argument indexing of SICStus Prolog will recognize that the call
is determinate--only one of the two clauses for `concat/3' can possibly
apply.  Thus, the Prolog system knows it does not have to store
backtracking information for the call.  This significantly reduces
memory use and execution time.

   Determinacy detection can also reduce the number of cuts in
predicates.  In the above example, if there was no indexing, a cut
would not strictly be needed in the first clause as long as the
predicate was always to be called with the first argument instantiated.
If the first clause matched, the second clause could not possibly
match; discovery of this fact, however, would be postponed until
backtracking.  The programmer might thus be tempted to use a cut in the
first clause to signal determinacy and recover space for backtracking
information as early as possible.

   With indexing, if the example predicate is always called with its
first argument instantiated, backtracking information is _never_
stored.  This gives substantial performance improvements over using a
cut rather than indexing to force determinacy.  At the same time
greater flexibility is maintained: the predicate can now be used in a
nondeterminate fashion as well, as in
     | ?- concat(L1, L2, [a,b,c,d]).

which will generate on backtracking all the possible partitions of the
list `[a,b,c,d]' on backtracking.  If a cut had been used in the first
clause, this would not work.


File: sicstus.info,  Node: Last Clause Determinacy Detection,  Next: The Determinacy Checker,  Prev: Indexing,  Up: Writing Efficient Programs

9.5 Last Clause Determinacy Detection
=====================================

Even if the determinacy detection made possible by indexing is
unavailable to a predicate call, SICStus Prolog still can detect
determinacy before determinate exit from the predicate.  Space for
backtracking information can thus be recovered as early as possible,
reducing memory requirements and increasing performance.  For instance,
the predicate `member/2' (found in the SICStus Prolog library) could be
defined by:
     member(Element, [Element|_]).
     member(Element, [_|Rest]) :-
             member(Element, Rest).

   `member/2' might be called with an instantiated first argument in
order to check for membership of the argument in a list, which is
passed as a second argument, as in
     | ?- member(4, [1,2,3,4]).

   The first arguments of both clauses of `member/2' are variables, so
first argument indexing cannot be used.  However, determinacy can still
be detected before determinate exit from the predicate.  This is
because on entry to the last clause of a nondeterminate predicate, a
call becomes effectively determinate; it can tell that it has no more
clauses to backtrack to.  Thus, backtracking information is no longer
needed, and its space can be reclaimed.  In the example, each time a
call fails to match the first clause and backtracks to the second
(last) clause, backtracking information for the call is automatically
deleted.

   Because of last clause determinacy detection, a cut is never needed
as the first subgoal in the last clause of a predicate.  Backtracking
information will have been deleted before a cut in the last clause is
executed, so the cut will have no effect except to waste time.

   Note that last clause determinacy detection is exploited by dynamic
code as well as static code in SICStus Prolog.


File: sicstus.info,  Node: The Determinacy Checker,  Next: Last Call Optimization,  Prev: Last Clause Determinacy Detection,  Up: Writing Efficient Programs

9.6 The Determinacy Checker
===========================

The determinacy checker can help you spot unwanted nondeterminacy in
your programs.  This tool examines your program source code and points
out places where nondeterminacy may arise.  It is not in general
possible to find exactly which parts of a program will be
nondeterminate without actually running the program, but this tool can
find most unwanted nondeterminacy.  Unintended nondeterminacy should be
eradicated because

  1. it may give you wrong answers on backtracking

  2. it may cause a lot of memory to be wasted

* Menu:

* Using the Determinacy Checker:: Using the Determinacy Checker
* Declaring Nondeterminacy:: Declaring Nondeterminacy
* Checker Output:: Checker Output
* Det Example:: Example
* Det Options:: Options
* What is Detected:: What is Detected


File: sicstus.info,  Node: Using the Determinacy Checker,  Next: Declaring Nondeterminacy,  Up: The Determinacy Checker

9.6.1 Using the Determinacy Checker
-----------------------------------

There are two different ways to use the determinacy checker, either as a
stand-alone tool, or during compilation.  You may use it whichever way
fits best with the way you work.  Either way, it will discover the same
nondeterminacy in your program.

   The stand-alone determinacy checker is called `spdet', and is run
from the shell prompt, specifying the names of the Prolog source files
you wish to check.

   The determinacy checker can also be integrated into the compilation
process, so that you receive warnings about unwanted nondeterminacy
along with warnings about singleton variables or discontiguous clauses.
To make this happen, simply insert the line
     :- load_files(library(detcheck),
                   [when(compile_time), if(changed)]).

   Once this line is added, every time that file is loaded, it will be
checked for unwanted nondeterminacy.


File: sicstus.info,  Node: Declaring Nondeterminacy,  Next: Checker Output,  Prev: Using the Determinacy Checker,  Up: The Determinacy Checker

9.6.2 Declaring Nondeterminacy
------------------------------

Some predicates are intended to be nondeterminate.  By declaring
intended nondeterminacy, you avoid warnings about predicates you intend
to be nondeterminate.  Equally importantly, you also inform the
determinacy checker about nondeterminate predicates.  It uses this
information to identify unwanted nondeterminacy.

   Nondeterminacy is declared by putting a declaration of the form

     :- nondet NAME/ARITY.

in your source file.  This is similar to a `dynamic' or `discontiguous'
declaration.  You may have multiple `nondet' declarations, and a single
declaration may mention several predicates, separating them by commas.

   Similarly, a predicate P/N may be classified as nondeterminate by
the checker, whereas in reality it is determinate.  This may happen
e.g. if P/N calls a dynamic predicate that in reality never has more
than one clause.  To prevent false alarms asiring from this, you can
inform the checker about determinate predicates by declarations of the
form:

     :- det NAME/ARITY.

   If you wish to include `det' and `nondet' declarations in your file
and you plan to use the stand-alone determinacy checker, you must
include the line
     :- load_files(library(nondetdecl),
                   [when(compile_time), if(changed)]).

near the top of each file that contains such declarations.  If you use
the integrated determinacy checker, you do not need (and should not
have) this line.


File: sicstus.info,  Node: Checker Output,  Next: Det Example,  Prev: Declaring Nondeterminacy,  Up: The Determinacy Checker

9.6.3 Checker Output
--------------------

The output of the determinacy checker is quite simple.  For each clause
containing unexpected nondeterminacy, a single line is printed showing
the module, name, arity, and clause number (counting from 1).  The form
of the information is:
     * Non-determinate: MODULE:NAME/ARITY (clause NUMBER)

   A second line for each nondeterminate clause indicates the cause of
the nondeterminacy.  The recognized causes are:

   * The clause contains a disjunction that is not forced to be
     determinate with a cut or by ending the clause with a call to
     `fail/0' or `raise_exception/1'.

   * The clause calls a nondeterminate predicate.  In this case the
     predicate is named.

   * There is a later clause for the same predicate whose first
     argument has the same principal functor (or one of the two clauses
     has a variable for the first argument), and this clause does not
     contain a cut or end with a call to `fail/0' or
     `raise_exception/1'.  In this case, the clause number of the other
     clause is mentioned.

   * If the predicate is multifile, clause indexing is not considered
     sufficient to ensure determinacy.  This is because other clauses
     may be added to the predicate in other files, so the determinacy
     checker cannot be sure it has seen all the clauses for the
     predicate.  It is good practice to include a cut (or fail) in
     every clause of a multifile predicate.

   The determinacy checker also occasionally prints warnings when
declarations are made too late in the file or not at all.  For example,
if you include a `dynamic', `nondet', or `discontiguous' declaration
for a predicate after some clauses for that predicate, or if you put a
`dynamic' or `nondet' declaration for a predicate after a clause that
includes a call to that predicate, the determinacy checker may have
missed some nondeterminacy in your program.  The checker also detects
undeclared discontiguous predicates, which may also have undetected
nondeterminacy.  Finally, the checker looks for goals in your program
that indicate that predicates are dynamic; if no `dynamic' declaration
for those predicates exists, you will be warned.

   These warnings take the following form:
     ! warning: predicate module:name/arity is PROPERTY.
     !          Some nondeterminacy may have been missed.
     !          Add (or move) the directive
     !              :- PROPERTY module:name/arity.
     !          near the top of this file.


File: sicstus.info,  Node: Det Example,  Next: Det Options,  Prev: Checker Output,  Up: The Determinacy Checker

9.6.4 Example
-------------

Here is an example file:
     :- load_files(library(detcheck),
                   [when(compile_time), if(changed)]).

     parent(abe, rob).
     parent(abe, sam).
     parent(betty, rob).
     parent(betty, sam).

     is_parent(Parent) :- parent(Parent, _).

   The determinacy checker notices that the first arguments of clauses
1 and 2 have the same principal functor, and similarly for clauses 3
and 4.  It reports:
     * Non-determinate: user:parent/2 (clause 1)
     *     Indexing cannot distinguish this from clause 2.
     * Non-determinate: user:parent/2 (clause 3)
     *     Indexing cannot distinguish this from clause 4.

   In fact, `parent/2' should be nondeterminate, so we should add the
declaration
     :- nondet parent/2.
before the clauses for `parent/2'.  If run again after modifying
file, the determinacy checker prints:
     * Non-determinate: user:is_parent/1 (clause 1)
     *     This clause calls user:parent/2, which may be nondeterminate.

   It no longer complains about `parent/2' being nondeterminate, since
this is declared.  But now it notices that because `parent/2' is
nondeterminate, then so is `is_parent/1'.


File: sicstus.info,  Node: Det Options,  Next: What is Detected,  Prev: Det Example,  Up: The Determinacy Checker

9.6.5 Options
-------------

When run from the command line, the determinacy checker has a few
options to control its workings.

   The `-r' option specifies that the checker should recursively check
files in such a way that it finds nondeterminacy caused by calls to
other nondeterminate predicates, whether they are declared so or not.
Also, predicates that appear to determinate will be treated as such,
whether declared `nondet' or not.  This option is quite useful when
first running the checker on a file, as it will find all predicates
that should be either made determinate or declared `nondet' at once.
Without this option, each time a `nondet' declaration is added, the
checker may find previously unnoticed nondeterminacy.

   For example, if the original example above, without any `nondet'
declarations, were checked with the `-r' option, the output would be:
     * Non-determinate: user:parent/2 (clause 1)
     *     Indexing cannot distinguish this from clause 2.
     * Non-determinate: user:parent/2 (clause 3)
     *     Indexing cannot distinguish this from clause 4.
     * Non-determinate: user:is_parent/1 (clause 1)
     *     Calls nondet predicate user:parent/2.

   The `-d' option causes the tool to print out the needed `nondet'
declarations.  These can be readily pasted into the source files.  Note
that it only prints the `nondet' declarations that are not already
present in the files.  However, these declarations should not be pasted
into your code without each one first being checked to see if the
reported nondeterminacy is intended.

   The `-D' option is like `-d', except that it prints out all `nondet'
declarations that should appear, whether they are already in the file
or not.  This is useful if you prefer to replace all old `nondet'
declarations with new ones.

   Your code will probably rely on operator declarations and possibly
term expansion. The determinacy checker handles this in the following
way: you must supply an initialization file, using the `-i' IFILE
option.  `spdet' will execute any operator declaration it encounters.


File: sicstus.info,  Node: What is Detected,  Prev: Det Options,  Up: The Determinacy Checker

9.6.6 What is Detected
----------------------

As mentioned earlier, it is not in general possible to find exactly
which places in a program will lead to nondeterminacy.  The determinacy
checker gives predicates the benefit of the doubt: when it's possible
that a predicate will be determinate, it will not be reported.  The
checker will only report places in your program that will be
nondeterminate regardless of which arguments are bound.  Despite this,
the checker catches most unwanted nondeterminacy in practice.

   The determinacy checker looks for the following sources of
nondeterminacy:

   * Multiple clauses that can't be distinguished by the principal
     functor of the first arguments, and are not made determinate with
     an explicit cut, `fail/0', `false/0', or `raise_exception/1'.
     First argument indexing is not considered for multifile predicates,
     because another file may have a clause for this predicate with the
     same principal functor of its first argument.

   * A clause with a disjunction not forced to be determinate by a cut,
     `fail/0', `false/0', or `raise_exception/1' in each arm of the
     disjunction but the last, or where the whole disjunction is
     followed by a cut, `fail/0', `false/0', or `raise_exception/1'.

   * A clause that calls something known to be nondeterminate, other
     than when it is followed by a cut, `fail/0', `false/0', or
     `raise_exception/1', or where it appears in the condition of an
     if-then-else construct.  Known nondeterminate predicates include
     hooks and those declared nondeterminate or dynamic (since they can
     be modified, dynamic predicates are assumed to be nondeterminate),
     plus the following built-in predicates:

        - `absolute_file_name/3', when the options list contains
          `solutions(all)'.

        - `atom_concat/3', when the first two arguments are variables
          not appearing earlier in the clause (including the clause
          head).

        - `bagof/3', when the second argument contains any variables
          not appearing earlier in the clause (including the clause
          head).

        - `clause/[2,3]'.

        - `current_op/3', when any argument contains any variables not
          appearing earlier in the clause (including the clause head).

        - `current_key/2', when the second argument contains any
          variables not appearing earlier in the clause (including the
          clause head).

        - `current_predicate/2', when the second argument contains any
          variables not appearing earlier in the clause (including the
          clause head).

        - `length/2', when both arguments are variables not appearing
          earlier in the clause (including the clause head).

        - `predicate_property/2', when either argument contains any
          variables not appearing earlier in the clause (including the
          clause head).

        - `recorded/3'.

        - `repeat/0'.

        - `retract/1'.

        - `setof/3', when the second argument contains any variables
          not appearing earlier in the clause (including the clause
          head).

        - `source_file/[1,2]' when the last argument contains any
          variables not appearing earlier in the clause (including the
          clause head).

        - `sub_atom/5', when at least two of the second, fourth and
          fifth arguments are variables not appearing earlier in the
          clause (including the clause head).



File: sicstus.info,  Node: Last Call Optimization,  Next: Building and Dismantling Terms,  Prev: The Determinacy Checker,  Up: Writing Efficient Programs

9.7 Last Call Optimization
==========================

Another important efficiency feature of SICStus Prolog is last call
optimization.  This is a space optimization technique, which applies
when a predicate is determinate at the point where it is about to call
the last goal in the body of a clause.  For example,
     % for(Int, Lower, Upper)
     % Lower and Upper should be integers such that Lower =< Upper.
     % Int should be uninstantiated; it will be bound successively on
     % backtracking to Lower, Lower+1, ... Upper.

     for(Int, Int, _Upper).
     for(Int, Lower, Upper) :-
             Lower < Upper,
             Next is Lower + 1,
             for(Int, Next, Upper).

   This predicate is determinate at the point where the recursive call
is about to be made, since this is the last clause and the preceding
goals `(<)/2' and `is/2') are determinate.  Thus last call optimization
can be applied; effectively, the stack space being used for the current
predicate call is reclaimed before the recursive call is made.  This
means that this predicate uses only a constant amount of space, no
matter how deep the recursion.

* Menu:

* Accumulating Parameters:: Accumulating Parameters
* Accumulating Lists:: Accumulating Lists


File: sicstus.info,  Node: Accumulating Parameters,  Next: Accumulating Lists,  Up: Last Call Optimization

9.7.1 Accumulating Parameters
-----------------------------

To take best advantage of this feature, make sure that goals in
recursive predicates are determinate, and whenever possible put the
recursive call at the end of the predicate.

   This isn't always possible, but often can be done through the use of
"accumulating parameters".  An accumulating parameter is an added
argument to a predicate that builds up the result as computation
proceeds.  For example, in our factorial example, the last goal in the
body of the recursive case is `is/2', not the recursive call to `fac/2'.

     fac(N, X) :-
         (   N > 0 ->
                 N1 is N - 1,
                 fac(N1, Y),
                 X is N * Y
         ;   N =:= 0 ->
                 X = 1
         ).

   This can be corrected by adding another argument to `fac/2' to
accumulate the factorial.

     fac(N, X) :- fac(N, 1, X).

     %  fac(+N, +M, -X)
     %  X is M * the factorial of N.

     fac(N, M, X) :-
         (   N > 0 ->
                 N1 is N - 1,
                 M1 is N * M,
                 fac(N1, M1, X)
         ;   N =:= 0 ->
                 X = M
         ).

   Here, we do the multiplication before calling `fac/3' recursively.
Note that we supply the base case, 1, at the start of the computation,
and that we are multiplying by decreasing numbers.  In the earlier
version, `fac/2', we multiply after the recursive call, and so we
multiply by increasing numbers.  Effectively, the new version builds the
result backwards.  This is correct because multiplication is
associative.


File: sicstus.info,  Node: Accumulating Lists,  Prev: Accumulating Parameters,  Up: Last Call Optimization

9.7.2 Accumulating Lists
------------------------

This technique becomes much more important when extended to lists, as
in this case it can save much building of unneeded lists through
unnecessary calls to append sublists together.  For example, the naive
way to reverse a list is:

     nreverse([], []).
     nreverse([H|T], L) :-
             nreverse(T, L1),
             append(L1, [H], L).

   This is very wasteful, since each call to `append/3' copies the
initial part of the list, and adds one element to it.  Fortunately,
this can be very easily rewritten to use an accumulating parameter:

     reverse(L1, L2) :- reverse(L1, [], L2).

     %  reverse(+X, +Y, -Z)
     %  Z is X reversed, followed by Y
     reverse([], Z, Z).
     reverse([H|T], L0, L) :-
             reverse(T, [H|L0], L).

   This version of reverse is many times faster than the naive version,
and uses much less memory.  The key to understanding the behavior of
this predicate is the observation made earlier: using an accumulating
parameter, we build the result backwards.

   Don't let this confuse you.  Building a list forward is easy.  For
example, a predicate returning a list L of consecutive numbers from 1
to N could be written in two different ways: counting up and collecting
the resulting list forward, or counting down and accumulating the
result backward.

     iota1(N, L) :- iota1(1, N, L).
     iota1(N, Max, L) :-
             (   N > Max ->
                     L = []
             ;   N1 is N+1,
                 L = [N|L1],
                 iota1(N1, Max, L1)
             ).
or,

     iota2(N, L) :- iota2(N, [], L).
     iota2(N, L0, L) :-
             (   N =< 0 ->
                     L = L0
             ;   N1 is N-1,
                 iota2(N1, [N|L0], L)
             ).

   Both versions generate the same results, and neither waste any space.
The second version is slightly faster.  Choose whichever approach you
prefer.


File: sicstus.info,  Node: Building and Dismantling Terms,  Next: Conditionals and Disjunction,  Prev: Last Call Optimization,  Up: Writing Efficient Programs

9.8 Building and Dismantling Terms
==================================

The built-in predicate `(=..)/2' is a clear way of building terms and
taking them apart.  However, it is almost never the most efficient way.
`functor/3' and `arg/3' are generally much more efficient, though less
direct.  The best blend of efficiency and clarity is to write a
clearly-named predicate that implements the desired operation and to
use `functor/3' and `arg/3' in that predicate.

   Here is an actual example.  The task is to reimplement the built-in
predicate `(==)/2'.  The first variant uses `(=..)/2' (this symbol is
pronounced "univ" for historical reasons).  Some Prolog textbooks
recommend code similar to this.
     ident_univ(X, Y) :-
             var(X),                 % If X is a variable,
             !,
             var(Y),                 % so must Y be, and
             samevar(X, Y).          % they must be the same.
     ident_univ(X, Y) :-             % If X is not a variable,
             nonvar(Y),              % neither may Y be;
             X =.. [F|L],            % they must have the
             Y =.. [F|M],            % same function symbol F
             ident_list(L, M).       % and identical arguments

     ident_list([], []).
     ident_list([H1|T1], [H2|T2]) :-
             ident_univ(H1, H2),
             ident_list(T1, T2).

     samevar(29, Y) :-               % If binding X to 29
             var(Y),                 % leaves Y unbound,
             !,                      % they were not the same
             fail.                   % variable.
     samevar(_, _).                  % Otherwise they were.

   This code performs the function intended; however, every time it
touches a non-variable term of arity N, it constructs a list with N+1
elements, and if the two terms are identical, these lists are reclaimed
only when backtracked over or garbage collected.

   Better code uses `functor/3' and `arg/3'.
     ident_farg(X, Y) :-
             (   var(X) ->           % If X is a variable,
                     var(Y),         % so must Y be, and
                     samevar(X, Y)   % they must be the same;
             ;   nonvar(Y),          % otherwise Y must be nonvar
                 functor(X, F, N),   % The principal functors of X
                 functor(Y, F, N),   % and Y must be identical,
                 ident_farg(N, X, Y) % including the last N args.
             ).

     ident_farg(0, _, _) :- !.
     ident_farg(N, X, Y) :-          % The last N arguments are
             arg(N, X, Xn),          % identical
             arg(N, Y, Yn),          % if the Nth arguments
             ident_farg(Xn, Yn),     % are identical,
             M is N-1,               % and the last N-1 arguments
             ident_farg(M, X, Y).    % are also identical.

   This approach to walking through terms using `functor/3' and `arg/3'
avoids the construction of useless lists.

   The pattern shown in the example, in which a predicate of arity K
calls an auxiliary predicate of the same name of arity K+1 (the
additional argument denoting the number of items remaining to process),
is very common.  It is not necessary to use the same name for this
auxiliary predicate, but this convention is generally less prone to
confusion.

   In order to simply find out the principal function symbol of a term,
use
     | ?- THE_TERM_IS(Term),
     |    functor(Term, FunctionSymbol, _).

   The use of `(=..)/2', as in
     | ?- THE_TERM_IS(Term),
     |    Term =.. [FunctionSymbol|_].
is wasteful, and should generally be avoided.  The same remark
applies if the arity of a term is desired.

   `(=..)/2' should not be used to locate a particular argument of some
term.  For example, instead of
     Term =.. [_F,_,ArgTwo|_]
you should write
     arg(2, Term, ArgTwo)

   It is generally easier to get the explicit number "2" right than to
write the correct number of anonymous variables in the call to
`(=..)/2'.  Other people reading the program will find the call to
`arg/3' a much clearer expression of the program's intent.  The program
will also be more efficient.  Even if several arguments of a term must
be located, it is clearer and more efficient to write
     arg(1, Term, First),
     arg(3, Term, Third),
     arg(4, Term, Fourth)
than to write
     Term =.. [_,First,_,Third,Fourth|_]

   Finally, `(=..)/2' should not be used when the functor of the term
to be operated on is known (that is, when both the function symbol and
the arity are known).  For example, to make a new term with the same
function symbol and first arguments as another term, but one additional
argument, the obvious solution might seem to be to write something like
the following:
     add_date(OldItem, Date, NewItem) :-
             OldItem =.. [item,Type,Ship,Serial],
             NewItem =.. [item,Type,Ship,Serial,Date].

   However, this could be expressed more clearly and more efficiently as
     add_date(OldItem, Date, NewItem) :-
             OldItem = item(Type,Ship,Serial),
             NewItem = item(Type,Ship,Serial,Date).
or even
     add_date(item(Type,Ship,Serial),
              Date,
              item(Type,Ship,Serial,Date)
             ).


File: sicstus.info,  Node: Conditionals and Disjunction,  Next: Programming Examples,  Prev: Building and Dismantling Terms,  Up: Writing Efficient Programs

9.9 Conditionals and Disjunction
================================

There is an efficiency advantage in using conditionals whose test part
consists only of arithmetic comparisons or type tests.  Consider the
following alternative definitions of the predicate
`type_of_character/2'.  In the first definition, four clauses are used
to group characters on the basis of arithmetic comparisons.

     type_of_character(Ch, Type) :-
             Ch >= "a", Ch =< "z",
             !,
             Type = lowercase.
     type_of_character(Ch, Type) :-
             Ch >= "A", Ch =< "Z",
             !,
             Type = uppercase.
     type_of_character(Ch, Type) :-
             Ch >= "0", Ch =< "9",
             !,
             Type = digit.
     type_of_character(_Ch, Type) :-
             Type = other.

   In the second definition, a single clause with a conditional is
used.  The compiler generates equivalent, optimized code for both
versions.

     type_of_character(Ch, Type) :-
             (   Ch >= "a", Ch =< "z" ->
                     Type = lowercase
             ;   Ch >= "A", Ch =< "Z" ->
                     Type = uppercase
             ;   Ch >= "0", Ch =< "9" ->
                     Type = digit
             ;   otherwise ->
                     Type = other
             ).

   Following is a list of built-in predicates that are compiled
efficiently in conditionals:

   * `atom/1'

   * `atomic/1'

   * `callable/1'

   * `compound/1'

   * `float/1'

   * `ground/1'

   * `integer/1'

   * `nonvar/1'

   * `number/1'

   * `simple/1'

   * `var/1'

   * `</2'

   * `=</2'

   * `=:=/2'

   * `=\=/2'

   * `>=/2'

   * `>/2'

   * `@</2'

   * `@=</2'

   * `==/2'

   * `\==/2'

   * `@>=/2'

   * `@>/2'

   This optimization is actually somewhat more general than what is
described above.  A sequence of guarded clauses:

     HEAD1 :- GUARD1, !, BODY1.
     ...
     HEADM :- GUARDM, !, BODYM.
     HEADN :- BODYM.

is eligible for the same optimization, provided that the arguments of
the clause heads are all unique variables and that the "guards" are
simple tests as listed above.


File: sicstus.info,  Node: Programming Examples,  Next: The Cross-Referencer,  Prev: Conditionals and Disjunction,  Up: Writing Efficient Programs

9.10 Programming Examples
=========================

The rest of this chapter contains a number of simple examples of Prolog
programming, illustrating some of the techniques described above.

* Menu:

* Simple List:: Simple List Processing
* Family Example:: Family Example (descendants)
* Association Lists:: Association List Primitives
* Derivative:: Differentiation
* Use Of Meta:: Use of Meta-Logical Predicates
* Interpreter:: Prolog in Prolog
* Translate:: Translating English Sentences into Logic Formulae


File: sicstus.info,  Node: Simple List,  Next: Family Example,  Up: Programming Examples

9.10.1 Simple List Processing
-----------------------------

The goal `concatenate(L1,L2,L3)' is true if list L3 consists of the
elements of list L1 concatenated with the elements of list L2.  The goal
`member(X,L)' is true if X is one of the elements of list L.  The goal
`reverse(L1,L2)' is true if list L2 consists of the elements of list L1
in reverse order.

     concatenate([], L, L).
     concatenate([X|L1], L2, [X|L3]) :- concatenate(L1, L2, L3).

     member(X, [X|_]).
     member(X, [_|L]) :- member(X, L).

     reverse(L, L1) :- reverse_concatenate(L, [], L1).

     reverse_concatenate([], L, L).
     reverse_concatenate([X|L1], L2, L3) :-
             reverse_concatenate(L1, [X|L2], L3).


File: sicstus.info,  Node: Family Example,  Next: Association Lists,  Prev: Simple List,  Up: Programming Examples

9.10.2 Family Example (descendants)
-----------------------------------

The goal `descendant(X,Y)' is true if Y is a descendant of X.

     descendant(X, Y) :- offspring(X, Y).
     descendant(X, Z) :- offspring(X, Y), descendant(Y, Z).

     offspring(abraham, ishmael).
     offspring(abraham, isaac).
     offspring(isaac, esau).
     offspring(isaac, jacob).

   If for example the query

     | ?- descendant(abraham, X).

is executed, Prolog's backtracking results in different descendants of
Abraham being returned as successive instances of the variable X, i.e.

     X = ishmael
     X = isaac
     X = esau
     X = jacob


File: sicstus.info,  Node: Association Lists,  Next: Derivative,  Prev: Family Example,  Up: Programming Examples

9.10.3 Association List Primitives
----------------------------------

These predicates implement "association list" primitives.  They use a
binary tree representation.  Thus the time complexity for these
predicates is O(LG N), where N is the number of keys.  These predicates
also illustrate the use of `compare/3' for case analysis.

   The goal `get_assoc(KEY, ASSOC, VALUE)' is true when KEY is
identical to one of the keys in ASSOC, and VALUE unifies with the
associated value.

     get_assoc(Key, t(K,V,L,R), Val) :-
             compare(Rel, Key, K),
             get_assoc(Rel, Key, V, L, R, Val).

     get_assoc(=, _, Val, _, _, Val).
     get_assoc(<, Key, _, Tree, _, Val) :-
             get_assoc(Key, Tree, Val).
     get_assoc(>, Key, _, _, Tree, Val) :-
             get_assoc(Key, Tree, Val).


File: sicstus.info,  Node: Derivative,  Next: Use Of Meta,  Prev: Association Lists,  Up: Programming Examples

9.10.4 Differentiation
----------------------

The goal `d(E1, X, E2)' is true if expression E2 is a possible form for
the derivative of expression E1 with respect to X.

     d(X, X, D) :- atomic(X), !, D = 1.
     d(C, X, D) :- atomic(C), !, D = 0.
     d(U+V, X, DU+DV) :- d(U, X, DU), d(V, X, DV).
     d(U-V, X, DU-DV) :- d(U, X, DU), d(V, X, DV).
     d(U*V, X, DU*V+U*DV) :- d(U, X, DU), d(V, X, DV).
     d(U**N, X, N*U**N1*DU) :- integer(N), N1 is N-1, d(U, X, DU).
     d(-U, X, -DU) :- d(U, X, DU).


File: sicstus.info,  Node: Use Of Meta,  Next: Interpreter,  Prev: Derivative,  Up: Programming Examples

9.10.5 Use of Meta-Logical Predicates
-------------------------------------

This example illustrates the use of the meta-logical predicates
`var/1', `arg/3', and `functor/3'.  The goal `variables(TERM, L, [])'
instantiates variable L to a list of all the variable occurrences in
TERM.  E.g.:

     | ?- variables(d(U*V, X, DU*V+U*DV), L, []).

     L = [U,V,X,DU,V,U,DV]

     variables(X, [X|L0], L) :- var(X), !, L = L0.
     variables(T, L0, L) :-
     %       nonvar(T),
             functor(T, _, A),
             variables(0, A, T, L0, L).

     variables(A, A, _, L0, L) :- !, L = L0.
     variables(A0, A, T, L0, L) :-
     %       A0<A,
             A1 is A0+1,
             arg(A1, T, X),
             variables(X, L0, L1),
             variables(A1, A, T, L1, L).


File: sicstus.info,  Node: Interpreter,  Next: Translate,  Prev: Use Of Meta,  Up: Programming Examples

9.10.6 Prolog in Prolog
-----------------------

This example shows how simple it is to write a Prolog interpreter in
Prolog, and illustrates the use of a variable goal.  In this
mini-interpreter, goals and clauses are represented as ordinary Prolog
data structures (i.e. terms).  Terms representing clauses are specified
using the predicate `my_clause/1', e.g.:

     my_clause( (grandparent(X, Z) :- parent(X, Y), parent(Y, Z)) ).

   A unit clause will be represented by a term such as

     my_clause( (parent(john, mary) :- true) ).

   The mini-interpreter consists of three clauses:

     execute((P,Q)) :- !, execute(P), execute(Q).
     execute(P) :- predicate_property(P, built_in), !, P.
     execute(P) :- my_clause((P :- Q)), execute(Q).

   The second clause enables the mini-interpreter to cope with calls to
ordinary Prolog predicates, e.g. built-in predicates.  The
mini-interpreter needs to be extended to cope with the other control
structures, i.e. `!', `(P;Q)', `(P->Q)', `(P->Q;R)', `(\+ P)', and
`if(P,Q,R)'.


File: sicstus.info,  Node: Translate,  Prev: Interpreter,  Up: Programming Examples

9.10.7 Translating English Sentences into Logic Formulae
--------------------------------------------------------

The following example of a definite clause grammar defines in a formal
way the traditional mapping of simple English sentences into formulae of
classical logic.  By way of illustration, if the sentence

     Every man that lives loves a woman.

is parsed as a sentence by the call

     | ?- phrase(sentence(P), [every,man,that,lives,loves,a,woman]).

P will get instantiated to

     all(X):(man(X)&lives(X) => exists(Y):(woman(Y)&loves(X,Y)))

where `:', `&' and `=>' are infix operators defined by

     :- op(900, xfx, =>).
     :- op(800, xfy, &).
     :- op(550, xfy, :). /* predefined */

   The grammar follows:

     sentence(P) --> noun_phrase(X, P1, P), verb_phrase(X, P1).

     noun_phrase(X, P1, P) -->
             determiner(X, P2, P1, P), noun(X, P3), rel_clause(X, P3, P2).
     noun_phrase(X, P, P) --> name(X).

     verb_phrase(X, P) --> trans_verb(X, Y, P1), noun_phrase(Y, P1, P).
     verb_phrase(X, P) --> intrans_verb(X, P).

     rel_clause(X, P1, P1&P2) --> [that], verb_phrase(X, P2).
     rel_clause(_, P, P) --> [].

     determiner(X, P1, P2, all(X):(P1=>P2)) --> [every].
     determiner(X, P1, P2, exists(X):(P1&P2)) --> [a].

     noun(X, man(X)) --> [man].
     noun(X, woman(X)) --> [woman].

     name(john) --> [john].

     trans_verb(X, Y, loves(X,Y)) --> [loves].
     intrans_verb(X, lives(X)) --> [lives].


File: sicstus.info,  Node: The Cross-Referencer,  Prev: Programming Examples,  Up: Writing Efficient Programs

9.11 The Cross-Referencer
=========================

* Menu:

* Xref Introduction:: Introduction
* Xref Practice and Experience:: Practice and Experience


File: sicstus.info,  Node: Xref Introduction,  Next: Xref Practice and Experience,  Up: The Cross-Referencer

9.11.1 Introduction
-------------------

The main purpose of the cross-referencer, `spxref', is to find
undefined predicates and unreachable code.  To this end, it begins by
looking for initializations, hooks and `public' directives to start
tracing the reachable code from.  If an entire application is being
checked, it also traces from `user:runtime_entry/1'.  If individual
module-files are being checked, it also traces from their export lists.

   A second function of `spxref' is to aid in the formation of module
statements.  `spxref' can list all of the required `module/2' and
`use_module/2' statements by file.

   The cross-referencer is called `spxref', and is run from the shell
prompt, specifying the names of the Prolog source files you wish to
check.


File: sicstus.info,  Node: Xref Practice and Experience,  Prev: Xref Introduction,  Up: The Cross-Referencer

9.11.2 Practice and Experience
------------------------------

Your code will probably rely on operator declarations and possibly term
expansion. The cross-referencer handles this in the following way: you
must supply an initialization file, using the `-i' IFILE option.
`spxref' will execute any operator declaration it encounters.

   Supply meta-predicate declarations for your meta-predicates.
Otherwise, the cross-referencer will not follow the meta-predicates'
arguments.  Be sure the cross-referencer encounters the meta-predicate
declarations _before_ it encounters calls to the declared predicates.

   The cross-referencer traces from initializations, hooks, predicates
declared `public', and optionally from `user:runtime_entry/1' and
module declarations.  The way it handles meta-predicates requires that
your application load its module-files before its non-module-files.

   This cross-referencer was written in order to tear out the copious
dead code from the application that the author became responsible for.
If you are doing such a thing, the cross-referencer is an invaluable
tool. Be sure to save the output from the first run that you get from
the cross referencer: this is very useful resource to help you find
things that you've accidentally ripped out and that you really needed
after all.

   There are situations where the cross-referencer does not follow
certain predicates. This can happen if the predicate name is
constructed on the fly, or if it is retrieved from the database. In
this case, add `public' declarations for these.  Alternatively, you
could create term expansions that are peculiar to the cross-referencer.


File: sicstus.info,  Node: The Prolog Library,  Next: Prolog Reference Pages,  Prev: Writing Efficient Programs,  Up: Top

10 The Prolog Library
*********************

The Prolog library comprises a number of packages that are thought to be
useful in a number of applications.  Note that the predicates in the
Prolog library are not built-in predicates.  One has to explicitly load
each package to get access to its predicates.

   To load a library package PACKAGE, you will normally enter a query

     | ?- use_module(library(PACKAGE)).

   A library package normally consists of one or more hidden (*note
ref-mod::) modules.  The following packages are provided:

`aggregate (*note lib-aggregate::)'
     provides an aggregation operator for data-base-style queries.

`assoc (*note lib-assoc::)'
     uses unbalanced binary trees trees to implement "association
     lists", i.e. extendible finite mappings from terms to terms.

`atts (*note lib-atts::)'
     provides a means of associating with variables arbitrary
     attributes, i.e. named properties that can be used as storage
     locations as well as hooks into Prolog's unification.

`avl (*note lib-avl::)'
     uses AVL trees to implement "association lists", i.e. extendible
     finite mappings from terms to terms.

`bags (*note lib-bags::)'
     defines operations on bags, or multisets

`bdb (*note lib-bdb::)'
     provides an interface to Berkeley DB, for storage and retrieval of
     terms on disk files with user-defined multiple indexing.

`between (*note lib-between::)'
     provides some means of generating integers.

`codesio (*note lib-codesio::)'
     defines I/O predicates that read from, or write to, a code-list.

`file_systems (*note lib-file_systems::)'
     accesses files and directories.

`heaps (*note lib-heaps::)'
     implements binary heaps, the main application of which are
     priority queues.

`lists (*note lib-lists::)'
     provides basic operations on lists.

`logarr (*note lib-logarr::)'
     provides an implementation of extendible arrays with logarithmic
     access time.

`objects (*note lib-objects::)'
     provides a package for object-oriented programming, and can be
     regarded as a high-level alternative to `library(structs)'.

`ordsets (*note lib-ordsets::)'
     defines operations on sets represented as lists with the elements
     ordered in Prolog standard order.

`process (*note lib-process::)'
     provides process creation primitives.

`queues (*note lib-queues::)'
     defines operations on queues (FIFO stores of information).

`random (*note lib-random::)'
     provides a random number generator.

`rem (*note lib-rem::)'
     provides Rem's algorithm for maintaining equivalence classes.

`samsort (*note lib-samsort::)'
     provides generic sorting.

`sets (*note lib-sets::)'
     defines operations on sets represented as lists with the elements
     unordered.

`sockets (*note lib-sockets::)'
     provides an interface to sockets.

`structs (*note lib-structs::)'
     provides access to C data structures, and can be regarded as a
     low-level alternative to `library(objects)'.

`system (*note lib-system::)'
     provides access to operating system services.

`terms (*note lib-terms::)'
     provides a number of operations on terms.

`timeout (*note lib-timeout::)'
     Meta-call with limit on execution time.

`trees (*note lib-trees::)'
     uses binary trees to represent non-extendible arrays with
     logarithmic access time.  The functionality is very similar to
     that of `library(logarr)', but `library(trees)' is slightly more
     efficient if the array does not need to be extendible.

`types (*note lib-types::)'
     Provides type checking.

`ugraphs (*note lib-ugraphs::)'
     Provides an implementation of directed and undirected graphs with
     unlabeled edges.

`varnumbers (*note lib-varnumbers::)'
     An inverse of `numbervars/3'.

`wgraphs (*note lib-wgraphs::)'
     provides an implementation of directed and undirected graphs where
     each edge has an integral weight.

`xml (*note lib-xml::)'
     provides an XML parser.

`linda/client (*note lib-linda::)'
`linda/server (*note lib-linda::)'
     provides an implementation of the Linda concept for process
     communication.

`chr (*note lib-chr::)'
     provides Constraint Handling Rules

`clpfd (*note lib-clpfd::)'
     provides constraint solving over Finite (Integer) Domains

`clpq (*note lib-clpqr::)'
`clpr (*note lib-clpqr::)'
     provides constraint solving over Q (Rationals) or R (Reals)

`fdbg (*note lib-fdbg::)'
     provides a debugger for finite domain constraint programs

`pillow (*note lib-pillow::)'
     The PiLLoW Web Programming Library,

`tcltk (*note lib-tcltk::)'
     An interface to the Tcl/Tk language and toolkit.

`gauge (*note lib-gauge::)'
     is a profiling tool for Prolog programs with a graphical interface
     based on `tcltk'.

`prologbeans (*note lib-prologbeans::)'
     Access Prolog from Java.

`comclient (*note lib-comclient::)'
     An interface to Microsoft COM automaton objects.


   For the purpose of migrating code from release 3, the following
*deprecated* library modules are also provided. For documentation,
please see the release 3 documentation for the corresponding library
module with the trailing `3' removed from its name:

`arrays3'

`assoc3'

`lists3'

`queues3'

`random3'

`system3'

* Menu:

* lib-aggregate:: `library(aggregate)'
* lib-assoc:: `library(assoc)'
* lib-atts:: `library(atts)'
* lib-avl:: `library(avl)'
* lib-bags:: `library(bags)'
* lib-bdb:: `library(bdb)'
* lib-between:: `library(between)'
* lib-codesio:: `library(codesio)'
* lib-file_systems:: `library(file_systems)'
* lib-heaps:: `library(heaps)'
* lib-lists:: `library(lists)'
* lib-logarr:: `library(logarr)'
* lib-objects:: `library(objects)'
* lib-ordsets:: `library(ordsets)'
* lib-process:: `library(process)'
* lib-queues:: `library(queues)'
* lib-random:: `library(random)'
* lib-rem:: `library(rem)'
* lib-samsort:: `library(samsort)'
* lib-sets:: `library(sets)'
* lib-sockets:: `library(sockets)'
* lib-structs:: `library(structs)'
* lib-system:: `library(system)'
* lib-terms:: `library(terms)'
* lib-timeout:: `library(timeout)'
* lib-trees:: `library(trees)'
* lib-types:: `library(types)'
* lib-ugraphs:: `library(ugraphs)'
* lib-varnumbers:: `library(varnumbers)'
* lib-wgraphs:: `library(wgraphs)'
* lib-xml:: `library(xml)'
* lib-linda:: `library('linda/client')', `library('linda/server')'
* lib-chr:: `library(chr)'
* lib-clpfd:: `library(clpfd)'
* lib-clpqr:: `library(clpq)', `library(clpr)'
* lib-fdbg:: `library(fdbg)'
* lib-pillow:: `library(pillow)'
* lib-tcltk:: `library(tcltk)'
* lib-gauge:: `library(gauge)'
* lib-prologbeans:: `library(prologbeans)'
* lib-comclient:: `library(comclient)'


File: sicstus.info,  Node: lib-aggregate,  Next: lib-assoc,  Up: The Prolog Library

10.1 An Aggregation Operator for Data-Base-Style Queries--`library(aggregate)'
==============================================================================

Data base query languages usually provide so-called "aggregation"
operations.  Given a relation, aggregation specifies
   * a column of the relation

   * an operation, one of {sum,max,min,ave,var} or more

   One might, for example, ask

         PRINT DEPT,SUM(AREA) WHERE OFFICE(_ID,DEPT,AREA,_OCCUPANT)

   and get a table of <DEPARTMENT,TOTALAREA> pairs.  The Prolog
equivalent of this might be

         dept_office_area(Dept, TotalArea) :-
                 aggregate(sum(Area),
                     I^O^office(I,Dept,Area,O), TotalArea).

   where AREA is the column and `sum(_)' is the aggregation operator.
We can also ask who has the smallest office in each department:

         smallest_office(Dept, Occupant) :-
                 aggregate(min(Area),
                         I^O^office(I,Dept,Area,O), MinArea),
                 office(_, Dept, MinArea, Occupant).

   This module provides an aggregation operator in Prolog:

             aggregate(Template, Generator, Results)

   where:
   * TEMPLATE is OPERATOR(EXPRESSION) or  CONSTRUCTOR(ARG,...,ARG)

   * each ARG is OPERATOR(EXPRESSION)

   * OPERATOR is `sum | min | max'  {for now}

   * EXPRESSION is an arithmetic expression

   RESULTS is unified with a form of the same structure as TEMPLATE.

   Things like mean and standard deviation can be calculated from sums,
e.g. to find the average population of countries (defined as "if you
sampled people at random, what would be the mean size of their answers
to the question 'what is the population of your country?'?") we could do

     ?-  aggregate(x(sum(Pop),sum(Pop*Pop)),
                   Country^population(Country,Pop),
                   x(People,PeopleTimesPops)),
         AveragePop is PeopleTimesPops/People.

   Note that according to this definition, `aggregate/3' FAILS if there
are no solutions.  For `max(_)', `min(_)', and many other operations
(such as `mean(_)') this is the only sensible definition (which is why
`bagof/3' works that way).  Even if BAGOF/3 yielded an empty list,
AGGREGATE/3 would still fail.

   Concerning the minimum and maximum, it is convenient at times to
know Which term had the minimum or maximum value.  So we write

         min(Expression, Term)
         max(Expression, Term)

   and in the constructed term we will have

         min(MinimumValue, TermForThatValue)
         max(MaximumValue, TermForThatValue)

   So another way of asking who has the smallest office is

         smallest_office(Dept, Occupant) :-
                 aggregate(min(Area,O),
                         I^office(I,Dept,Area,O), min(_,Occupant)).

   Consider queries like

         aggregate(sum(Pay), Person^pay(Person,Pay), TotalPay)

   where for some reason `pay/2' might have multiple solutions.  (For
example, someone might be listed in two departments.)  We need a way of
saying "treat identical instances of the Template as a single instance,
UNLESS they correspond to different instances of a Discriminator."
That is what

         aggregate(Template, Discriminator, Generator, Results)

   does.

   Operations available:
`count'
     `sum(1)'

`sum(E)'
     sum of values of E

`min(E)'
     minimum of values of E

`min(E,X)'
     `min(E)' with corresponding instance of X

`max(E)'
     maximum of values of E

`max(E,X)'
     `max(E)' with corresponding instance of X

`set(X)'
     ordered set of instances of X

`bag(X)'
     list of instances of X in generated order.

     bagof(X, G, B) :- aggregate(bag(X),    G, L).
     setof(X, G, B) :- aggregate(set(X), X, G, L).

   Exported predicates:

`forall(:GENERATOR, :GOAL)'
     succeeds when GOAL is provable for each true instance of GENERATOR.
     Note that there is a sort of double negation going on in here (it
     is in effect a nested pair of failure-driven loops), so it will
     never bind any of the variables which occur in it.

`foreach(:GENERATOR, :GOAL)'
     for each proof of Generator in turn, we make a copy of GOAL with
     the appropriate substitution, then we execute these copies in
     sequence.  For example, `foreach(between(1,3,I), p(I))' is
     equivalent to `p(1), p(2), p(3)'.

     Note that this is not the same as `forall/2'.  For example,
     `forall(between(1,3,I), p(I))' is equivalent to `\+ \+ p(1), \+ \+
     p(2), \+ \+ p(3)'.

     The trick in `foreach/2' is to ensure that the variables of GOAL
     which do not occur in GENERATOR are restored properly.  (If there
     are no such variables, you might as well use `forall/2'.)

     Like `forall/2', this predicate does a failure-driven loop over the
     GENERATOR.  Unlike `forall/2', the GOALS are executed as an
     ordinary conjunction, and may succeed in more than one way.

`aggregate(+TEMPLATE, +DISCRIMINATOR, :GENERATOR, -RESULT)'
     is a generalisation of `setof/3' which lets you compute sums,
     minima, maxima, and so on.

`aggregate(+TEMPLATE, :GENERATOR, -RESULT)'
     is a generalisation of `findall/3' which lets you compute sums,
     minima, maxima, and so on.

`aggregate_all(+Template, +Discriminator, :Generator, -Result)'
     is like `aggregate/4' except that it will find at most one
     solution, and does not bind free variables in the GENERATOR.

`aggregate_all(+Template, :Generator, -Result)'
     is like `aggregate/3' except that it will find at most one
     solution, and does not bind free variables in the GENERATOR.

`free_variables(+Goal, +Bound, +Vars0, -Vars)'
     binds VARS to the union of VARS0 with the set of _free_ variables
     in GOAL, that is the set of variables which are captured neither
     by BOUND nor by any internal quantifiers or templates in GOAL.  We
     have to watch out for `setof/3' and `bagof/3' themselves, for the
     explicit existential quantifier `VARS^GOAL', and for things like
     `\+(_)' which might look as though they bind variables but can't.

`term_variables(+TERM, +VARS0, -VARS)'
     binds VARS to a union of VARS0 and the variables which occur in
     TERM.  This doesn't take quantifiers into account at all.


File: sicstus.info,  Node: lib-assoc,  Next: lib-atts,  Prev: lib-aggregate,  Up: The Prolog Library

10.2 Association Lists--`library(assoc)'
========================================

This library provides a binary tree implementation of "association
lists". The binary tree is _not_ kept balanced, as opposed to
`library(avl)', which provides similar functionality based on balanced
AVL trees.

   Exported predicates:

`empty_assoc(?ASSOC)'
     is true when ASSOC is an empty assoc.

`assoc_to_list(+ASSOC, -LIST)'
     assumes that ASSOC is a proper "assoc" tree, and is true when LIST
     is a list of KEY-VALUE pairs in ascending order with no duplicate
     KEYS specifying the same finite function as ASSOC.  Use this to
     convert an assoc to a list.

`gen_assoc(?KEY, +ASSOC, ?VALUE)'
     assumes that ASSOC is a proper "assoc" tree, and is true when KEY
     is associated with VALUE in ASSOC.  Use this to enumerate KEYS and
     VALUES in the ASSOC, or to find KEYS associated with a particular
     VALUE.  If you want to look up a particular KEY, you should use
     `get_assoc/3'.  Note that this predicate is not determinate.  If
     you want to maintain a finite bijection, it is better to maintain
     two assocs than to drive one both ways.  The KEYS and VALUES are
     enumerated in ascending order of KEYS.

`get_assoc(+KEY, +ASSOC, -VALUE)'
     assumes that ASSOC is a proper "assoc" tree.  It is true when KEY
     is identical to (`==') one of the keys in ASSOC, and Value unifies
     with the associated value.  Note that since we use the term
     ordering to identify keys, we obtain logarithmic access, at the
     price that it is not enough for the KEY to unify with a key in
     ASSOC, it must be identical.  This predicate is determinate.  The
     argument order follows the the pattern established by the built-in
     predicate `arg/3' (called the `arg/3', or selector, rule):
              PREDICATE(INDICES, STRUCTURE, ELEMENT).
     The analogy with `arg(N, TERM, ELEMENT)' is that
              KEY:N :: ASSOC:TERM :: VALUE:ELEMENT.

`get_next_assoc(+KEY, +ASSOC, -KNEXT, -VNEXT)'
     is true when KNEXT is the smallest key in ASSOC such that
     KNEXT@>KEY, and VNEXT is the value associated with KNEXT.  If
     there is no such KNEXT, `get_next_assoc/4' naturally fails.  It
     assumes that ASSOC is a proper assoc.  KEY should normally be
     ground.  Note that there is no need for KEY to be in the
     association at all.  You can use this predicate in combination
     with `min_assoc/3' to traverse an association tree; but if there
     are N pairs in the tree the cost will be O(N LG N).  If you want
     to traverse all the pairs, calling `assoc_to_list/2' and walking
     down the list will take O(N) time.

`get_prev_assoc(+KEY, +ASSOC, -KPREV, -VPREV)'
     is true when KPREV is the largest key in ASSOC such that
     KPREV@<KEY, and VPREV is the value associated with KPREV.  You can
     use this predicate in combination with `max_assoc/3' to traverse
     an assoc.  See the notes on `get_next_assoc/4'.

`is_assoc(+THING)'
     is true when THING is a (proper) association tree.  If you use the
     routines in this file, you have no way of constructing a tree with
     an unbound tip, and the heading of this file explicitly warns
     against using variables as keys, so such structures are NOT
     recognised as being association trees.  Note that the code relies
     on variables (to be precise, the first anonymous variable in
     `is_assoc/1') being `@<' than any non-variable.

`list_to_assoc(+LIST, -ASSOC)'
     is true when LIST is a proper list of KEY-VAL pairs (in any order)
     and ASSOC is an association tree specifying the same finite
     function from KEYS to VALUES.  Note that the list should not
     contain any duplicate keys.  In this release, `list_to_assoc/2'
     doesn't check for duplicate keys, but the association tree which
     gets built won't work.

`ord_list_to_assoc(+LIST, -ASSOC)'
     is a version of `list_to_assoc/2' which trusts you to have sorted
     the list already.  If you pair up an ordered set with suitable
     values, calling this instead will save the sort.

`map_assoc(:PRED, +ASSOC)'
     is true when ASSOC is a proper association tree, and for each
     KEY->VAL pair in ASSOC, the proposition PRED(VAL) is true.  PRED
     must be a closure, and ASSOC should be proper.  There should be a
     version of this predicate which passes KEY to PRED as well as VAL,
     but there isn't.

`map_assoc(:PRED, ?OLDASSOC, ?NEWASSOC)'
     is true when OLDASSOC and NEWASSOC are association trees of the
     same shape (at least one of them should be provided as a proper
     assoc, or `map_assoc/3' may not terminate), and for each KEY, if
     KEY is associated with OLD in OLDASSOC and with NEW in NEWASSOC,
     the proposition PRED(OLD,NEW) is true.  Normally we assume that
     PRED is a function from OLD to NEW, but the code does not require
     that.  There should be a version of this predicate which passes
     KEY to PRED as well as OLD and NEW, but there isn't.  If you'd
     have a use for it, please tell us.

`max_assoc(+ASSOC, -KEY, -VAL)'
     is true when KEY is the largest KEY in ASSOC, and VAL is the
     associated value.  It assumes that ASSOC is a proper assoc.  This
     predicate is determinate.  If ASSOC is empty, it just fails
     quietly; an empty set can have no largest element!

`min_assoc(+ASSOC, -KEY, -VAL)'
     is true when KEY is the smallest KEY in ASSOC, and VAL is the
     associated value.  It assumes that ASSOC is a proper assoc.  This
     predicate is determinate.  If ASSOC is empty, it just fails
     quietly; an empty set can have no smallest element!

`portray_assoc(+ASSOC)'
     writes an association tree to the current output stream in a
     pretty form so that you can easily see what it is.  Note that an
     association tree written out this way can NOT be read back in.
     For that, use `writeq/1'.  The point of this predicate is to get
     association trees displayed nicely by `print/1'.

`put_assoc(+KEY, +OLDASSOC, +VAL, -NEWASSOC)'
     is true when OLDASSOC and NEWASSOC define the same finite function,
     except that NEWASSOC associates VAL with KEY.  OLDASSOC need not
     have associated any value at all with Key,


File: sicstus.info,  Node: lib-atts,  Next: lib-avl,  Prev: lib-assoc,  Up: The Prolog Library

10.3 Attributed Variables--`library(atts)'
==========================================

This package implements attributed variables.  It provides a means of
associating with variables arbitrary attributes, i.e. named properties
that can be used as storage locations as well as to extend the default
unification algorithm when such variables are unified with other terms
or with each other.  This facility was primarily designed as a clean
interface between Prolog and constraint solvers, but has a number of
other uses as well.  The basic idea is due to Christian Holzbaur and he
was actively involved in the final design.  For background material,
see the dissertation [Holzbaur 90].

   The package provides a means to declare and access named attributes
of variables.  The attributes are compound terms whose arguments are
the actual attribute values.  The attribute names are _private_ to the
module in which they are defined.  They are defined with a declaration

     :- attribute ATTRIBUTESPEC, ..., ATTRIBUTESPEC.

where each ATTRIBUTESPEC has the form (NAME/ARITY).  There must be at
most one such declaration in a module MODULE.

   Having declared some attribute names, these attributes can now be
added, updated and deleted from unbound variables.  For each declared
attribute name, any variable can have at most one such attribute
(initially it has none).

   The declaration causes the following two access predicates to become
defined by means of the `user:goal_expansion/3' mechanism.  They take a
variable and an ACCESSSPEC as arguments where an ACCESSSPEC is either
`+(ATTRIBUTE)', `-(ATTRIBUTE)', or a list of such.  The `+' prefix may
be dropped for convenience.  The meaning of the `+'/`-' prefix is
documented below:

`MODULE:get_atts(-VAR, ?ACCESSSPEC)'
     Gets the attributes of VAR according to ACCESSSPEC.  If ACCESSSPEC
     is unbound, it will be bound to a list of all set attributes of
     VAR.  Non-variable terms cause a type error to be raised.  The
     prefixes in the ACCESSSPEC have the following meaning:
    `+(ATTRIBUTE)'
          The corresponding actual attribute must be present and is
          unified with ATTRIBUTE.

    `-(ATTRIBUTE)'
          The corresponding actual attribute must be absent.  The
          arguments of ATTRIBUTE are ignored, only the name and arity
          are relevant.

`MODULE:put_atts(-VAR, +ACCESSSPEC)'
     Sets the attributes of VAR according to ACCESSSPEC.  Non-variable
     terms cause a type error to be raised.  The effects of
     `put_atts/2' are undone on backtracking.
    `+(ATTRIBUTE)'
          The corresponding actual attribute is set to ATTRIBUTE.  If
          the actual attribute was already present, it is simply
          replaced.

    `-(ATTRIBUTE)'
          The corresponding actual attribute is removed.  If the actual
          attribute was already absent, nothing happens.

   A module that contains an attribute declaration has an opportunity
to extend the default unification algorithm by defining the following
predicate:

`MODULE:verify_attributes(-VAR, +VALUE, -GOALS)  "hook"'
     This predicate is called whenever a variable VAR that might have
     attributes in MODULE is about to be bound to VALUE (it might have
     none).  The unification resumes after the call to
     `verify_attributes/3'.  VALUE is a non-variable term, or another
     attributed variable.  VAR might have no attributes present in
     MODULE; the unification extension mechanism is not sophisticated
     enough to filter out exactly the variables that are relevant for
     MODULE.

     `verify_attributes/3' is called _before_ VAR has actually been
     bound to VALUE.  If it fails, the unification is deemed to have
     failed.  It may succeed nondeterminately, in which case the
     unification might backtrack to give another answer.  It is
     expected to return, in GOALS, a list of goals to be called _after_
     VAR has been bound to VALUE.

     `verify_attributes/3' may invoke arbitrary Prolog goals, but VAR
     should _not_ be bound by it.  Binding VAR will result in undefined
     behavior.

     If VALUE is a non-variable term, `verify_attributes/3' will
     typically inspect the attributes of VAR and check that they are
     compatible with VALUE and fail otherwise.  If VALUE is another
     attributed variable, `verify_attributes/3' will typically copy the
     attributes of VAR over to VALUE, or merge them with VALUE's, in
     preparation for VAR to be bound to VALUE.  In either case,
     `verify_attributes/3' may determine VAR's current attributes by
     calling `get_atts(VAR,LIST)' with an unbound LIST.

   An important use for attributed variables is in implementing
coroutining facilities as an alternative or complement to the built-in
coroutining mechanisms.  In this context it might be useful to be able
to interpret some of the attributes of a variable as a goal that is
blocked on that variable.  Certain built-in predicates (`frozen/2',
`call_residue/2') and the Prolog top-level need to access blocked
goals, and so need a means of getting the goal interpretation of
attributed variables by calling:

`MODULE:attribute_goal(-VAR, -GOAL)  "hook"'
     This predicate is called in each module that contains an attribute
     declaration, when an interpretation of the attributes as a goal is
     needed, for example in `frozen/2' and `call_residue/2'.  It should
     unify GOAL with the interpretation, or merely fail if no such
     interpretation is available.

   An important use for attributed variables is to provide an interface
to constraint solvers.  An important function for a constraint solver
in the constraint logic programming paradigm is to be able to perform
projection of the residual constraints onto the variables that occurred
in the top-level query.  A module that contains an attribute
declaration has an opportunity to perform such projection of its
residual constraints by defining the following predicate:

`MODULE:project_attributes(+QUERYVARS, +ATTRVARS)  "hook"'
     This predicate is called by the Prolog top level and by the
     built-in predicate `call_residue/2' in each module that contains
     an attribute declaration.  QUERYVARS is the list of variables
     occurring in the query, or in terms bound to such variables, and
     ATTRVARS is a list of possibly attributed variables created during
     the execution of the query.  The two lists of variables may or may
     not be disjoint.

     If the attributes on ATTRVARS can be interpreted as constraints,
     this predicate will typically "project" those constraints onto the
     relevant QUERYVARS.  Ideally, the residual constraints will be
     expressed entirely in terms of the QUERYVARS, treating all other
     variables as existentially quantified.  Operationally,
     `project_attributes/2' must remove all attributes from ATTRVARS,
     and add transformed attributes representing the projected
     constraints to some of the QUERYVARS.

     Projection has the following effect on the Prolog top-level.  When
     the top-level query has succeeded, `project_attributes/2' is
     called first.  The top-level then prints the answer substition and
     residual constraints.  While doing so, it searches for attributed
     variables created during the execution of the query.  For each
     such variable, it calls `attribute_goal/2' to get a printable
     representation of the constraint encoded by the attribute.  Thus,
     `project_attributes/2' is a mechanism for controlling how the
     residual constraints should be displayed at top-level.

     Similarly during the execution of `call_residue(GOAL,RESIDUE)',
     when GOAL has succeeded, `project_attributes/2' is called.  After
     that, all attributed variables created during the execution of GOAL
     are located.  For each such variable, `attribute_goal/2' produces
     a term representing the constraint encoded by the attribute, and
     RESIDUE is unified with the list of all such terms.

     The exact definition of `project_attributes/2' is constraint system
     dependent, but *note Answer Constraints:: and *note CLPQR
     Projection:: for details about projection in CLPFD and CLP(Q,R)
     respectively.

   In the following example we sketch the implementation of a finite
domain "solver".  Note that an industrial strength solver would have to
provide a wider range of functionality and that it quite likely would
utilize a more efficient representation for the domains proper.  The
module exports a single predicate `domain(-VAR,?DOMAIN)', which
associates DOMAIN (a list of terms) with VAR.  A variable can be
queried for its domain by leaving DOMAIN unbound.

   We do not present here a definition for `project_attributes/2'.
Projecting finite domain constraints happens to be difficult.

                                                          _% domain.pl_
     :- module(domain, [domain/2]).

     :- use_module(library(atts)).
     :- use_module(library(ordsets), [
             ord_intersection/3,
             ord_intersect/2,
             list_to_ord_set/2
        ]).

     :- attribute dom/1.

     verify_attributes(Var, Other, Goals) :-
             get_atts(Var, dom(Da)), !,          % are we involved?
             (   var(Other) ->                   % must be attributed then
                 (   get_atts(Other, dom(Db)) -> %   has a domain?
                     ord_intersection(Da, Db, Dc),
                     Dc = [El|Els],              % at least one element
                     (   Els = [] ->             % exactly one element
                         Goals = [Other=El]      % implied binding
                     ;   Goals = [],
                         put_atts(Other, dom(Dc))% rescue intersection
                     )
                 ;   Goals = [],
                     put_atts(Other, dom(Da))    % rescue the domain
                 )
             ;   Goals = [],
                 ord_intersect([Other], Da)      % value in domain?
             ).
     verify_attributes(_, _, []).                % unification triggered
                                                 % because of attributes
                                                 % in other modules

     attribute_goal(Var, domain(Var,Dom)) :-     % interpretation as goal
             get_atts(Var, dom(Dom)).

     domain(X, Dom) :-
             var(Dom), !,
             get_atts(X, dom(Dom)).
     domain(X, List) :-
             list_to_ord_set(List, Set),
             Set = [El|Els],                     % at least one element
             (   Els = [] ->                     % exactly one element
                 X = El                          % implied binding
             ;   put_atts(Fresh, dom(Set)),
                 X = Fresh                       % may call
                                                 % verify_attributes/3
             ).

   Note that the "implied binding" `Other=El' was deferred until after
the completion of `verify_attribute/3'.  Otherwise, there might be a
danger of recursively invoke `verify_attribute/3', which might bind
`Var', which is not allowed inside the scope of `verify_attribute/3'.
Deferring unifications into the third argument of `verify_attribute/3'
effectively serializes th calls to `verify_attribute/3'.

   Assuming that the code resides in the file `domain.pl', we can load
it via:

     | ?- use_module(domain).

   Let's test it:

     | ?- domain(X,[5,6,7,1]), domain(Y,[3,4,5,6]), domain(Z,[1,6,7,8]).

     domain(X,[1,5,6,7]),
     domain(Y,[3,4,5,6]),
     domain(Z,[1,6,7,8])

     | ?- domain(X,[5,6,7,1]), domain(Y,[3,4,5,6]), domain(Z,[1,6,7,8]),
          X=Y.

     Y = X,
     domain(X,[5,6]),
     domain(Z,[1,6,7,8])

     | ?- domain(X,[5,6,7,1]), domain(Y,[3,4,5,6]), domain(Z,[1,6,7,8]),
          X=Y, Y=Z.

     X = 6,
     Y = 6,
     Z = 6

   To demonstrate the use of the GOALS argument of
`verify_attributes/3', we give an implementation of `freeze/2'.  We
have to name it `myfreeze/2' in order to avoid a name clash with the
built-in predicate of the same name.

                                                        _% myfreeze.pl_
     :- module(myfreeze, [myfreeze/2]).

     :- use_module(library(atts)).

     :- attribute frozen/1.

     verify_attributes(Var, Other, Goals) :-
             get_atts(Var, frozen(Fa)), !,       % are we involved?
             (   var(Other) ->                   % must be attributed then
                 (   get_atts(Other, frozen(Fb)) % has a pending goal?
                 ->  put_atts(Other, frozen((Fa,Fb))) % rescue conjunction
                 ;   put_atts(Other, frozen(Fa)) % rescue the pending goal
                 ),
                 Goals = []
             ;   Goals = [Fa]
             ).
     verify_attributes(_, _, []).

     attribute_goal(Var, Goal) :-                % interpretation as goal
             get_atts(Var, frozen(Goal)).

     myfreeze(X, Goal) :-
             put_atts(Fresh, frozen(Goal)),
             Fresh = X.

   Assuming that this code lives in file `myfreeze.pl', we would use it
via:

     | ?- use_module(myfreeze).
     | ?- myfreeze(X,print(bound(x,X))), X=2.

     bound(x,2)                      % side-effect
     X = 2                           % bindings

   The two solvers even work together:

     | ?- myfreeze(X,print(bound(x,X))), domain(X,[1,2,3]),
          domain(Y,[2,10]), X=Y.

     bound(x,2)                      % side-effect
     X = 2,                          % bindings
     Y = 2

   The two example solvers interact via bindings to shared attributed
variables only.  More complicated interactions are likely to be found
in more sophisticated solvers.  The corresponding `verify_attributes/3'
predicates would typically refer to the attributes from other known
solvers/modules via the module prefix in `MODULE:get_atts/2'.


File: sicstus.info,  Node: lib-avl,  Next: lib-bags,  Prev: lib-atts,  Up: The Prolog Library

10.4 AVL Trees--`library(avl)'
==============================

This library module provides an AVL tree implementation of "association
lists". The binary tree _is_ kept balanced, as opposed to
`library(assoc)', which provides similar functionality based on binary
trees that are not kept balanced.

   Exported predicates:

`empty_avl(?AVL)'
     is true when AVL is an empty AVL tree.

`avl_to_list(+AVL, -LIST)'
     assumes that AVL is a proper AVL tree, and is true when LIST is a
     list of KEY-VALUE pairs in ascending order with no duplicate keys
     specifying the same finite function as AVL.  Use this to convert
     an AVL to an ordered list.

`is_avl(+AVL)'
     is true when AVL is a (proper) AVL tree.  It checks both the order
     condition (that the keys are in ascending order as you go from left
     to right) and the height balance condition.  This code relies on
     variables (to be precise, the first anonymous variable in is_avl/1)
     being `@<' than any non-variable.  in strict point of fact you
     _can_ construct an AVL tree with variables as keys, but `is_avl/1'
     doesn't believe it, and it is not good taste to do so.

`avl_domain(+AVL, -DOMAIN)'
     unifies DOMAIN with the ordered set representation of the domain
     of the AVL tree (the keys of it).  As the keys are in ascending
     order with no duplicates, we just read them off like
     `avl_to_list/2'.

`avl_range(+AVL, -RANGE)'
     unifies RANGE with the ordered set representation of the range of
     the AVL (the values associated with its keys, not the keys
     themselves).  Note that the cardinality (length) of the domain and
     the range are seldom equal, except of course for trees
     representing intertible maps.

`avl_min(+AVL, -KEY)'
     is true when KEY is the smallest key in AVL.

`avl_min(+AVL, -KEY, -VAL)'
     is true when KEY is the smallest key in AVL and VAL is its value.

`avl_max(+AVL, -KEY)'
     is true when KEY is the greatest key in AVL.

`avl_max(+AVL, -KEY, -VAL)'
     is true when KEY is the greatest key in AVL and VAL is its value.

`avl_height(+AVL, -HEIGHT)'
     is true when HEIGHT is the height of the given AVL tree, that is,
     the longest path in the tree has HEIGHT 'node's on it.

`avl_size(+AVL, -SIZE)'
     is true when SIZE is the size of the AVL tree, the number of
     'node's in it.

`portray_avl(+AVL)'
     writes an AVL tree to the current output stream in a pretty form so
     that you can easily see what it is.  Note that an AVL tree written
     out this way can NOT be read back in; for that use `writeq/1'.  The
     point of this predicate is to get AVL trees displayed nicely by
     `print/1'.

`avl_member(?KEY, +AVL)'
     is true when KEY is one of the keys in the given AVL.  This
     predicate should be used to enumerate the keys, not to look for a
     particular key (use `avl_fetch/2' or `avl_fetch/3' for that).  The
     KEYS are enumerated in ascending order.

`avl_member(?KEY, +AVL, ?VAL)'
     is true when KEY is one of the keys in the given AVL and VAL is
     the value the AVL associates with that KEY.  This predicate should
     be used to enumerate the keys and their values, not to look up the
     value of a known key (use `avl_fetch/3') for that.  The KEYS are
     enumerated in ascending order.

`avl_fetch(+KEY, +AVL)'
     is true when the (given) KEY is one of the keys in the (given) AVL.
     Use this to test whether a known Key occurs in AVL and you don't
     want to know the value associated with it.

`avl_fetch(+KEY, +AVL, -VAL)'
     is true when the (given) KEY is one of the keys in the (given) AVL
     and the value associated with it therein is VAL.  It should be
     used to look up _known_ keys, not to enumerate keys (use either
     `avl_member/2' or `avl_member/3' for that).

`avl_next(+KEY, +AVL, -KNEXT)'
     is true when KNEXT is the next key after KEY in AVL; that is,
     KNEXT is the smallest key in AVL such that KNEXT @> KEY.

`avl_next(+KEY, +AVL, -KNEXT, -VNEXT)'
     is true when KNEXT is the next key after KEY in AVL and VNEXT is
     the value associated with KNEXT in AVL.  That is, KNEXT is the
     smallest key in AVL such that KNEXT @> KEY, and `avl_fetch(KNEXT,
     VAL, VNEXT)'.

`avl_prev(+KEY, +AVL, -KPREV)'
     is true when KPREV is the key previous to KEY in AVL; that is,
     KPREV is the greatest key in AVL such that KPREV @< KEY.

`avl_prev(+KEY, +AVL, -KPREV, -VPREV)'
     is true when KPREV is the key previous to Key in AVL and VPREV is
     the value associated with KPREV in AVL.  That is, KPREV is the
     greatest key in AVL such that KPREV @< KEY, and `avl_fetch(KPREV,
     AVL, VPREV)'.

`avl_change(+KEY, ?AVL1, ?VAL1, ?AVL2, ?VAL2)'
     is true when AVL1 and AVL2 are avl trees of exactly the same shape,
     KEY is a key of both of them, VAL1 is the value associated with KEY
     in AVL1 and VAL2 is the value associated with it in AVL2, and when
     AVL1 and AVL2 are identical except perhaps for the value they
     assign to KEY.  Use this to change the value associated with a KEY
     which is already present, not to insert a new KEY (it won't).

`ord_list_to_avl(+LIST, -AVL)'
     is given a list of KEY-VAL pairs where the KEYS are already in
     standard order with no duplicates (this is not checked) and
     returns an AVL representing the same associations.  This takes
     O(N) time, unlike `list_to_avl/2' which takes O(N LG N).

`list_to_avl(+PAIRS, -AVL)'
     is given a list of KEY-VAL pairs where the KEYS are in no
     particular order (but are sufficiently instantiated to be told
     apart) and returns an AVL representing the same associations.
     This works by starting with an empty tree and inserting the
     elements of the list into it.  This takes O(N LG N) time.  Since
     it is possible to read off a sorted list in O(N) time from the
     result, O(N LG N) is as good as can possibly be done.  If the same
     KEY appears more than once in the input, the last value associated
     with it will be used.

`avl_store(+KEY, +OLDAVL, +VAL, +NEWAVL)'
     is true when OLDAVL and NEWAVL define the same finite function
     except that NEWAVL associates VAL with KEY.  OLDAVL need not have
     associated any value at all with KEY.  When it didn't, you can
     read this as "insert (KEY->VAL) into OLDAVL giving NEWAVL".

`avl_incr(+KEY, +OLDAVL, +INC, +NEWAVL)'
     if KEY is not present in OLDAVL, adds KEY->INCR.  if KEY->N is
     present in OLDAVL, changes it to KEY->N+INCR.

`avl_delete(+KEY, +OLDAVL, -VAL, -NEWAVL)'
     is true when OLDAVL and NEWAVL define the same finite function
     except that OLDAVL associates KEY with VAL and NEWAVL doesn't
     associate KEY with any value.

`avl_del_min(+OLDAVL, -KEY, -VAL, -NEWAVL)'
     is true when OLDAVL and NEWAVL define the same finite function
     except that OLDAVL associates KEY with VAL and NEWAVL doesn't
     associate KEY with any value and KEY precedes all other keys in
     OLDAVL.

`avl_del_max(+OLDAVL, -KEY, -VAL, -NEWAVL)'
     is true when OLDAVL and NEWAVL define the same finite function
     except that OLDAVL associates KEY with VAL and NEWAVL doesn't
     associate KEY with any value and KEY is preceded by all other keys
     in OLDAVL.

`avl_map(:PRED, +AVL)'
     is true when AVL is an association tree, and for each KEY, if KEY
     is associated with VALUE in AVL, PRED(VALUE) is true.

`avl_map(:PRED, +OLDAVL, -NEWAVL)'
     is true when OLDAVL and NEWAVL are association trees of the same
     shape, and for each KEY, if KEY is associated with OLD in OLDAVL
     and with NEW in NEWAVL, PRED(OLD,NEW) is true.


File: sicstus.info,  Node: lib-bags,  Next: lib-bdb,  Prev: lib-avl,  Up: The Prolog Library

10.5 Bags, or Multisets--`library(bags)'
========================================

This library module provides operations on bags.  Bags are also known
as multisets.  A bag B is a function from a set `dom(B)' to the
non-negative integers.  For the purposes of this module, a bag is
constructed from two functions:

`bag'
     creates an empty bag

`bag(E,M,B)'
     extends the bag B with a _new_ element E which occurs with
     multiplicity M, and which precedes all elements of B in Prolog's
     order.

   A bag is represented by a Prolog term mirroring its construction.
There is one snag with this: what are we to make of
         bag(f(a,Y), 1, bag(f(X,b), 1, bag))     ?
   As a term it has two distinct elements, but `f(a,b)' will be
reported as occurring in it twice.  But according to the definition
above,
         bag(f(a,b), 1, bag(f(a,b), 1, bag))
   is not the representation of any bag, that bag is represented by
         bag(f(a,b), 2, bag)
   alone.  We are apparently stuck with a scheme which is only
guaranteed to work for "sufficiently instantiated" terms, but then,
that's true of a lot of Prolog code.

   The reason for insisting on the order is to make union and
intersection linear in the sizes of their arguments.
`library(ordsets)' does the same for ordinary sets.

   Exported predicates:

`is_bag(+BAG)'
     recognises proper well-formed bags.  You can pass variables to
     `is_bag/1', and it will reject them.

`portray_bag(+BAG)'
     writes a bag to the current output stream in a pretty form so that
     you can easily see what it is.  Note that a bag written out this
     way can _not_ be read back in.  For that, use `write_canonical/1'.
     The point of this predicate is to have bags displayed nicely by
     print/1 and the debugger.  This will print things which are not
     fully instantiated, which is mainly of interest for debugging this
     module.

`checkbag(:PRED, +BAG)'
     is true when BAG is a BAG{E1:M1, ..., EN:MN} with elements EI of
     multiplicity MI, and PRED(EI, MI) is true for each I.

`mapbag(:PRED, +BAG)'
     is true when BAG is a BAG{E1:M1, ..., EN:MN} with elements EI of
     multiplicity MI, and PRED(EI) is true for each element EI.  The
     multiplicities are ignored:  if you don't want this, use
     `checkbag/2'.

`mapbag(:PRED, +OLDBAG, -NEWBAG)'
     is true when OLDBAG is a BAG{E1:M1, ..., EN:MN} and NEWBAG is a
     BAG{F1:M'1, ..., FN:M'N} and the elements of OLDBAG and NEWBAG are
     related by PRED(EI, FJ).  What happens is that the elements of
     OLDBAG are mapped, and then the result is converted to a bag, so
     there is no positional correspondence between EI and FJ.  Even
     when PRED is bidirectional, `mapbag/3' is _not_.  OLDBAG should
     satisfy `is_bag/1' before `mapbag/3' is called.

`somebag(:PRED, +BAG)'
     is true when BAG is a BAG{E1:M1, ..., EN:MN} with elements EI of
     multiplicity MI and PRED(EI, MI) is true of some element EI and
     its multiplicity.  There is no version which ignores the MI.

`somechkbag(:PRED, +BAG)'
     is like `somebag(PRED, BAG)', but commits to the first solution it
     finds.  For example, if `p(X,X,_)', `somechk(p(X), BAG)' would be
     an analogue of `memberchk/2' for bags.

`bag_to_list(+BAG, -LIST)'
     converts a BAG{E1:M1, ..., EN:MN} to a list where each element
     appears as many times as its multiplicity requires.  For example,
     `Bag{a:1, b:3, c:2}' would be converted to `[a,b,b,b,c,c]'.

`bag_to_ord_set(+BAG, -ORDSET)'
     converts a BAG{E1:M1, ..., EN:MN} to a list where each element
     appears once without its multiplicity.  The result is always an
     ordered (representation of a) set, suitable for processing by
     `library(ordsets)'.  See also `bag_to_list/2'.

`bag_to_ord_set(+BAG, +THRESHOLD, -ORDSET)'
     given a BAG{E1:M1, ..., EN:MN} returns a list in standard order of
     the set of elements {EI | MI >= THRESHOLD}.  The result is an
     Ordset.

`list_to_bag(+LIST, -BAG)'
     converts a LIST to a BAG representing the same multi-set.  Each
     element of the List appears once in the BAG together with the
     number of times it appears in the LIST.

`bag_to_set(+BAG, -SET)'
     converts a BAG{E1:M1, ..., EN:MN} to a list which represents the
     SET {E1, ..., EN}.  The order of elements in the result is not
     defined:  for a version where the order is defined use
     `bag_to_ord_set/2'.

`bag_to_set(+BAG, +THRESHOLD, -SET)'
     given a BAG{E1:M1, ..., EN:MN} returns a list which represents the
     SET of elements {EI | MI >= THRESHOLD}.  Because the BAG is sorted,
     the result is necessarily an ordered set.

`empty_bag(?BAG)'
     is true when BAG is the representation of an empty bag.  It can be
     used both to make and to recognise empty bags.

`member(?ELEMENT, ?MULTIPLICITY, +BAG)'
     is true when ELEMENT appears in the multi-set represented by BAG
     with the indicated MULTIPLICITY.  BAG should be instantiated, but
     ELEMENT and MULTIPLICITY may severally be given or solved for.

`memberchk(+ELEMENT, ?MULTIPLICITY, +BAG)'
     is true when ELEMENT appears in the multi-set represented by BAG,
     with the indicated MULTIPLICITY.  It should only be used to check
     whether a given element occurs in the BAG, or whether there is an
     element with the given MULTIPLICITY.  Note that guessing the
     multiplicity and getting it wrong may force the wrong choice of
     clause, but the result will be correct if `is_bag(BAG)'.

`bag_max(+BAG, -COMMONESTELEMENT)'
     unifies COMMONESTELEMENT with the element of BAG which occurs most
     often, picking the leftmost element if several have this
     multiplicity.  To find the multiplicity as well, use `bag_max/3'.
     `bag_max/2' and `bag_min/2' break ties the same way.

`bag_min(+BAG, -RARESTELEMENT)'
     unifies RARESTELEMENT with the element of BAG which occurs least
     often, picking the leftmost element if several have this
     multiplicity.  To find the multiplicity as well, use `bag_min/3'.
     `bag_max/2' and `bag_min/2' break ties the same way, so
              bag_max(Bag, Elt), bag_min(Bag, Elt)
     is true only when all the elements of BAG have the same
     multiplicity.

`bag_max(+BAG, -COMMONESTELEMENT, -MULTIPLICITY)'
     unifies COMMONESTELEMENT with the element of BAG which occurs most
     often, and MULTIPLICITY with the multiplicity of that element.  If
     there are several elements with the same greatest multiplicity,
     the left-most is returned.  `bag_min/3' breaks ties the same way.

`bag_min(+BAG, -RARESTELEMENT)'
     unifies RARESTELEMENT with the element of BAG which occurs least
     often, and MULTIPLICITY with the multiplicity of that element.  If
     there are several elements with the same least multiplicity, the
     left-most is returned.  `bag_max/3' breaks ties the same way, so
              bag_max(Bag, Elt, Mult), bag_min(Bag, Elt, Mult)
     is true only when all the elements of BAG have multiplicity MULT.

`length(+BAG, -BAGCARDINALITY, -SETCARDINALITY)'
     unifies BAGCARDINALITY with the total cardinality of the multi-set
     BAG (the sum of the multiplicities of its elements) and
     SETCARDINALITY with the number of distinct elements.

`make_sub_bag(+BAG, -SUBBAG)'
     enumerates the sub-bags of BAG, unifying SUBBAG with each of them
     in turn.  The order in which the sub-bags are generated is such
     that if SB2 is a sub-bag of SB1 which is a sub-bag of Bag, SB1 is
     generated before SB2.  In particular, Bag is enumerated first and
     bag last.

`test_sub_bag(+BAG, +SUBBAG)'
     is true when SUBBAG is (already) a sub-bag of BAG.  That is, each
     element of SubBag must occur in BAG with at least the same
     multiplicity.  If you know SUBBAG, you should use this to test,
     not `make_sub_bag/2'.

`bag_union(+BAG1, +BAG2, -UNION)'
     unifies UNION with the multi-set union of bags BAG1 and BAG2.

`bag_union(+LISTOFBAGS, -UNION)'
     is true when LISTOFBAGS is given as a proper list of bags and UNION
     is their multi-set union.  Letting K be the length of LISTOFBAGS,
     and N the sum of the sizes of its elements, the cost is O(N LG K).

`bag_intersection(+BAG1, +BAG2, -INTERSECTION)'
     unifies INTERSECTION with the multi-set intersection of bags BAG1
     and BAG2.

`bag_intersection(+LISTOFBAGS, -INTERSECTION)'
     is true when LISTOFBAGS is given as a non-empty proper list of Bags
     and INTERSECTION is their intersection.  The intersection of an
     empty list of Bags would be the universe with infinite
     multiplicities!

`bag_intersect(+BAG1, +BAG2)'
     is true when the multi-sets BAG1 and BAG2 have at least one
     element in common.

`bag_add_element(+BAG1, +ELEMENT, +MULTIPLICITY, -BAG2)'
     computes BAG2 = BAG1 U {ELEMENT:MULTIPLICITY}.  MULTIPLICITY must
     be an integer.

`bag_del_element(+BAG1, +ELEMENT, +MULTIPLICITY, -BAG2)'
     computes BAG2 = BAG1 \ {ELEMENT:MULTIPLICITY}.  MULTIPLICITY must
     be an integer.

`bag_subtract(+BAG1, +BAG2, -DIFFERENCE)'
     is true when DIFFERENCE is the multiset difference of BAG1 and
     BAG2.


File: sicstus.info,  Node: lib-bdb,  Next: lib-between,  Prev: lib-bags,  Up: The Prolog Library

10.6 External Storage of Terms (Berkeley DB)--`library(bdb)'
============================================================

This library module handles storage and retrieval of terms on files.
By using indexing, the store/retrieve operations are efficient also for
large data sets.  The package is an interface to the Berkeley DB
toolset.

* Menu:

* BDB Basics:: Basics
* Current Limitations:: Current Limitations
* Berkeley DB:: Berkeley DB
* The DB-Spec Informal Description:: The DB-Spec---Informal Description
* Predicates:: Predicates
* An Example Session:: An Example Session
* The DB-Spec:: The DB-Spec
* Exporting and importing a database:: Exporting and importing a database


File: sicstus.info,  Node: BDB Basics,  Next: Current Limitations,  Up: lib-bdb

10.6.1 Basics
-------------

The idea is to get a behavior similar to `assert/1', `retract/1' and
`clause/2', but the terms are stored on files instead of in primary
memory.

   The differences compared with the Prolog database are:

   * A "database" must be opened before any access and closed after the
     last access. (There are special predicates for this:
     `db_open/[4,5]' and `db_close/1'.)

   * The functors and the indexing specifications of the terms to be
     stored have to be given when the database is created. (*note The
     DB-Spec::).

   * The indexing is specified when the database is created.  It is
     possible to index on other parts of the term than just the functor
     and first argument.

   * Changes affect the database immediately.

   * The database will store variables with blocked goals as ordinary
     variables.

   Some commercial databases can't store non-ground terms or more than
one instance of a term.  This library module can however store terms of
either kind.


File: sicstus.info,  Node: Current Limitations,  Next: Berkeley DB,  Prev: BDB Basics,  Up: lib-bdb

10.6.2 Current Limitations
--------------------------

   * The terms are not necessarily fetched in the same order as they
     were stored.

   * If the process dies during an update operation (`db_store/3',
     `db_erase/[2,3]'), the database can be inconsistent.

   * Databases can only be shared between processes running on the
     machine where the environment is created (*note Predicates::).  The
     database itself can be on a different machine.

   * The number of terms ever inserted in a database cannot exceed
     2^32-1.

   * Duplicate keys are not handled efficiently by Berkeley DB.  This
     limitation is supposed to get lifted in the future.  Duplicate
     keys can result from indexing on non-key attribute sets, inserting
     terms with variables on indexing positions, or simply from storing
     the same term more than once.


File: sicstus.info,  Node: Berkeley DB,  Next: The DB-Spec Informal Description,  Prev: Current Limitations,  Up: lib-bdb

10.6.3 Berkeley DB
------------------

This library module is an interface to the Berkeley DB toolset to
support persistent storage of Prolog terms.  Some of the notions of
Berkeley DB are directly inherited, e.g. the environment.

   The interface uses the Concurrent Access Methods product of Berkeley
DB.  This means that multiple processes can open the same databas, but
transactions and disaster recovery are not supported.

   The environment and the database files are ordinary Berkeley DB
entities which means that the standard support utilities (e.g.
`db_stat') will work.


File: sicstus.info,  Node: The DB-Spec Informal Description,  Next: Predicates,  Prev: Berkeley DB,  Up: lib-bdb

10.6.4 The DB-Spec--Informal Description
----------------------------------------

The "db-spec" defines which functors are allowed and which parts of a
term are used for indexing in a database.  The syntax of a db-spec is a
skeletal goal with no module.  The db-spec is a list of atoms and
compound terms where the arguments are either `+' or `-'.  A term can
be inserted in the database if there is a spec in the spec list with
the same functor.

   Multilevel indexing is not supported, terms have to be "flattened".

   Every spec with the functor of the "indexed term" specifies an
indexing.  Every argument where there is a `+' in the spec is indexed
on.

   The idea of the db-spec is illustrated with a few examples.  (A
section further down explains the db-spec in a more formal way).

   Given a spec of `[f(+,-), .(+,-), g, f(-,+)]' the indexing works as
follows.  (The parts with indexing are underlined.)

TERM         STORE                             FETCH

`g(x,y)'     domain error                      domain error

`f(A,B)'     `f(A,B)'                          instantiation error
             `-'                               

`f(a,b)'     `f(a,b)  f(a,b)'                  `f(a,b)'
             `- -     -   -'                   `- -'

`[a,b]'      `.(a,.(b,[]))'                    `.(a,.(b,[]))'
             `- -'                             `- -'

`g'          `g'                               `g'
             `-'                               `-'

   The specification `[f(+,-), f(-,+)]' is different from `[f(+,+)]'.
The first specifies that two indices are to be made whereas the second
specifies that only one index is to be made on both arguments of the
term.


File: sicstus.info,  Node: Predicates,  Next: An Example Session,  Prev: The DB-Spec Informal Description,  Up: lib-bdb

10.6.5 Predicates
-----------------

* Menu:

* Conventions:: Conventions
* The Environment:: The Environment
* Memory Leaks:: Memory Leaks
* The Predicates:: The Predicates


File: sicstus.info,  Node: Conventions,  Next: The Environment,  Up: Predicates

10.6.5.1 Conventions
....................

The following conventions are used in the predicate descriptions below.
   * MODE is either `update' or `read' or `enumerate'.  In mode `read'
     no updates can be made.  Mode `enumerate' is like mode `read', but
     indexing cannot be used, i.e. you can only sequentially enumerate
     the items in the database.  In mode `enumerate' only the file
     storing the terms along with their references is used.

   * ENVREF is a reference to an open database environment.  The
     environment is returned when it is opened.  The reference becomes
     invalid after the environment has been closed.

   * DBREF is a reference to an open database.  The reference is
     returned when the database is opened.  The reference becomes
     invalid after the database has been closed.

   * TERMREF is a reference to a term in a given database.  The
     reference is returned when a term is stored.  The reference stays
     valid even after the database has been closed and hence can be
     stored permanently as part of another term.  However, if such
     references are stored in the database, automatic compression of
     the database (using `db_compress/[2,3]') is not possible, in that
     case the user has to write her own compressing predicate.

   * SPECLIST is a description of the indexing scheme; *note The
     DB-Spec::.

   * TERM is any Prolog term.

   * ITERATOR is a non-backtrackable mutable object.  It can be used to
     iterate through a set of terms stored in a database.  The
     iterators are unidirectional.


File: sicstus.info,  Node: The Environment,  Next: Memory Leaks,  Prev: Conventions,  Up: Predicates

10.6.5.2 The Environment
........................

To enable sharing of databases between process, programs have to create
"environments" and the databases should be opened in these
environments.  A database can be shared between processes that open it
in the same environment.  An environment physically consists of a
directory containing the files needed to enable sharing databases
between processes.  The directory of the environment has to be located
in a local file system.

   Databases can be opened outside any environment (see `db_open/4'),
but in that case a process writing the database must ensure exclusive
access or the behavior of the predicates is undefined.


File: sicstus.info,  Node: Memory Leaks,  Next: The Predicates,  Prev: The Environment,  Up: Predicates

10.6.5.3 Memory Leaks
.....................

In order to avoid memory leaks, environments, databases and iterators
should always be closed explicitly.  Consider using `call_cleanup/2' to
automate the closing/deallocation of these objects.  You can always use
`db_current_env/1', `db_current/5' and `db_current_iterator/3' to
enumerate the currently living objects.

     *Please note*: a database must not be closed while there are
     outstanding choices for some `db_fetch/3' goal that refers to that
     database.  Outstanding choices can be removed with a cut (`!').


File: sicstus.info,  Node: The Predicates,  Prev: Memory Leaks,  Up: Predicates

10.6.5.4 The Predicates
.......................

`db_open_env(+ENVNAME, -ENVREF)'
`db_open_env(+ENVNAME, +CACHESIZE, -ENVREF)'
     Opens an environment with the name ENVNAME.  A directory with this
     name is created for the environment if necessary.  ENVNAME is not
     subject to `absolute_file_name/3' conversion.

     By using `db_open_env/3' one can specify the size of the cache:
     CACHESIZE is the (integer) size of the cache in kilobytes.  The
     size of the cache cannot be less than 20 kilobytes.
     `db_open_env/2' will create a cache of the system's default size.

     The size of the cache is determined when the environment is
     created and cannot be changed by future openings.

     A process cannot open the same environment more than once.

`db_close_env(+ENVREF)'
     Closes an environment.  All databases opened in the environment
     will be closed as well.

`db_current_env(?ENVNAME, ?ENVREF)'
     Unifies the arguments with the open environments.  This predicate
     can be used for enumerating all currently open environments
     through backtracking.

`db_open(+DBNAME, +MODE, ?SPECLIST, -DBREF)'
`db_open(+DBNAME, +MODE, ?SPECLIST, +OPTIONS, -DBREF)'
     Opens a database with the name DBNAME.  The database physically
     consists of a directory with the same name, containing the files
     that make up the database.  If the directory does not exist, it is
     created.  In that case MODE must be `update' and the db-spec
     SPECLIST must be ground.  If an existing database is opened and
     MODE is `read' or `update', SPECLIST is unified with the db-spec
     given when the database was created.  If the unification fails an
     error is raised.  DBREF is unified with a reference to the opened
     database.  DBNAME is not subject to `absolute_file_name/3'
     conversion.

     If MODE is `enumerate' then the indexing specification is not
     read, and SPECLIST is left unbound.

     OPTIONS provides a way to specify an environment in which to open
     the database, or a cache size.  OPTIONS should be a list of terms
     of the following form:

    `environment(ENVREF)'
          The database will be opened in this environment.

    `cache_size(CACHESIZE)'
          This is the (integer) size of the cache in kilobytes.  The
          size of the cache cannot be less than 20 kilobytes.  If
          CACHESIZE is given as the atom `default', a default cache
          size will be used.  If CACHESIZE is given as the atom `off'
          or the atom `none', all modified records will be flushed to
          disk after each operation.

     To avoid inconsistency, if multiple processes open the same
     database, then all of them should do that with MODE set to `read'
     or `enumerate'.  (This is not enforced by the system.)

`db_close(+DBREF)'
     Closes the database referenced by DBREF.  Any iterators opened in
     the database will be deallocated.

`db_current(?DBNAME, ?MODE, ?SPECLIST, ?ENVREF, ?DBREF)'
     Unifies the arguments with the open databases.  This predicate can
     be used to enumerate all currently open databases through
     backtracking.  If the database was opened without an environment,
     then ENVREF will be unified with the atom `none'.

`db_store(+DBREF, +TERM, -TERMREF)'
     Stores TERM in the database DBREF.  TERMREF is unified with a
     corresponding term reference.  The functor of TERM must match the
     functor of a spec in the db-spec associated with DBREF.

`db_fetch(+DBREF, ?TERM, ?TERMREF)'
     Unifies TERM with a term from the database DBREF.  At the same
     time, TERMREF is unified with a corresponding term reference.
     Backtracking over the predicate unifies with all terms matching
     TERM.

     If TERMREF is not instantiated then both the functor and the
     instantiatedness of TERM must match a spec in the db-spec
     associated with DBREF.

     If TERMREF is instantiated, the referenced term is read and
     unified with TERM.

     If you simply want to find all matching terms, it is more
     efficient to use `db_findall/5' or `db_enumerate/3'.

`db_erase(+DBREF, +TERMREF)'
`db_erase(+DBREF, +TERMREF, +TERM)'
     Deletes the term from the database DBREF that is referenced by
     TERMREF.

     In the case of `db_erase/2' the term associated with TERMREF has
     to be looked up.  `db_erase/3' assumes that the term TERM is
     identical with the term associated with TERMREF (modulo variable
     renaming).  If this is not the case, the behavior is undefined.

`db_enumerate(+DBREF, ?TERM, ?TERMREF)'
     Unifies TERM with a term from the database DBREF.  At the same
     time, TERMREF is unified with a corresponding term reference.
     Backtracking over the predicate unifies with all terms matching
     TERM.

     Implemented by linear search--the db-spec associated with DBREF is
     ignored.  It is not useful to call this predicate with TERMREF
     instantiated.

`db_findall(+DBREF, +TEMPLATE, +TERM, :GOAL, -BAG)'
     Unifies BAG with the list of instances of TEMPLATE in all proofs
     of GOAL found when TERM is unified with a matching term from the
     database DBREF.  Both the functor and the instantiatedness of TERM
     must match a spec in the db-spec associated with DBREF.
     Conceptually, this predicate is equivalent to `findall(TEMPLATE,
     (db_fetch(DBREF, TERM, _), GOAL), BAG)'.

`db_compress(+DBREF, +DBNAME)'
`db_compress(+DBREF, +DBNAME, +SPECLIST)'
     Copies the database given by DBREF to a new database named by
     DBNAME.  The new database will be a compressed version of the
     first one in the sense that it will not have "holes" resulting
     from deletion of terms.  Deleted term references will also be
     reused, which implies that references that refer to terms in the
     old database will be invalid in the new one.

     `db_compress/2' looks for a database with the db-spec of the
     original one.  `db_compress/3' stores the terms found in the
     original database with the indexing specification SPECLIST.
     `db_compress/2' cannot be used if the database DBREF was opened in
     mode `enumerate'.

     If the database DBNAME already exists then the terms of DBREF will
     be appended to it.  Of course DBNAME must have an indexing
     specification, which enables the terms in DBREF to be inserted
     into it.

     In the case of `db_compress/3' if the database DBNAME does not
     exist, then SPECLIST must be a valid indexing specification.

`db_sync(+DBREF)'
     Flushes any cached information from the database referenced by
     DBREF to stable storage.

`db_make_iterator(+DBREF, -ITERATOR)'
`db_make_iterator(+DBREF, +TERM, -ITERATOR)'
     Creates a new iterator and unifies it with ITERATOR.  Iterators
     created with `db_make_iterator/2' iterate through the whole
     database.  Iterators created with `db_make_iterator/3' iterate
     through the terms that would be found by `db_fetch(DBREF, TERM,
     _)'.

     Every iterator created by `db_make_iterator/[2,3]' must be
     destroyed with `db_iterator_done/1'.

`db_iterator_next(+ITERATOR, -TERM, -TERMREF)'
     ITERATOR advances to the next term, TERM and TERMREF is unified
     with the term and its reference pointed to by ITERATOR.  If there
     is no next term, the predicate fails.

`db_iterator_done(+ITERATOR)'
     Deallocates ITERATOR, which must not be in use anymore.

`db_current_iterator(?DBREF, ?TERM, ?ITERATOR)'
     Unifies the the variables with the respective properties of the
     living iterators.  This predicate can be used to enumerate all
     currently alive iterators through backtracking.  If ITERATOR was
     made with `db_make_iterator/2' then TERM will be left unbound.

`db_export(+DBNAME, +EXPORTFILE)'
`db_export(+DBNAME, +OPTIONS, +EXPORTFILE)'
     Exports the database with the name DBNAME to the text file
     EXPORTFILE. EXPORTFILE can be imported by `db_import/[2,3]'.

     OPTIONS should be an options list of the form acceptable by
     `db_open/[4,5]'.

     In SICStus 3.12.0 `bdb:export/[2,3]' is available instead of
     `db_export/[2,3]'.

`db_import(+DBNAME, +IMPORTFILE)'
`db_import(+DBNAME, +OPTIONS, +IMPORTFILE)'
     Imports the text file IMPORTFILE into the database with the name
     DBNAME.

     If IMPORTFILE is imported into an existing database, the SPECLIST
     found in the IMPORTFILE will be unified with the SPECLIST in the
     database.

     OPTIONS should be an options list of the form acceptable by
     `db_open/[4,5]'.

     In SICStus 3.12.0 `bdb:import/[2,3]' is available instead of
     `db_import/[2,3]'.


File: sicstus.info,  Node: An Example Session,  Next: The DB-Spec,  Prev: Predicates,  Up: lib-bdb

10.6.6 An Example Session
-------------------------

     | ?- db_open(tempdb, update, [a(+,-)], DBRef), assert(tempdb(DBRef)).
     DBRef = '$db'(1077241400)

     | ?- tempdb(DBRef), db_store(DBRef, a(b,1), _).
     DBRef = '$db'(1077241400)

     | ?- tempdb(DBRef), db_store(DBRef, a(c,2), _).
     DBRef = '$db'(1077241400)

     | ?- tempdb(DBRef), db_fetch(DBRef, a(b,X), _).
     X = 1,
     DBRef = '$db'(1077241400) ? ;
     no

     | ?- tempdb(DBRef), db_enumerate(DBRef, X, _).
     X = a(b,1),
     DBRef = '$db'(1077241400) ? ;
     X = a(c,2),
     DBRef = '$db'(1077241400) ? ;
     no

     | ?- db_current(DBName, Mode, Spec, EnvRef, DBRef).
     Mode = update,
     Spec = [a(+,-)],
     DBRef = '$db'(1077241400),
     DBName = tempdb,
     EnvRef = none ? ;
     no

     | ?- tempdb(DBRef), db_close(DBRef).
     DBRef = '$db'(1077241400)


File: sicstus.info,  Node: The DB-Spec,  Next: Exporting and importing a database,  Prev: An Example Session,  Up: lib-bdb

10.6.7 The DB-Spec
------------------

A db-spec has the form of a SPECLIST:

SPECLIST
     = `['SPEC1, ..., SPECM`]'

SPEC
     = FUNCTOR`('ARGSPEC1, ..., ARGSPECN`)'

ARGSPEC
     = `+' | `-'
   where FUNCTOR is a Prolog atom.  The case N = 0 is allowed.

   A spec F`('ARGSPEC1, ..., ARGSPECN`)' is _applicable_ to any nonvar
term with principal functor F/N.

   When storing a term T we generate a hash code for every applicable
spec in the db-spec, and a reference to T is stored with each of them.
(More precisely with each element of the set of generated hash codes).
If T contains nonvar elements on each `+' position in the spec, then
the hash code depends on each of these elements.  If T does contain
some variables on `+' position, then the hash code depends only on the
functor of T.

   When fetching a term Q we look for an applicable spec for which
there are no variables in Q on positions maked `+'.  If no applicable
spec can be found a domain error is raised.  If no spec can be found
where on each `+' position a nonvar term occurs in Q an instantiation
error is raised.  Otherwise, we choose the the spec with the most `+'
postitions in it breaking ties by choosing the leftmost one.

   The terms that contain nonvar terms on every `+' postition will be
looked up using indexing based on the principal functor of the term and
the principal functor of terms on `+' postitions.  The other (more
general) terms will be looked up using an indexing based on the
principal functor of the term only.

   As can be seen, storing and fetching terms with variables on `+'
positions are not vigorously supported operations.


File: sicstus.info,  Node: Exporting and importing a database,  Prev: The DB-Spec,  Up: lib-bdb

10.6.8 Exporting and importing a database
-----------------------------------------

Since the database format of a Berkeley DB may change from version to
version it may become necessary to migrate a database when upgrading.
To this purpose there are two predicates available: `db_export/[2,3]'
and `db_import/[2,3]' (*note The Predicates::).

   The export/import feature was introduced in SICStus 3.12.0, but in
that version you have to use `bdb:export/[2,3]' and `bdb:import/[2,3]'.
Neither is exported from the bdb module, but can be used with module
prefixing.

   Since the bdb interface prior to SICStus 4 uses a custom hash
function (*note Berkeley DB::), the standard Berkeley DB migration
tools will not work when migrating a database from SICStus 3 to SICStus
4.


File: sicstus.info,  Node: lib-between,  Next: lib-codesio,  Prev: lib-bdb,  Up: The Prolog Library

10.7 Generating Integers--`library(between)'
============================================

This library module provides some means of generating integers.
Exported predicates:

`between(+LOWER, +UPPER, -NUMBER)'
     is true when LOWER, UPPER, and NUMBER are integers, and LOWER =<
     NUMBER =< UPPER.  If LOWER and UPPER are given, NUMBER can be
     tested or enumerated.  If either LOWER or UPPER is absent, there
     is not enough information to find it, and an error will be
     reported.

`gen_nat(?N)'
     is true when N is a natural number.  If N is a variable, it will
     enumerate the natural numbers 0,1,2,... and of course not
     terminate.  It is not meant to be applied to anything but integers
     and variables.

`gen_int(?I)'
     is true when I is an integer.  If I is a variable, it will
     enumerate the integers in the order 0, 1, -1, 2, -2, 3, -3, &c.
     Of course this sequence has no end.  It is not meant to be applied
     to anything but integers and variables.

`repeat(+N)'
     (where N is a non-negative integer) succeeds exactly N times.  You
     can only understand it procedurally, and really it is only
     included for compatibility with some other Prologs.

`numlist(?LOWER, ?UPPER, ?LIST)'
     is true when LIST is [LOWER, ..., UPPER], LOWER and UPPER integers.
     For example, `numlist(1, 3, L)' binds `L = [1,2,3]'.  This is not
     yet as general as it ought to be: if LOWER and UPPER are not both
     integers, LIST must be proper, and if LOWER and UPPER are both
     variables, at least one element of List must be an integer.  If
     LOWER = UPPER+1, `numlist(LOWER, UPPER, [])' is true.


File: sicstus.info,  Node: lib-codesio,  Next: lib-file_systems,  Prev: lib-between,  Up: The Prolog Library

10.8 I/O on Lists of Character Codes--`library(codesio)'
========================================================

This package defines I/O predicates that read from, or write to, a
code-list.  There are also predicates to open a stream referring to a
code-list.  The stream may be used with general Stream I/O predicates.

   Exported predicates:

`format_to_codes(+FORMAT, :ARGUMENTS, -CODES)'
`format_to_codes(+FORMAT, :ARGUMENTS, ?S0, ?S)'
     Prints ARGUMENTS into a code-list using `format/3'.  CODES is
     unified with the list, alternatively S0 and S are unified with the
     head and tail of the list, respectively.

`write_to_codes(+TERM, -CODES)'
`write_to_codes(+TERM, ?S0, ?S)'
     A specialized `format_to_codes/[3,4]'. Writes TERM into a
     code-list using `write/2'.  CODES is unified with the list.
     Alternatively, S0 and S are unified with the head and tail of the
     list, respectively.

`write_term_to_codes(+TERM, -CODES, +OPTIONS)'
`write_term_to_codes(+TERM, ?S0, ?S, +OPTIONS)'
     A specialized `format_to_codes/[3,4]'. Writes TERM into a
     code-list using `write_term/3' and OPTIONS.  CODES is unified with
     the list.  Alternatively, S0 and S are unified with the head and
     tail of the list, respectively.

`read_from_codes(+CODES, -TERM)'
     Reads TERM from CODES using `read/2'.  The CODES must, as usual,
     be terminated by a FULL-STOP, i.e. a `.', possibly followed by
     LAYOUT-TEXT.

`read_term_from_codes(+CODES, -TERM, +OPTIONS)'
     Reads TERM from CODES using `read_from_term/3' and OPTIONS.  The
     CODES must, as usual, be terminated by a FULL-STOP, i.e. a `.',
     possibly followed by LAYOUT-TEXT.

`open_codes_stream(+CODES, -STREAM)'
     STREAM is opened as an input stream to an existing code-list.  The
     stream may be read with the Stream I/O predicates and must be
     closed using `close/1'.  The list is copied to an internal buffer
     when the stream is opened and must therefore be a ground code-list
     at that point.

`with_output_to_codes(:GOAL, -CODES)'
`with_output_to_codes(:GOAL, ?S0, ?S)'
`with_output_to_codes(:GOAL, -STREAM, ?S0, ?S)'
     GOAL is called with the `current_output' stream set to a new
     stream. This stream writes to an internal buffer, which is, after
     the successful execution of GOAL, converted to a list of character
     codes.  CODES is unified with the list, alternatively S0 and S are
     unified with the head and tail of the list, respectively.
     `with_output_to_codes/4' also passes the stream in the STREAM
     argument. It can be used only by GOAL for writing.


File: sicstus.info,  Node: lib-file_systems,  Next: lib-heaps,  Prev: lib-codesio,  Up: The Prolog Library

10.9 Accessing Files And Directories--`library(file_systems)'
=============================================================

This module provides operations on files and directories, such as
renaming, deleting, opening, checking permissions, accessing members of.

   The following principles have been observed:

   * An absolute distinction is drawn between files and directories.
     The set of operations one can usefully perform on a directory is
     different from the set one can perform on a file:  for example,
     having write permission to a directory allows the user to create
     new files in it, not to rewrite the entire directory!  If any
     routine in this package tells you that a "file" exists, you can be
     sure that it means a file and not a directory (and vice versa for
     "directory" exists).

   * The directory scanning routines do not actually open the files they
     find.  Thus finer discriminations, such as that between source and
     object code, are not made.

   * All paths are expanded as if by `absolute_file_name/3'.

   * Every predicate acts like a genuine logical relation insofar as it
     possibly can.

   * If anything goes wrong, the predicates in `library(directory)'
     raise an error exception.  Any time that a predicate fails
     quietly, it should mean "this question is meaningful, but the
     answer is no".

   * The directory scanning routines insist that the directory argument
     name a searchable directory.  [PM] 4.0 this was never true (it
     always, and still, barfs if taking property of a non-existing
     object)

   The "property" routines use the same simplistic access control model
as that used by the `absolute_file_name/3' `access/1'-option. *Note
mpg-ref-absolute_file_name::, for details.

   Exported predicates:

`rename_file(+OLDNAME, +NEWNAME)'
     be renamed to NEWNAME.  The details of just when this can be done
     are operating-system dependent.  Typically it is only possible to
     rename within the same file system.

`rename_directory(+OLDNAME, +NEWNAME)'
     be renamed to NEWNAME.  The details of just when this can be done
     are operating-system dependent.  Typically it is only possible to
     rename empty directories within the same file system.

`delete_file(+OLDNAME)'
     OLDNAME must identify an existing file, which will be deleted.

`delete_directory(+DIRECTORY)'
`delete_directory(+DIRECTORY, +OPTIONS)'
     DIRECTORY must identify an existing directory, which will be
     deleted, if empty.  OPTIONS should be a list of at most one term
     of the form:
    `if_nonempty(VALUE)'
          Defines what to do if the directory is nonempty.  One of:
         `ignore'
               The predicate simply succeeds, deleting nothing.

         `fail'
               The predicate simply fails, deleting nothing.

         `error'
               The predicate raises a permisison error.

         `delete'
               The predicate recursively deletes the directory and its
               contents.

`directory_exists(+DIRECTORY)'
`directory_exists(+DIRECTORY, +MODE)'
     is true when DIRECTORY is an existing directory that is accessible
     according to MODE. MODE defaults to `exist'.

     This is more or less equivalent to `absolute_file_name(FILE, _,
     [file_type(directory),access([exist|MODE]),file_errors(fail)])'.

`make_directory(+DIRECTORY)'
     DIRECTORY is expanded, as if by `absolute_file_name/3', and the
     resulting directory is created.

`file_exists(+FILE)'
`file_exists(+FILE, +MODE)'
     is true when FILE is an existing file that is accessible according
     to MODE. MODE defaults to `exist'.

     This is more or less equivalent to `absolute_file_name(FILE, _,
     [access([exist|MODE]),file_errors(fail)])'.

`file_must_exist(+FILE)'
`file_must_exist(+FILE, +MODE)'
     is like `file_exists(FILE[, MODE])' except that if the file is
     _not_ accessible it reports an error.

     This is more or less equivalent to `absolute_file_name(FILE, _,
     [access([exist|MODE]),file_errors(error)])'.

`directory_must_exist(+FILE)'
`directory_must_exist(+FILE, +MODE)'
     is like `file_must_exists(FILE[, MODE])', but for directories.

     This is more or less equivalent to `absolute_file_name(FILE, _,
     [file_type(directory),access([exists|MODE]),file_errors(error)])'.

`close_all_streams'
     closes all the streams (other than the standard streams) which are
     currently open.  The time to call this is after an `abort/0'.
     Note that `current_stream/3' does not notice the standard streams.

`directory_member_of_directory(?BASENAME, ?FULLNAME)'
     is true when BASENAME is the name of a subdirectory of the current
     directory (other than '.' or '..') and FULLNAME is its absolute
     name.

     This uses `absolute_file_name/3' with the `glob/1' option.

`directory_member_of_directory(+DIRECTORY, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a subdirectory of
     that directory (other than '.' or '..') and FULLNAME is its
     absolute name.

     This uses `absolute_file_name/3' with the `glob/1' option.

`directory_member_of_directory(+DIRECTORY, +PATTERN, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a directory of that
     directory (other than '.' or '..') which matches the given PATTERN,
     and FULLNAME is the absolute name of the subdirectory.

     This uses `absolute_file_name/3' with a `glob(PATTERN)' option.

`directory_members_of_directory(-SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the current
     directory.

     This uses `absolute_file_name/3' with the `glob/1' option.

`directory_members_of_directory(+DIRECTORY, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY.  DIRECTORY need not be absolute; the FULLNAMES will be
     regardless.

     This uses `absolute_file_name/3' with the `glob/1' option.

`directory_members_of_directory(+DIRECTORY, +PATTERN, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY, such that each BASENAME matches the given Pattern.

     This uses `absolute_file_name/3' with a `glob(PATTERN)' option.

`file_member_of_directory(?BASENAME, ?FULLNAME)'
     is true when BASENAME is the name of a file in the current
     directory and FULLNAME is its absolute name.

     This uses `absolute_file_name/3' with the `glob/1' option.

`file_member_of_directory(+DIRECTORY, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a file in that
     directory, and FULLNAME is its absolute name.

     This uses `absolute_file_name/3' with the `glob/1' option.

`file_member_of_directory(+DIRECTORY, +PATTERN, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a file in that
     directory which matches the given PATTERN, and FULLNAME is its
     absolute name.

     This uses `absolute_file_name/3' with a `glob(PATTERN)' option.

`file_members_of_directory(-SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of the files in the current directory.

     This uses `absolute_file_name/3' with the `glob/1' option.

`file_members_of_directory(+DIRECTORY, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of the files in the given DIRECTORY.
     DIRECTORY need not be absolute; the FULLNAMES will be regardless.

     This uses `absolute_file_name/3' with the `glob/1' option.

`file_members_of_directory(+DIRECTORY, +PATTERN, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY, such that each BASENAME matches the given PATTERN.

     This uses `absolute_file_name/3' with a `glob(PATTERN)' option.

`directory_property(+DIRECTORY, ?PROPERTY)'
     is true when DIRECTORY is a name of a directory, and PROPERTY is a
     boolean property which that directory possesses, e.g.
              directory_property(., searchable).

     The current set of file and directory properties include:
    `readable'
    `writable'
    `executable'
    `searchable'
          Tries to determine whether the process has permission to
          read, write, execute (only for files) or search (only for
          directories) the file.

    `create_timestamp'
    `modify_timestamp'
    `access_timestamp'
          The time of creation, last modification or last access
          expressed as a timestamp.  A "timestamp" is an integer
          expressing the time interval, in seconds, since the "Epoch".
          The "Epoch" is the time zero hours, zero minutes, zero
          seconds, on January 1, 1970 Coordinated Universal Time (UTC).

          The timestamp is what should be used when comparing
          information between files since it is independent of locale
          issues like time zone and daylight savings time etc.

    `create_localtime'
    `modify_localtime'
    `access_localtime'
          The same as the corresponding `..._timestamp' values passed
          through `system:datime/2', i.e. expressed as local time and
          split up in the components year, month, day, hour, minute,
          seconds.

    `set_user_id'
    `set_group_id'
    `save_text'
          True if the set-uid, set-group-id, save-text bits,
          respectively, are set for the file. Always false on Windows.

    `who_can_read'
    `who_can_write'
    `who_can_execute'
    `who_can_search'
          A list containing the subset of `[user,group,other]' for the
          process classes that can, respectively, read, write, execute
          (only for files) or search (only for directories.

    `owner_user_id'
    `owner_group_id'
          The id of the owner and group of the file. The id is an
          integer on UNIX and an atom (expressed as a string security
          identifier) on Windows.

    `owner_user_name'
    `owner_group_group'
          The atom containing the name of the files owner and group
          respectively. On Windows a name like `'DOMAIN\NAME'' will be
          used.

          If for some reason the name cannot be found it will fall back
          to using the same value as `owner_user_id' and
          `owner_group_id'.


     Other properties may be added in the future. You can backtrack
     through the available properties by calling `file_property/3' or
     `directory_property/3' with an uninstantiated PROPERTY argument.

`directory_property(+DIRECTORY, ?PROPERTY, ?VALUE)'
     is true when DIRECTORY is a name of a directory, PROPERTY is a
     property of directories, and VALUE is DIRECTORY's PROPERTY VALUE.
     See `directory_property/2', above, for a list of properties.

`file_property(+FILE, ?PROPERTY)'
     is true when FILE is a name of a file, and PROPERTY is a boolean
     property which that file possesses, e.g.
              file_property(., readable).
     See `directory_property/2', above, for a list of properties.

`file_property(+FILE, ?PROPERTY, ?VALUE)'
     is true when FILE is a name of a file, PROPERTY is a property of
     files, and VALUE is FILE's PROPERTY VALUE.  See
     `directory_property/2', above, for a list of properties.

`current_directory(-DIRECTORY)'
`current_directory(-DIRECTORY, +NEWDIRECTORY)'
     DIRECTORY is unified with the current working directory and the
     working directory is set to NEWDIRECTORY.


File: sicstus.info,  Node: lib-heaps,  Next: lib-lists,  Prev: lib-file_systems,  Up: The Prolog Library

10.10 Heap Operations--`library(heaps)'
=======================================

A heap is a labelled binary tree where the key of each node is less
than or equal to the keys of its sons.  The point of a heap is that we
can keep on adding new elements to the heap and we can keep on taking
out the minimum element.  If there are N elements total, the total time
is O(N LG N).  If you know all the elements in advance, you are better
off doing a merge-sort, but this file is for when you want to do say a
best-first search, and have no idea when you start how many elements
there will be, let alone what they are.

   A heap is represented as a triple `heap(N,Free,Tree)' where N is the
number of elements in the tree, FREE is a list of integers which
specifies unused positions in the tree, and TREE is a tree made of:
`heap'
     terms for empty subtrees and

`heap(KEY,DATUM,LSON,RSON)'
     terms for the rest

   The nodes of the tree are notionally numbered like this:

                                     1
                      2				    3
              4               6               5               7
          8      12      10     14       9       13      11     15
       ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
   The idea is that if the maximum number of elements that have been in
the heap so far is M, and the tree currently has K elements, the tree
is some subtreee of the tree of this form having exactly M elements,
and the FREE list is a list of M-K integers saying which of the
positions in the M-element tree are currently unoccupied.  This free
list is needed to ensure that the cost of passing N elements through
the heap is O(N LG M) instead of O(N LG N).  For M say 100 and N say
10^4 this means a factor of two.  The cost of the free list is slight.
The storage cost of a heap in a copying Prolog is 2K+3M words.
Exported predicates:

`add_to_heap(+OLDHEAP, +KEY, +DATUM, -NEWHEAP)'

`add_to_heap/4 (heaps)'
     inserts the new KEY-DATUM pair into the heap.  The insertion is
     not stable, that is, if you insert several pairs with the same KEY
     it is not defined which of them will come out first, and it is
     possible for any of them to come out first depending on the
     history of the heap.

`delete_from_heap(+OLDHEAP, +KEY, -DATUM, -NEWHEAP)'

`delete_from_heap/4 (heaps)'
     deletes a single KEY-DATUM pair from the OLDHEAP producing a
     NEWHEAP.  This is useful if you want to e.g. change the priority
     of Datum.

`get_from_heap(+OLDHEAP, -KEY, -DATUM, -NEWHEAP)'

`get_from_heap/4 (heaps)'
     returns the KEY-DATUM pair in OLDHEAP with the smallest KEY, and
     also a NEWHEAP which is the OLDHEAP with that pair deleted.

`heap_size(+HEAP, -SIZE)'

`heap_size/2 (heaps)'
     reports the number of elements currently in the heap.

`heap_to_list(+HEAP, -LIST)'

`heap_to_list/2 (heaps)'
     returns the current set of KEY-DATUM pairs in the HEAP as a LIST,
     sorted into ascending order of KEYS.

`list_to_heap(+LIST, -HEAP)'

`list_to_heap/2 (heaps)'
     takes a list of KEY-DATUM pairs (such as `keysort/2' could be used
     to sort) and forms them into a heap.

`empty_heap(?HEAP)'

`empty_heap/1 (heaps)'
     is true when HEAP represents an empty heap.  There is only one way
     it can be true.

`is_heap(+HEAP)'

`is_heap/1 (heaps)'
     is true when HEAP is a well formed heap.  For this to be true, the
     size must be right and the tree must satisfy the heap condition.

`min_of_heap(+HEAP, -KEY, -DATUM)'

`min_of_heap/3 (heaps)'
     returns the KEY-DATUM pair at the top of the heap (which is of
     course the pair with the smallest KEY), but does not remove it
     from the heap.  It fails if the heap is empty.

`min_of_heap(+HEAP, -KEY1, -DATUM1, -KEY2, -DATUM2)'

`min_of_heap/5 (heaps)'
     returns the smallest (KEY1) and second smallest (KEY2) pairs in
     the heap, without deleting them.  It fails if the heap does not
     have at least two elements.

`portray_heap(+HEAP)'

`portray_heap/1 (heaps)'
     writes a heap to the current output stream in a pretty format so
     that you can easily see what it is.  Note that a heap written out
     this way can _not_ be read back in.  The point of this predicate
     is that you can add a clause
              portray(X) :- is_heap(X), !, portray_heap(X).

